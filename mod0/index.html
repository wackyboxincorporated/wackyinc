<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mod0.71</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'VT323', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
        }
        .tracker-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1px;
            background-color: #333;
            border: 1px solid #444;
        }
        .tracker-cell {
            background-color: #222;
            padding: 2px 4px;
            white-space: pre;
            font-size: 14px; /* Ensure text fits */
        }
        .tracker-header {
            background-color: #444;
            font-weight: bold;
            text-align: center;
        }
        .active-row {
            background-color: #005a00 !important; /* Brighter for visibility */
            color: #ffff00;
        }
        #message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        #message-box.show {
            opacity: 1;
        }
        #message-box.error {
            background-color: #b91c1c; /* red-700 */
            color: white;
        }
        #message-box.info {
            background-color: #047857; /* green-700 */
            color: white;
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #00ff00;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 4px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #047857;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #047857;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-900 text-green-400 p-4">

    <div id="message-box"></div>

    <div class="max-w-7xl mx-auto bg-gray-800 border border-green-500 rounded-lg shadow-lg p-6">
        <h1 class="text-4xl mb-4 text-center text-green-300">mod 0.71</h1>

        <div class="mb-6">
            <label for="file-loader" class="block mb-2 text-lg">load .MOD file</label>
            <input type="file" id="file-loader" accept=".mod" class="block w-full text-sm text-green-400
                file:mr-4 file:py-2 file:px-4
                file:rounded-full file:border-0
                file:text-sm file:font-semibold
                file:bg-green-700 file:text-white
                hover:file:bg-green-600 cursor-pointer"/>
        </div>

        <div class="flex items-center justify-center space-x-4 mb-6">
            <button id="play-button" class="bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-6 rounded-lg disabled:opacity-50" disabled>Play</button>
            <button id="pause-button" class="bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-2 px-6 rounded-lg disabled:opacity-50" disabled>Pause</button>
            <button id="stop-button" class="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-6 rounded-lg disabled:opacity-50" disabled>Stop</button>
        </div>

        <div class="mb-6">
            <label for="volume-slider" class="block mb-2 text-lg">Volume</label>
            <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.75" class="w-full">
        </div>
        
        <div class="mb-6">
            <label for="hz-input" class="block mb-2 text-lg">Set Playback Rate (Hz)</label>
            <div class="flex items-center space-x-2">
                <input type="number" id="hz-input" min="1" value="50" class="w-24 p-2 rounded-md bg-gray-700 border border-gray-600 text-green-400">
                <button id="set-hz-button" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-lg">Apply Hz</button>
            </div>
            <p class="text-sm text-gray-400 mt-1">Recommended: 50 (PAL), 60 (NTSC) or adjust for desired speed.</p>
        </div>

        <div id="song-info" class="mb-6 bg-gray-700 p-4 rounded-lg border border-gray-600">
            <h2 class="text-2xl mb-2 text-green-300">song information</h2>
            <div class="grid grid-cols-2 md:grid-cols-3 gap-2">
                <p><strong>title:</strong> <span id="song-title">N/A</span></p>
                <p><strong>instruments:</strong> <span id="instrument-count">0</span></p>
                <p><strong>patterns:</strong> <span id="pattern-count">0</span></p>
                <p><strong>position:</strong> <span id="current-position">0</span> / <span id="song-length">0</span></p>
                <p><strong>pattern:</strong> <span id="current-pattern">0</span> | <strong>Row:</strong> <span id="current-row">0</span></p>
                <p><strong>speed:</strong> <span id="current-speed">6</span> | <strong>BPM:</strong> <span id="current-bpm">125</span></p>
            </div>
        </div>

        <div id="pattern-view-container" class="bg-gray-900 p-4 rounded-lg border border-gray-700 overflow-x-auto">
             <h2 class="text-2xl mb-2 text-green-300">Pattern Data</h2>
             <div id="pattern-view" class="tracker-grid min-w-[600px]">
                 <div class="tracker-header">Ch 1</div>
                 <div class="tracker-header">Ch 2</div>
                 <div class="tracker-header">Ch 3</div>
                 <div class="tracker-header">Ch 4</div>
                 </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const fileLoader = document.getElementById('file-loader');
            const playButton = document.getElementById('play-button');
            const pauseButton = document.getElementById('pause-button');
            const stopButton = document.getElementById('stop-button');
            const volumeSlider = document.getElementById('volume-slider');
            const hzInput = document.getElementById('hz-input');
            const setHzButton = document.getElementById('set-hz-button');
            const messageBox = document.getElementById('message-box');

            let audioContext;
            let masterGainNode;
            let modFile;
            let playerState = {};
            let sortedPeriods = [];
            let customHz = null; // Stores user-set Hz, null means use MOD BPM/Speed

            // Constants
            const NTSC_CLOCK = 3579545; // NTSC Amiga master clock frequency
            const MIN_PERIOD = 113;
            const MAX_PERIOD = 856;

            // Note period table for PAL Amigas (periods are the same, frequencies differ with clock)
            const periodTable = {
                856: 'C-1', 808: 'C#1', 762: 'D-1', 720: 'D#1', 678: 'E-1', 640: 'F-1', 604: 'F#1', 570: 'G-1', 538: 'G#1', 508: 'A-1', 480: 'A#1', 453: 'B-1',
                428: 'C-2', 404: 'C#2', 381: 'D-2', 360: 'D#2', 339: 'E-2', 320: 'F-2', 302: 'F#2', 285: 'G-2', 269: 'G#2', 254: 'A-2', 240: 'A#2', 226: 'B-2',
                214: 'C-3', 202: 'C#3', 190: 'D-3', 180: 'D#3', 170: 'E-3', 160: 'F-3', 151: 'F#3', 142: 'G-3', 135: 'G#3', 127: 'A-3', 120: 'A#3', 113: 'B-3'
            };

            // Pre-calculate sorted periods for effect lookups
            sortedPeriods = Object.keys(periodTable).map(p => parseInt(p)).sort((a, b) => b - a);
            
            // --- UI & Event Listeners ---
            
            function showMessage(text, type = 'info') {
                messageBox.textContent = text;
                messageBox.className = ``; // Clear classes
                messageBox.classList.add(type, 'show');
                setTimeout(() => messageBox.classList.remove('show'), 3000);
            }

            fileLoader.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            stopPlayback();
                            modFile = parseModFile(e.target.result);
                            if (modFile) {
                                showMessage('MOD file loaded successfully.', 'info');
                                updateSongInfo();
                                resetPlayerState(); // Set initial state
                                displayPattern(modFile.patterns[modFile.patternTable[0]]);
                                playButton.disabled = false;
                            }
                        } catch (error) {
                            console.error("Failed to parse MOD file:", error);
                            showMessage('Failed to parse MOD file. It might be corrupt or unsupported.', 'error');
                            modFile = null;
                            playButton.disabled = true;
                        }
                    };
                    reader.readAsArrayBuffer(file);
                }
            });

            playButton.addEventListener('click', () => {
                if (!modFile) return;

                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    masterGainNode = audioContext.createGain(); // Initialize master gain
                    masterGainNode.connect(audioContext.destination);
                    masterGainNode.gain.value = parseFloat(volumeSlider.value); // Set initial volume
                }
                // Resume context if it was suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                if (playerState.isPaused) { // Resuming from pause
                    playerState.isPaused = false;
                    playerState.isPlaying = true;
                } else if (!playerState.isPlaying) { // Starting from stop
                    startPlayback();
                }
                
                // Always ensure the ticker is running if we are supposed to be playing
                if (playerState.isPlaying && !playerState.timerId) {
                   tick(); 
                }

                playButton.disabled = true;
                pauseButton.disabled = false;
                stopButton.disabled = false;
            });

            pauseButton.addEventListener('click', () => {
                if (playerState.isPlaying) {
                    playerState.isPlaying = false;
                    playerState.isPaused = true;
                    // The tick loop will automatically stop and clear its timer
                    playButton.disabled = false;
                    pauseButton.disabled = true;
                }
            });

            stopButton.addEventListener('click', stopPlayback);

            volumeSlider.addEventListener('input', (event) => {
                if (masterGainNode) {
                    masterGainNode.gain.value = parseFloat(event.target.value);
                }
            });

            setHzButton.addEventListener('click', () => {
                const newHz = parseFloat(hzInput.value);
                if (!isNaN(newHz) && newHz > 0) {
                    customHz = newHz;
                    showMessage(`Playback rate set to ${newHz} Hz.`, 'info');
                    // If playing, restart the tick loop to apply new speed immediately
                    if (playerState.isPlaying) {
                        clearTimeout(playerState.timerId);
                        playerState.timerId = null; // Clear existing timer
                        tick(); // Start new tick loop
                    }
                } else {
                    showMessage('Please enter a valid Hz value (e.g., 50 or 60).', 'error');
                    customHz = null; // Revert to default if invalid
                }
            });

            // --- Core Playback Logic ---

            function resetPlayerState() {
                playerState = {
                    isPlaying: false, isPaused: false,
                    position: 0, row: 0, tick: 0,
                    speed: 6, bpm: 125, timerId: null,
                    channels: Array(4).fill(null).map(() => ({
                        sampleNum: 0, period: 0, volume: 64, noteOn: false,
                        source: null, gainNode: null, effect: { command: 0, value: 0 },
                        portamentoTarget: 0, portamentoSpeed: 0,
                        vibratoSpeed: 0, vibratoDepth: 0, vibratoPos: 0,
                        arpeggioCache: [0,0,0],
                    })),
                };
            }

            function startPlayback() {
                if (!audioContext) return;
                
                resetPlayerState();
                playerState.isPlaying = true;

                // Create gain nodes and connect them to the master gain node
                playerState.channels.forEach(ch => {
                    ch.gainNode = audioContext.createGain();
                    ch.gainNode.connect(masterGainNode); // Connect to master gain
                });
                
                // Initial UI update for the start of the song
                updateSongInfo();
                displayPattern(modFile.patterns[modFile.patternTable[0]]);
            }
            
            function stopPlayback() {
                if(playerState.timerId){
                    clearTimeout(playerState.timerId);
                    playerState.timerId = null;
                }

                if (playerState.channels) {
                    playerState.channels.forEach(ch => {
                        if (ch.source) {
                            try { ch.source.stop(); } catch(e) {}
                            ch.source.disconnect(); // Disconnect old source
                            ch.source = null; // Clear source reference
                        }
                        if (ch.gainNode) {
                            try { ch.gainNode.disconnect(); } catch(e) {}
                            ch.gainNode = null; // Clear gainNode reference
                        }
                    });
                }
                
                // Disconnect master gain node if it exists
                if (masterGainNode) {
                    try { masterGainNode.disconnect(); } catch(e) {}
                    masterGainNode = null;
                }

                // Close audio context if it exists
                if (audioContext) {
                    try { audioContext.close(); } catch(e) {}
                    audioContext = null;
                }

                resetPlayerState(); // Reset all state variables
                
                // Reset UI
                if(modFile) {
                    updateSongInfo();
                    displayPattern(modFile.patterns[modFile.patternTable[0]]);
                    updateActiveRowHighlight(-1); // Remove highlight
                    playButton.disabled = false;
                } else {
                     playButton.disabled = true;
                }
                pauseButton.disabled = true;
                stopButton.disabled = true;
            }
            
            function tick() {
                // If we are no longer playing or paused, stop the loop.
                if (!playerState.isPlaying) {
                    playerState.timerId = null;
                    return;
                }
                
                let tickDuration;
                if (customHz !== null) {
                    tickDuration = 1000 / customHz;
                } else {
                    // Original MOD BPM-driven tempo, adjusted for NTSC 60Hz equivalent at 125 BPM
                    tickDuration = (2083.333 / playerState.bpm); 
                }

                if (playerState.tick === 0) { // New row
                    processRow();
                    updateSongInfo(); // Update song info at start of new row (tick 0)
                } else { // Intermediate tick
                    updateEffects();
                }

                playerState.tick++;
                if (playerState.tick >= playerState.speed) {
                    playerState.tick = 0;
                    playerState.row++;

                    if (playerState.row >= 64) {
                        playerState.row = 0;
                        playerState.position++;
                        if (playerState.position >= modFile.songLength) {
                            playerState.position = 0; // Loop song
                        }
                        const nextPatternIndex = modFile.patternTable[playerState.position];
                        displayPattern(modFile.patterns[nextPatternIndex]);
                    }
                }
                playerState.timerId = setTimeout(tick, tickDuration);
            }
            
            function processRow() {
                const patternIndex = modFile.patternTable[playerState.position];
                if (patternIndex >= modFile.patterns.length) return;
                
                const pattern = modFile.patterns[patternIndex];
                if (!pattern) return;

                const rowData = pattern[playerState.row];
                if (!rowData) return;
                
                updateActiveRowHighlight(playerState.row);

                for (let ch = 0; ch < 4; ch++) {
                    const note = rowData[ch];
                    const channel = playerState.channels[ch];

                    // Store effect for continuous processing in updateEffects()
                    channel.effect = note.effect;
                    
                    if (note.sampleNum > 0) {
                        channel.sampleNum = note.sampleNum - 1;
                        // Set volume to sample's default unless there's a Set Volume (C) effect
                        if(note.effect.command !== 0xC) {
                           channel.volume = modFile.samples[channel.sampleNum].volume;
                        }
                    }

                    if (note.period > 0) {
                        // If not a portamento effect, trigger a new note
                        if (note.effect.command !== 0x3 && note.effect.command !== 0x5) { 
                             channel.period = note.period;
                             channel.noteOn = true;
                             channel.vibratoPos = 0; // Reset vibrato phase
                        }
                        // For portamento, set the target period but don't retrigger the sample
                        channel.portamentoTarget = note.period;
                    }
                    
                    // Handle effects that take place only on tick 0
                    handleTick0Effects(ch, note.effect);

                    if (channel.noteOn && channel.sampleNum < modFile.samples.length) {
                        const sample = modFile.samples[channel.sampleNum];
                        if (sample && sample.data) {
                           playSample(ch, channel.sampleNum, channel.period);
                        }
                        channel.noteOn = false;
                    }
                }
            }
            
            // --- Effect Processing ---

            function handleTick0Effects(ch, effect) {
                const channel = playerState.channels[ch];
                const cmd = effect.command;
                const val = effect.value;

                switch (cmd) {
                    case 0x0: // Arpeggio - set up notes for subsequent ticks
                        if (val > 0) {
                            const x = val >> 4;
                            const y = val & 0x0F;
                            channel.arpeggioCache[0] = channel.period;
                            channel.arpeggioCache[1] = getPeriodForNote(channel.period, x);
                            channel.arpeggioCache[2] = getPeriodForNote(channel.period, y);
                        }
                        break;
                    case 0x3: // Tone Portamento
                    case 0x5: // Tone Portamento + Volume Slide
                        if (val !== 0) channel.portamentoSpeed = val;
                        break;
                    case 0x4: // Vibrato
                    case 0x6: // Vibrato + Volume Slide
                        if ((val & 0xF0) > 0) channel.vibratoSpeed = (val & 0xF0) >> 4;
                        if ((val & 0x0F) > 0) channel.vibratoDepth = (val & 0x0F);
                        // Apply effect on first tick as well
                        updateVibrato(ch); 
                        break;
                    case 0x9: // Sample Offset
                        if (channel.sampleNum < modFile.samples.length) {
                             const offsetInFrames = val * 256;
                             // Retrigger the sample from the offset point
                             playSample(ch, channel.sampleNum, channel.period, offsetInFrames / audioContext.sampleRate);
                             channel.noteOn = false; // We've consumed the note trigger if it was set
                        }
                        break;
                    case 0xB: // Position Jump
                        playerState.position = val;
                        playerState.row = -1; // Will advance to 0 on next tick
                        updateSongInfo(); // Update UI immediately on position jump
                        break;
                    case 0xC: // Set Volume
                        channel.volume = val > 64 ? 64 : val;
                        channel.gainNode.gain.setTargetAtTime(channel.volume / 64, 0, 0.001); // Instant volume change
                        break;
                    case 0xD: // Pattern Break
                        playerState.position++;
                        if (playerState.position >= modFile.songLength) playerState.position = 0;
                        const row = (val >> 4) * 10 + (val & 0x0F);
                        playerState.row = row - 1; // Will advance to target row on next tick
                        if(playerState.row < -1) playerState.row = -1;
                        updateSongInfo(); // Update UI immediately on pattern break
                        break;
                    case 0xF: // Set Speed / BPM
                        if (val > 0) {
                            if (val <= 32) { // Set speed
                                playerState.speed = val;
                            } else { // Set BPM
                                playerState.bpm = val;
                            }
                        }
                        break;
                }
            }
            
            function updateEffects() {
                for (let ch = 0; ch < 4; ch++) {
                    const channel = playerState.channels[ch];
                    if (!channel) continue;
                    const cmd = channel.effect.command;
                    const val = channel.effect.value;

                    switch (cmd) {
                         case 0x0: // Arpeggio
                            if (val > 0) {
                                const arpIndex = playerState.tick % 3;
                                const arpPeriod = channel.arpeggioCache[arpIndex];
                                if (arpPeriod > 0) updatePitch(ch, arpPeriod);
                            }
                            break;
                        case 0x1: // Porta Up
                             channel.period -= val;
                             if(channel.period < MIN_PERIOD) channel.period = MIN_PERIOD;
                             updatePitch(ch, channel.period);
                             break;
                        case 0x2: // Porta Down
                             channel.period += val;
                             if(channel.period > MAX_PERIOD) channel.period = MAX_PERIOD;
                             updatePitch(ch, channel.period);
                             break;
                        case 0x3: // Tone Portamento
                        case 0x5: // Tone Portamento + Volume Slide
                            updatePortamento(ch);
                            break;
                        case 0x4: // Vibrato
                        case 0x6: // Vibrato + Volume Slide
                            updateVibrato(ch);
                            break;
                        case 0xA: // Volume Slide
                        case 0x5: // (Volume slide part)
                        case 0x6: // (Volume slide part)
                            updateVolumeSlide(ch, val);
                            break;
                    }
                }
            }

            function updatePortamento(ch) {
                const channel = playerState.channels[ch];
                if(channel.portamentoTarget > 0) {
                    if (channel.period < channel.portamentoTarget) {
                        channel.period += channel.portamentoSpeed;
                        if (channel.period > channel.portamentoTarget) channel.period = channel.portamentoTarget;
                    } else if (channel.period > channel.portamentoTarget) {
                        channel.period -= channel.portamentoSpeed;
                        if (channel.period < channel.portamentoTarget) channel.period = channel.portamentoTarget;
                    }

                    if (channel.period < MIN_PERIOD) channel.period = MIN_PERIOD;
                    if (channel.period > MAX_PERIOD) channel.period = MAX_PERIOD;
                    
                    updatePitch(ch, channel.period);
                }
            }

            function updateVibrato(ch) {
                const channel = playerState.channels[ch];
                const wave = Math.sin(channel.vibratoPos * 2 * Math.PI);
                const delta = wave * channel.vibratoDepth / 4;
                updatePitch(ch, channel.period + delta);
                
                channel.vibratoPos += channel.vibratoSpeed / 64;
                if(channel.vibratoPos > 1) channel.vibratoPos -= 1;
            }

            function updateVolumeSlide(ch, val) {
                const channel = playerState.channels[ch];
                const up = val >> 4;
                const down = val & 0x0F;

                channel.volume += up;
                channel.volume -= down;

                if(channel.volume < 0) channel.volume = 0;
                if(channel.volume > 64) channel.volume = 64;
                
                channel.gainNode.gain.setTargetAtTime(channel.volume / 64, 0, 0.001);
            }

            function getPeriodForNote(basePeriod, semitoneOffset) {
                const baseIndex = sortedPeriods.reduce((prev, curr) => 
                    (Math.abs(curr - basePeriod) < Math.abs(prev - basePeriod) ? curr : prev));
                
                const newIndex = sortedPeriods.indexOf(baseIndex) - semitoneOffset;
                if (newIndex >= 0 && newIndex < sortedPeriods.length) {
                    return sortedPeriods[newIndex];
                }
                return basePeriod;
            }

            // --- Audio Node Management ---

            function playSample(channelIndex, sampleIndex, period, startOffset = 0) {
                if (!audioContext || sampleIndex >= modFile.samples.length) return;
                const sample = modFile.samples[sampleIndex];
                if (!sample || !sample.data) return;

                const channel = playerState.channels[channelIndex];
                if (channel.source) {
                    try { channel.source.stop(); } catch(e) {}
                    channel.source.disconnect(); // Disconnect old source
                    channel.source = null;
                }

                const buffer = audioContext.createBuffer(1, sample.length, audioContext.sampleRate);
                const bufferData = buffer.getChannelData(0);
                for (let i = 0; i < sample.length; i++) {
                    bufferData[i] = sample.data[i] / 128.0;
                }

                channel.source = audioContext.createBufferSource();
                channel.source.buffer = buffer;
                
                if(sample.repeatLength > 2){ // Amiga MODs have a loop length of 2 bytes (word), meaning 4 actual bytes
                    channel.source.loop = true;
                    channel.source.loopStart = sample.repeatOffset / audioContext.sampleRate;
                    channel.source.loopEnd = (sample.repeatOffset + sample.repeatLength) / audioContext.sampleRate;
                }

                updatePitch(channelIndex, period);
                channel.gainNode.gain.setTargetAtTime(channel.volume / 64, 0, 0.001); // Apply volume immediately
                channel.source.connect(channel.gainNode);
                channel.source.start(0, startOffset);
            }
            
            function updatePitch(channelIndex, period) {
                const channel = playerState.channels[channelIndex];
                if(channel.source && period > 0 && audioContext) {
                    const sample = modFile.samples[channel.sampleNum];
                    
                    const fineTuneFactor = Math.pow(2, (sample.fineTune || 0) / (12 * 8));
                    
                    // Use NTSC_CLOCK for pitch calculation
                    const targetFrequency = (NTSC_CLOCK / period) * fineTuneFactor;
                    const playbackRate = targetFrequency / audioContext.sampleRate;
                    
                    channel.source.playbackRate.setTargetAtTime(playbackRate, 0, 0.001); // Apply pitch immediately
                }
            }
            
            // --- MOD File Parsing ---

            function parseModFile(arrayBuffer) {
                const dv = new DataView(arrayBuffer);
                const textDecoder = new TextDecoder('iso-8859-1');

                const identifier = textDecoder.decode(new Uint8Array(arrayBuffer, 1080, 4));
                const is31Sample = ['M.K.', 'M!K!', 'FLT4', '4CHN'].includes(identifier);
                
                if (!is31Sample) {
                    console.warn(`MOD identifier is '${identifier}', not a standard 31-sample format. Parsing might fail.`);
                }
                
                let mod = {
                    title: textDecoder.decode(new Uint8Array(arrayBuffer, 0, 20)).replace(/\0/g, ''),
                    samples: [],
                    songLength: dv.getUint8(950),
                    patternTable: [],
                    patterns: [],
                    identifier: identifier,
                    numPatterns: 0
                };

                let offset = 20;
                for (let i = 0; i < 31; i++) {
                    let ft = dv.getUint8(offset + 24);
                    // Fine tune is signed 4-bit, convert from unsigned 0-15 to signed -8 to 7
                    if (ft > 7) ft = ft - 16; 

                    const sample = {
                        name: textDecoder.decode(new Uint8Array(arrayBuffer, offset, 22)).replace(/\0/g, ''),
                        length: dv.getUint16(offset + 22) * 2, // Sample length is in words, so multiply by 2 for bytes
                        fineTune: ft,
                        volume: dv.getUint8(offset + 25),
                        repeatOffset: dv.getUint16(offset + 26) * 2, // Repeat offset also in words
                        repeatLength: dv.getUint16(offset + 28) * 2, // Repeat length also in words
                        data: null
                    };
                    mod.samples.push(sample);
                    offset += 30;
                }
                
                offset = 952;
                let maxPattern = 0;
                for (let i = 0; i < 128; i++) {
                    const pNum = dv.getUint8(offset + i);
                    mod.patternTable.push(pNum);
                    if (pNum > maxPattern) maxPattern = pNum;
                }
                mod.numPatterns = maxPattern + 1;

                offset = 1084; // Start of pattern data
                for (let p = 0; p < mod.numPatterns; p++) {
                    let pattern = [];
                    for (let row = 0; row < 64; row++) {
                        let rowData = [];
                        for (let ch = 0; ch < 4; ch++) {
                            const b1 = dv.getUint8(offset++);
                            const b2 = dv.getUint8(offset++);
                            const b3 = dv.getUint8(offset++);
                            const b4 = dv.getUint8(offset++);

                            rowData.push({
                                sampleNum: (b1 & 0xF0) | (b3 >> 4),
                                period: ((b1 & 0x0F) << 8) | b2,
                                effect: { command: b3 & 0x0F, value: b4 }
                            });
                        }
                        pattern.push(rowData);
                    }
                    mod.patterns.push(pattern);
                }

                // Sample Data starts after pattern data
                for (let i = 0; i < 31; i++) {
                    // Only read data if sample has a length
                    if(mod.samples[i].length > 0) {
                        // Ensure repeatLength is at least 2 bytes if looping (Amiga quirk)
                        if (mod.samples[i].repeatLength > 0 && mod.samples[i].repeatLength < 2) {
                            mod.samples[i].repeatLength = 2;
                        }

                        // Cap repeatOffset + repeatLength to sample.length
                        if (mod.samples[i].repeatOffset + mod.samples[i].repeatLength > mod.samples[i].length) {
                            mod.samples[i].repeatLength = mod.samples[i].length - mod.samples[i].repeatOffset;
                        }
                        if (mod.samples[i].repeatLength < 0) mod.samples[i].repeatLength = 0;


                        const sampleData = new Int8Array(arrayBuffer, offset, mod.samples[i].length);
                        mod.samples[i].data = sampleData;
                        offset += mod.samples[i].length;
                    } else {
                        // If sample has no length, ensure its data is null
                        mod.samples[i].data = null;
                        mod.samples[i].repeatLength = 0; // No loop if no length
                    }
                }
                return mod;
            }

            // --- UI Rendering ---

            function updateSongInfo() {
                if (!modFile) return;
                document.getElementById('song-title').textContent = modFile.title || 'N/A';
                document.getElementById('instrument-count').textContent = modFile.samples.filter(s => s.length > 0).length;
                document.getElementById('pattern-count').textContent = modFile.numPatterns;
                document.getElementById('song-length').textContent = modFile.songLength;
                document.getElementById('current-position').textContent = playerState.position;
                document.getElementById('current-pattern').textContent = modFile.patternTable[playerState.position];
                document.getElementById('current-row').textContent = playerState.row;
                document.getElementById('current-speed').textContent = playerState.speed;
                document.getElementById('current-bpm').textContent = playerState.bpm;
            }

            function displayPattern(pattern) {
                const patternView = document.getElementById('pattern-view');
                patternView.innerHTML = `
                    <div class="tracker-header">Ch 1</div>
                    <div class="tracker-header">Ch 2</div>
                    <div class="tracker-header">Ch 3</div>
                    <div class="tracker-header">Ch 4</div>
                `;
                
                if (!pattern) return;
                const fragment = document.createDocumentFragment();

                for (let r = 0; r < 64; r++) {
                    for (let c = 0; c < 4; c++) {
                        const noteData = pattern[r] ? pattern[r][c] : null;
                        if (!noteData) continue;
                        
                        let noteStr = '...';
                        if (noteData.period > 0) {
                             const closestPeriod = sortedPeriods.reduce((prev, curr) => 
                                (Math.abs(curr - noteData.period) < Math.abs(prev - noteData.period) ? curr : prev));
                             noteStr = periodTable[closestPeriod] || '???';
                        }
                        
                        // Sample number is 1-indexed in MOD, display as such
                        const sampleStr = noteData.sampleNum > 0 ? noteData.sampleNum.toString(16).toUpperCase().padStart(2, '0') : '..';
                        const effectStr = noteData.effect.command === 0 && noteData.effect.value === 0 
                            ? '...' 
                            : `${noteData.effect.command.toString(16).toUpperCase()}${noteData.effect.value.toString(16).toUpperCase().padStart(2, '0')}`;
                        
                        const cell = document.createElement('div');
                        cell.className = 'tracker-cell';
                        cell.id = `cell-${r}-${c}`;
                        cell.textContent = `${noteStr} ${sampleStr} ${effectStr}`;
                        fragment.appendChild(cell);
                    }
                }
                patternView.appendChild(fragment);
            }
            
            function updateActiveRowHighlight(row) {
                // Remove all previous active classes - this is more robust
                document.querySelectorAll('.active-row').forEach(cell => {
                    cell.classList.remove('active-row');
                });
                
                // Add class to the new active row
                if (row >= 0) {
                    for(let c = 0; c < 4; c++) {
                        const newActiveCell = document.getElementById(`cell-${row}-${c}`);
                        if (newActiveCell) {
                            newActiveCell.classList.add('active-row');
                        }
                    }
                }
            }
        });
    </script>
</body>
</html>
