<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbiting 3D Objects</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark background */
            color: #e0e0e0;
            display: flex;
            flex-direction: column; /* Changed to column to allow centering of single element */
            align-items: center; /* Center horizontally */
            justify-content: center; /* Center vertically */
            min-height: 100vh;
        }
        canvas {
            display: block;
            width: 100%;
            height: 90vh; /* Increased height to fill more of the screen */
            background-color: #1f1f2a; /* Slightly brighter canvas background */
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <canvas id="threeJsCanvas"></canvas>

    <script>
        // Global variables for Three.js scene components
        let scene, camera, renderer;
        let objects = []; // Array to hold all 3D objects (cubes, triangles, hexagons)

        // Camera orbit parameters
        const cameraOrbitRadius = 35; // Increased camera orbit radius to accommodate more objects
        const cameraOrbitSpeed = 0.0005;

        // Function to create a simple procedural texture (e.g., a checkerboard pattern)
        function createCheckerboardTexture() {
            const size = 64; // Texture size
            const data = new Uint8Array(size * size * 3); // RGB
            const color1 = new THREE.Color(0.8, 0.8, 0.8); // Light gray
            const color2 = new THREE.Color(0.2, 0.2, 0.2); // Dark gray

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const stride = (i * size + j) * 3;
                    const color = (Math.floor(i / (size / 8)) % 2) === (Math.floor(j / (size / 8)) % 2) ? color1 : color2;
                    data[stride] = Math.floor(color.r * 255);
                    data[stride + 1] = Math.floor(color.g * 255);
                    data[stride + 2] = Math.floor(color.b * 255);
                }
            }
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBFormat);
            texture.needsUpdate = true;
            return texture;
        }

        // Initialize the 3D scene
        function init() {
            // Create a new Three.js scene
            scene = new THREE.Scene();
            // Set the scene background to emit a dim global light
            scene.background = new THREE.Color(0x2a2a3a); // A slightly brighter, dim background color

            // Set up the camera
            // PerspectiveCamera(FOV, Aspect Ratio, Near, Far)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(cameraOrbitRadius, 10, 0); // Initial camera position for orbiting

            // Set up the WebGL renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('threeJsCanvas') });
            renderer.setSize(window.innerWidth, window.innerHeight * 0.9); // Set renderer size based on canvas height
            renderer.setPixelRatio(window.devicePixelRatio); // Handle high DPI displays

            // Add improved lighting
            // Ambient light for general illumination
            const ambientLight = new THREE.AmbientLight(0x404040, 1.0);
            scene.add(ambientLight);

            // Hemisphere light for more natural lighting (sky and ground colors)
            const hemisphereLight = new THREE.HemisphereLight(0xb1e1ff, 0xb97a20, 1.0);
            scene.add(hemisphereLight);

            // Directional light 1 (main light source)
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight1.position.set(5, 10, 7).normalize();
            scene.add(directionalLight1);

            // Directional light 2 (fill light from another angle)
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight2.position.set(-5, -10, -7).normalize();
            scene.add(directionalLight2);

            // Add a PointLight for more localized and intense illumination
            const pointLight = new THREE.PointLight(0xffffff, 1.5, 100);
            pointLight.position.set(0, 10, 0);
            scene.add(pointLight);

            // Define common geometry for cubes, triangles, and hexagons
            const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
            const triangleGeometry = new THREE.ConeGeometry(1.5, 2, 3); // Radius, Height, Segments (3 for triangle)
            const hexagonGeometry = new THREE.CylinderGeometry(1.5, 1.5, 1, 6); // RadiusTop, RadiusBottom, Height, Segments (6 for hexagon)

            // Function to generate a random color
            function getRandomColor() {
                const letters = '0123456789ABCDEF';
                let color = '0x';
                for (let i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                return parseInt(color, 16);
            }

            // Function to create a generic 3D object with random properties
            function createRandomObject(geometry, baseRadius, index) {
                const material = new THREE.MeshStandardMaterial({
                    color: getRandomColor(),
                    metalness: Math.random() * 0.5 + 0.5, // Metalness between 0.5 and 1.0
                    roughness: Math.random() * 0.5, // Roughness between 0.0 and 0.5
                    map: createCheckerboardTexture()
                });
                const object = new THREE.Mesh(geometry, material);
                object.userData = {
                    orbitRadius: baseRadius + index * 0.8, // Adjusted increment for more objects
                    orbitSpeed: (Math.random() * 0.005 + 0.002) * (Math.random() > 0.5 ? 1 : -1),
                    orbitOffset: Math.random() * Math.PI * 2,
                    rotationSpeedX: Math.random() * 0.01 + 0.005,
                    rotationSpeedY: Math.random() * 0.01 + 0.005
                };
                objects.push(object);
                scene.add(object);
            }

            // Create the initial 3 cubes
            const initialCubesData = [
                { color: 0xffa07a, metalness: 0.9, roughness: 0.2, orbitRadius: 5, orbitSpeed: 0.005, orbitOffset: 0 },
                { color: 0x87ceeb, metalness: 0.8, roughness: 0.3, orbitRadius: 7, orbitSpeed: 0.003, orbitOffset: Math.PI / 2 },
                { color: 0x98fb98, metalness: 0.7, roughness: 0.4, orbitRadius: 9, orbitSpeed: 0.007, orbitOffset: Math.PI }
            ];

            initialCubesData.forEach(data => {
                const material = new THREE.MeshStandardMaterial({
                    color: data.color,
                    metalness: data.metalness,
                    roughness: data.roughness,
                    map: createCheckerboardTexture()
                });
                const cube = new THREE.Mesh(cubeGeometry, material);
                cube.userData = {
                    orbitRadius: data.orbitRadius,
                    orbitSpeed: data.orbitSpeed,
                    orbitOffset: data.orbitOffset,
                    rotationSpeedX: Math.random() * 0.01 + 0.005,
                    rotationSpeedY: Math.random() * 0.01 + 0.005
                };
                objects.push(cube);
                scene.add(cube);
            });

            // Add 48 more cubes dynamically
            const numberOfNewCubes = 48;
            const baseOrbitRadiusCubes = 12;
            for (let i = 0; i < numberOfNewCubes; i++) {
                createRandomObject(cubeGeometry, baseOrbitRadiusCubes, i);
            }

            // Add 32 triangles dynamically
            const numberOfTriangles = 32;
            const baseOrbitRadiusTriangles = baseOrbitRadiusCubes + numberOfNewCubes * 0.8; // Start after cubes
            for (let i = 0; i < numberOfTriangles; i++) {
                createRandomObject(triangleGeometry, baseOrbitRadiusTriangles, i);
            }

            // Add 32 hexagons dynamically
            const numberOfHexagons = 32;
            const baseOrbitRadiusHexagons = baseOrbitRadiusTriangles + numberOfTriangles * 0.8; // Start after triangles
            for (let i = 0; i < numberOfHexagons; i++) {
                createRandomObject(hexagonGeometry, baseOrbitRadiusHexagons, i);
            }

            // Add event listener for window resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        // Handle window resizing to make the canvas responsive
        function onWindowResize() {
            camera.aspect = window.innerWidth / (window.innerHeight * 0.9);
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight * 0.9);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // Update each object's rotation and orbit
            objects.forEach(object => {
                // Rotate object on its own axis
                object.rotation.x += object.userData.rotationSpeedX;
                object.rotation.y += object.userData.rotationSpeedY;

                // Make object orbit around an invisible central point
                object.position.x = Math.cos(time * object.userData.orbitSpeed + object.userData.orbitOffset) * object.userData.orbitRadius;
                object.position.z = Math.sin(time * object.userData.orbitSpeed + object.userData.orbitOffset) * object.userData.orbitRadius;
                // Add some vertical movement based on orbit speed
                object.position.y = Math.sin(time * object.userData.orbitSpeed * 0.5 + object.userData.orbitOffset) * object.userData.orbitRadius * 0.2;
            });

            // Make the camera orbit around the scene center
            camera.position.x = Math.cos(time * cameraOrbitSpeed) * cameraOrbitRadius;
            camera.position.z = Math.sin(time * cameraOrbitSpeed) * cameraOrbitRadius;
            camera.position.y = Math.sin(time * cameraOrbitSpeed * 0.5) * cameraOrbitRadius * 0.3;

            camera.lookAt(scene.position);

            // Render the scene with the camera
            renderer.render(scene, camera);
        }

        // Initialize the scene and start the animation when the window loads
        window.onload = function() {
            init();
            animate();
        };
    </script>
</body>
</html>
