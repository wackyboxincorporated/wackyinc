<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wChat 2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="main.css">
    <style>
        /* Custom scrollbar for messagesListContainer */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Dark mode scrollbar */
        .dark .custom-scrollbar::-webkit-scrollbar-track {
            background: #333;
        }

        .dark .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #bbb;
        }

        .dark .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #eee;
        }

        /* Overlay for video feeds */
        #videoFeedsContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent background */
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            padding: 1rem;
            box-sizing: border-box;
            z-index: 20; /* Above chat, below modals */
        }

        #localVideo, #remoteVideo {
            max-width: 48%; /* Adjust based on gap and desired size */
            max-height: 100%;
            background-color: black;
            border-radius: 8px;
            object-fit: contain; /* Ensure video fits within bounds without cropping */
        }

        /* Full screen video for remote */
        #remoteVideo.full-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            z-index: 30; /* Above other videos */
        }
    </style>
</head>
<body class="flex flex-col h-screen bg-gray-100 text-gray-900 font-sans">

    <header class="bg-gradient-to-r from-blue-600 to-indigo-700 p-4 shadow-md rounded-b-xl flex justify-between items-center">
        <h1 class="text-3xl font-extrabold text-white">wChat 2</h1>
        <div class="flex items-center space-x-4">
            <button id="userSettingsButton" class="text-white text-2xl p-2 rounded-full hover:bg-white hover:bg-opacity-20 transition-colors duration-200">
                &#x2699;
            </button>
            <span id="userIdDisplay" class="text-sm text-white font-medium bg-blue-500 py-1 px-3 rounded-full shadow-inner">
                Your ID: Loading...
            </span>
            <input
                type="text"
                id="nicknameInput"
                placeholder="Set your nickname"
                class="p-2 rounded-lg bg-white bg-opacity-20 text-white placeholder-gray-200 focus:outline-none focus:ring-2 focus:ring-white transition-all duration-300 w-32 md:w-48"
                maxlength="20"
            />
        </div>
    </header>

    <section class="bg-white dark:bg-gray-800 p-4 shadow-md rounded-b-xl relative">
        <button id="channelToggleButton" class="absolute top-4 right-4 p-1 rounded-full bg-blue-500 text-white shadow-md z-10 transition-transform duration-300 hover:scale-110">
            <svg id="channelToggleIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 transform rotate-0" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
            </svg>
        </button>
        <div id="channelControlArea" class="max-h-0 overflow-hidden transition-all duration-300 ease-in-out">
            <div class="flex flex-col md:flex-row items-center justify-between space-y-3 md:space-y-0 md:space-x-4 pt-2">
                <div class="flex items-center space-x-2 w-full md:w-auto">
                    <label for="channelInput" class="text-gray-700 dark:text-gray-300 font-semibold text-sm">Channel:</label>
                    <input
                        type="text"
                        id="channelInput"
                        placeholder="Enter channel name (password)"
                        class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-100 transition-all duration-300"
                        value="general-chat"
                    />
                </div>
                <button
                    id="joinChannelButton"
                    class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 w-full md:w-auto"
                >
                    Join/Create Channel
                </button>
                <span id="currentChannelDisplay" class="text-blue-700 dark:text-blue-300 font-semibold text-sm w-full text-center md:text-right">
                    Current: #general-chat
                </span>
            </div>
        </div>
    </section>

    <main class="flex flex-1 overflow-hidden relative">
        <button id="sidebarToggle" class="absolute top-4 left-4 p-1 rounded-full bg-blue-500 text-white shadow-md z-10 transition-transform duration-300 hover:scale-110">
            <svg id="toggleIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 transform rotate-0" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
            </svg>
        </button>

        <aside id="sidebar" class="w-0 bg-gray-200 dark:bg-gray-800 transition-all duration-300 ease-in-out overflow-hidden flex-shrink-0">
            <div id="channelListContent" class="p-4 pt-10 h-full overflow-y-auto">
                <h3 class="text-lg font-semibold mb-2 text-gray-800 dark:text-gray-100">Public Channels</h3>
                <ul id="publicChannelList" class="space-y-1">
                </ul>
            </div>
        </aside>

        <div id="chatContentArea" class="flex-1 flex flex-col overflow-hidden">
            <div id="messagesListContainer" class="flex-1 relative overflow-y-auto p-4 space-y-3 custom-scrollbar">
                <div id="noMessagesPlaceholder" class="absolute inset-0 flex items-center justify-center hidden">
                    <p class="text-gray-600 dark:text-gray-400 text-lg">No messages yet. Start the conversation!</p>
                </div>
                <div id="loadingIndicator" class="absolute inset-0 flex items-center justify-center">
                    <div class="text-lg font-semibold animate-pulse">Loading chat...</div>
                </div>
            </div>
        </div>

        <aside id="friendsListSidebar" class="w-0 bg-gray-200 dark:bg-gray-800 transition-all duration-300 ease-in-out overflow-hidden flex-shrink-0">
            <div id="friendsListContent" class="p-4 pt-10 h-full overflow-y-auto">
                <h3 class="text-lg font-semibold mb-2 text-gray-800 dark:text-gray-100">Friends</h3>
                <ul id="friendsList" class="space-y-1">
                    </ul>
            </div>
        </aside>

        <button id="friendsListToggle" class="absolute top-4 right-4 p-1 rounded-full bg-blue-500 text-white shadow-md z-10 transition-transform duration-300 hover:scale-110">
            <svg id="friendsListToggleIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 transform rotate-180" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
            </svg>
        </button>

    </main>

    <form id="messageForm" class="p-4 bg-white dark:bg-gray-800 shadow-md rounded-t-xl flex flex-col space-y-3">
        <div class="flex items-center space-x-2">
            <button id="webrtcToggleButton" class="p-1 rounded-full bg-blue-500 text-white shadow-md z-10 transition-transform duration-300 hover:scale-110">
                <svg id="webrtcToggleIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 transform rotate-0" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
            </button>
            <div id="webrtcMainPanel" class="flex-1 bg-gray-50 dark:bg-gray-700 p-3 rounded-lg shadow-inner">
                <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-100 mb-2">WebRTC Audio/Video Call</h3>
                <div class="flex flex-col md:flex-row items-center space-y-2 md:space-y-0 md:space-x-4 mb-2">
                    <div class="flex items-center space-x-2 w-full">
                        <label for="targetUserIdInput" class="text-gray-700 dark:text-gray-300 text-sm whitespace-nowrap">Target User ID:</label>
                        <input
                            type="text"
                            id="targetUserIdInput"
                            placeholder="Enter User ID to call"
                            class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-100"
                        />
                    </div>
                    <span class="text-gray-500 dark:text-gray-400 font-semibold">OR</span>
                    <div class="flex items-center space-x-2 w-full">
                        <label for="callCodeInput" class="text-gray-700 dark:text-gray-300 text-sm whitespace-nowrap">4-Digit Code:</label>
                        <input
                            type="text"
                            id="callCodeInput"
                            placeholder="Enter 4-digit code to join"
                            class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-100 text-center font-mono text-lg"
                            maxlength="4"
                        />
                        <button type="button" id="generateCallCodeButton" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 whitespace-nowrap">Generate Code</button>
                    </div>
                </div>
                <div class="text-sm font-semibold text-gray-800 dark:text-gray-100 text-center mb-2">
                    Your generated code: <span id="generatedCallCodeDisplay" class="text-green-600 dark:text-green-400 font-bold">N/A</span>
                </div>
                <div class="flex flex-wrap gap-2 mb-2">
                    <button type="button" id="startCallButton" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300">Call</button>
                    <button type="button" id="answerCallButton" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 hidden">Answer</button>
                    <button type="button" id="endCallButton" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 hidden">Hang Up</button>
                    <button type="button" id="toggleVideoButton" class="flex-1 bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 hidden">Enable Video</button>
                    <button type="button" id="toggleAudioButton" class="flex-1 bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 hidden">Mute Audio</button>
                    <button type="button" id="startScreenshareButton" class="flex-1 bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300">Screenshare</button>
                    <button type="button" id="enlargeRemoteVideoButton" class="flex-1 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 hidden">Enlarge Remote Video</button>
                    <button type="button" id="hideLocalVideoButton" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 hidden">Hide My Video</button>
                </div>
                <div id="callStatus" class="text-sm text-gray-700 dark:text-gray-300 text-center relative">
                    Call status: Idle
                    <button id="addFriendFromCallButton" class="ml-2 p-1 rounded-full bg-blue-500 text-white shadow-md transition-colors duration-200 hover:bg-blue-600 text-xs hidden">
                        Add to Friends
                    </button>
                </div>
            </div>
        </div>

        <div class="flex items-center space-x-3">
            <textarea
                id="newMessageInput"
                placeholder="Type your message..."
                class="flex-1 p-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-100 resize-none h-12 overflow-hidden transition-all duration-200 shadow-sm"
                rows="1"
            ></textarea>

            <div class="relative">
                <input type="file" id="fileInput" class="hidden" accept="image/*,video/*,audio/*">
                <button type="button" id="attachFileButton" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M8 4a3 3 0 00-3 3v4a5 5 0 0010 0V7a1 1 0 112 0v4a7 7 0 11-14 0V7a5 5 0 0110 0v4a3 3 0 11-6 0V7a1 1 0 012 0v4a1 1 0 102 0V7a3 3 0 00-3-3z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>

            <button
                type="submit"
                id="sendButton"
                class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
            >
                Send
            </button>
        </div>

        <div id="mediaPreviewContainer" class="hidden bg-gray-100 dark:bg-gray-700 p-3 rounded-lg flex items-center justify-between">
            <span id="selectedFileName" class="text-sm text-gray-800 dark:text-gray-200 truncate"></span>
            <button type="button" id="cancelMediaSelection" class="ml-4 text-red-500 hover:text-red-700 text-sm font-semibold">Cancel</button>
        </div>

        <div id="fileSizeError" class="text-red-500 text-sm mt-2 hidden">
            File size exceeds the limit of 1MB. Please choose a smaller file.
        </div>

        <div id="uploadProgressBarContainer" class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700 hidden">
            <div id="uploadProgressBar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
        </div>

        <div id="audioRecordingStatus" class="flex items-center justify-center space-x-2 mt-2 hidden">
            <span class="text-red-500 text-lg animate-pulse">‚óè Recording...</span>
            <button type="button" id="stopRecordingButton" class="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-lg shadow-md transition-all duration-300">Stop</button>
            <button type="button" id="cancelRecordingButton" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-1 px-3 rounded-lg shadow-md transition-all duration-300">Cancel</button>
        </div>

    </form>

    <div id="videoFeedsContainer" class="hidden">
        <video id="localVideo" class="max-w-1/2 h-auto rounded-lg shadow-lg bg-black" autoplay muted></video>
        <video id="remoteVideo" class="max-w-1/2 h-auto rounded-lg shadow-lg bg-black" autoplay></video>
    </div>

    <div id="userSettingsModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl text-center max-w-md w-full relative">
            <button id="closeSettingsModalButton" class="absolute top-3 right-3 text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 text-2xl">&times;</button>
            <h2 class="text-2xl font-bold mb-4 text-gray-900 dark:text-gray-100">User Settings</h2>
            <div class="mb-4">
                <label for="themeToggle" class="block text-gray-700 dark:text-gray-300 font-semibold mb-2">Dark Mode:</label>
                <input type="checkbox" id="themeToggle" class="toggle toggle-lg toggle-primary" />
            </div>
            <button id="clearCacheButton" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2">
                Clear Local Cache
            </button>
            <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">This will clear your nickname, user ID, and saved channel.</p>
        </div>
    </div>

    <div id="confirmationModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl text-center max-w-sm w-full">
            <h3 class="text-xl font-semibold mb-4 text-gray-900 dark:text-gray-100">Confirm Clear Cache</h3>
            <p class="text-gray-700 dark:text-gray-300 mb-6">Are you sure you want to clear all local data (nickname, user ID, channel)?</p>
            <div class="flex justify-center space-x-4">
                <button id="confirmDeleteYes" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 active:scale-95">
                    Yes, Clear
                </button>
                <button id="confirmDeleteNo" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 active:scale-95">
                    No, Keep
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, onSnapshot, serverTimestamp, doc, getDoc, setDoc, updateDoc, deleteDoc, where, getDocs } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getStorage, ref, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";

        // Your Firebase configuration
        const firebaseConfig = {
            apiKey: "YOUR_API_KEY", // Replace with your actual API Key
            authDomain: "YOUR_AUTH_DOMAIN",
            projectId: "YOUR_PROJECT_ID",
            storageBucket: "YOUR_STORAGE_BUCKET",
            messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
            appId: "YOUR_APP_ID"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const storage = getStorage(app);

        // --- DOM Elements ---
        const userIdDisplay = document.getElementById('userIdDisplay');
        const nicknameInput = document.getElementById('nicknameInput');
        const messagesListContainer = document.getElementById('messagesListContainer');
        const newMessageInput = document.getElementById('newMessageInput');
        const messageForm = document.getElementById('messageForm');
        const noMessagesPlaceholder = document.getElementById('noMessagesPlaceholder');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const sendButton = document.getElementById('sendButton');
        const attachFileButton = document.getElementById('attachFileButton');
        const fileInput = document.getElementById('fileInput');
        const mediaPreviewContainer = document.getElementById('mediaPreviewContainer');
        const selectedFileName = document.getElementById('selectedFileName');
        const cancelMediaSelection = document.getElementById('cancelMediaSelection');
        const fileSizeError = document.getElementById('fileSizeError');
        const uploadProgressBarContainer = document.getElementById('uploadProgressBarContainer');
        const uploadProgressBar = document.getElementById('uploadProgressBar');
        const channelInput = document.getElementById('channelInput');
        const joinChannelButton = document.getElementById('joinChannelButton');
        const currentChannelDisplay = document.getElementById('currentChannelDisplay');
        const channelToggleButton = document.getElementById('channelToggleButton');
        const channelToggleIcon = document.getElementById('channelToggleIcon');
        const channelControlArea = document.getElementById('channelControlArea');
        const sidebarToggle = document.getElementById('sidebarToggle');
        const toggleIcon = document.getElementById('toggleIcon');
        const sidebar = document.getElementById('sidebar');
        const publicChannelList = document.getElementById('publicChannelList');
        const userSettingsButton = document.getElementById('userSettingsButton');
        const userSettingsModal = document.getElementById('userSettingsModal');
        const closeSettingsModalButton = document.getElementById('closeSettingsModalButton');
        const themeToggle = document.getElementById('themeToggle');
        const clearCacheButton = document.getElementById('clearCacheButton');
        const confirmationModal = document.getElementById('confirmationModal');
        const confirmDeleteYes = document.getElementById('confirmDeleteYes');
        const confirmDeleteNo = document.getElementById('confirmDeleteNo');
        const audioRecordingButton = document.getElementById('audioRecordingButton');
        const audioRecordingStatus = document.getElementById('audioRecordingStatus');
        const stopRecordingButton = document.getElementById('stopRecordingButton');
        const cancelRecordingButton = document.getElementById('cancelRecordingButton');

        // WebRTC Elements
        const webrtcToggleButton = document.getElementById('webrtcToggleButton');
        const webrtcToggleIcon = document.getElementById('webrtcToggleIcon');
        const webrtcMainPanel = document.getElementById('webrtcMainPanel');
        const targetUserIdInput = document.getElementById('targetUserIdInput');
        const callCodeInput = document.getElementById('callCodeInput');
        const generateCallCodeButton = document.getElementById('generateCallCodeButton');
        const generatedCallCodeDisplay = document.getElementById('generatedCallCodeDisplay');
        const startCallButton = document.getElementById('startCallButton');
        const answerCallButton = document.getElementById('answerCallButton');
        const endCallButton = document.getElementById('endCallButton');
        const toggleVideoButton = document.getElementById('toggleVideoButton');
        const toggleAudioButton = document.getElementById('toggleAudioButton');
        const startScreenshareButton = document.getElementById('startScreenshareButton'); // New screenshare button
        const enlargeRemoteVideoButton = document.getElementById('enlargeRemoteVideoButton');
        const hideLocalVideoButton = document.getElementById('hideLocalVideoButton');
        const callStatus = document.getElementById('callStatus');
        const videoFeedsContainer = document.getElementById('videoFeedsContainer');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const addFriendFromCallButton = document.getElementById('addFriendFromCallButton'); // New add friend button

        // Friends List Elements
        const friendsListSidebar = document.getElementById('friendsListSidebar');
        const friendsListToggle = document.getElementById('friendsListToggle');
        const friendsListToggleIcon = document.getElementById('friendsListToggleIcon');
        const friendsList = document.getElementById('friendsList');

        // --- Global Variables ---
        let currentUserId = localStorage.getItem('wChatUserId') || null;
        let currentNickname = localStorage.getItem('wChatNickname') || 'Anonymous';
        let currentChannelId = localStorage.getItem('wChatChannelId') || 'general-chat';
        let unsubscribeMessages = null; // To store the unsubscribe function for messages
        let unsubscribePublicChannels = null; // To store the unsubscribe function for public channels
        let fileErrorTimeout; // Timeout for file size error message

        // File/Media related variables
        let currentFile = null; // To hold the selected file Blob (image or video)
        let currentAudioFile = null; // To hold the recorded audio Blob or uploaded audio file
        let currentVideoFile = null; // To hold the recorded video Blob or uploaded video file
        const FIRESTORE_MAX_DOC_SIZE = 1048576; // 1MB in bytes for Firestore document size limit.
        // Base64 encoding adds approximately 33% overhead (multiply by 0.75 for safety).
        const MAX_RAW_FILE_SIZE_BEFORE_ENCODING = Math.floor(FIRESTORE_MAX_DOC_SIZE * 0.75);

        // Voice Recording related variables
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let recordingTimeout;
        const MAX_RECORDING_TIME_MS = 60000; // 1 minute maximum recording

        // WebRTC Global Variables
        let peerConnection;
        let localStream;
        let remoteStream;
        let isCalling = false;
        let callTargetUserId = null;
        let isLocalVideoHidden = false;
        let screenShareStream = null; // For screensharing

        // Friends List Global Variable
        let friends = JSON.parse(localStorage.getItem('wChatFriends')) || [];

        // WebRTC Configuration with STUN and TURN servers
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' } // Added TURN server for better connectivity
            ]
        };

        // Audio elements for call sounds
        const incomingCallSound = new Audio('path/to/incoming-call.mp3'); // Replace with actual path
        const connectSound = new Audio('path/to/connect.mp3'); // Replace with actual path
        incomingCallSound.loop = true;

        // --- Utility Functions ---

        /**
         * Applies the selected theme (dark/light).
         * @param {string} theme - 'dark' or 'light'.
         */
        function applyTheme(theme) {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
                themeToggle.checked = true;
            } else {
                document.documentElement.classList.remove('dark');
                themeToggle.checked = false;
            }
            localStorage.setItem('wChatTheme', theme);
        }

        /**
         * Toggles the visibility of the channel control area.
         */
        function toggleChannelControlArea() {
            channelControlArea.classList.toggle('max-h-0');
            channelControlArea.classList.toggle('max-h-full');
            channelToggleIcon.classList.toggle('rotate-0');
            channelToggleIcon.classList.toggle('rotate-180');
        }

        /**
         * Toggles the visibility of the left sidebar (channel list).
         */
        function toggleSidebar() {
            sidebar.classList.toggle('w-0');
            sidebar.classList.toggle('w-64');
            toggleIcon.classList.toggle('rotate-0');
            toggleIcon.classList.toggle('rotate-180');
        }

        /**
         * Toggles the visibility of the WebRTC main panel.
         */
        function toggleWebRTCPanel() {
            webrtcMainPanel.classList.toggle('hidden');
            webrtcToggleIcon.classList.toggle('rotate-0');
            webrtcToggleIcon.classList.toggle('rotate-180');
        }

        /**
         * Toggles the visibility of the friends list sidebar.
         */
        function toggleFriendsListSidebar() {
            friendsListSidebar.classList.toggle('w-0');
            friendsListSidebar.classList.toggle('w-64');
            friendsListToggleIcon.classList.toggle('rotate-0');
            friendsListToggleIcon.classList.toggle('rotate-180');
        }

        /**
         * Displays a file size error message.
         */
        function showFileSizeMessage() {
            fileSizeError.classList.remove('hidden');
            if (fileErrorTimeout) {
                clearTimeout(fileErrorTimeout);
            }
            fileErrorTimeout = setTimeout(() => {
                hideFileSizeMessage();
            }, 5000); // Message fades after 5 seconds
        }

        /**
         * Hides the file size message.
         */
        function hideFileSizeMessage() {
            fileSizeError.classList.add('hidden');
            if (fileErrorTimeout) {
                clearTimeout(fileErrorTimeout);
                fileErrorTimeout = null;
            }
        }

        /**
         * Scrolls the messages container to the bottom.
         */
        function scrollToBottom() {
            messagesListContainer.scrollTop = messagesListContainer.scrollHeight;
        }

        /**
         * Saves friends list to local storage.
         */
        function saveFriends() {
            localStorage.setItem('wChatFriends', JSON.stringify(friends));
        }

        /**
         * Renders the friends list in the sidebar.
         */
        function renderFriendsList() {
            friendsList.innerHTML = '';
            if (friends.length === 0) {
                friendsList.innerHTML = '<li class="text-gray-600 dark:text-gray-400">No friends yet.</li>';
                return;
            }
            friends.forEach(friend => {
                const li = document.createElement('li');
                li.className = 'flex justify-between items-center bg-gray-100 dark:bg-gray-700 p-2 rounded-lg mb-1 shadow-sm';
                li.innerHTML = `
                    <div>
                        <span class="font-semibold text-blue-700 dark:text-blue-300">${friend.nickname}</span>
                        <p class="text-xs text-gray-500 dark:text-gray-400">ID: ${friend.userId}</p>
                        <p id="note-${friend.userId}" class="text-sm text-gray-600 dark:text-gray-300">${friend.note || 'No note'}</p>
                    </div>
                    <div class="flex space-x-2">
                        <button data-userid="${friend.userId}" class="edit-note-button bg-gray-300 hover:bg-gray-400 text-gray-800 text-xs font-bold py-1 px-2 rounded-lg">Note</button>
                        <button data-userid="${friend.userId}" class="call-friend-button bg-green-500 hover:bg-green-600 text-white text-xs font-bold py-1 px-2 rounded-lg">Call</button>
                    </div>
                `;
                friendsList.appendChild(li);
            });

            // Add event listeners for new buttons
            friendsList.querySelectorAll('.edit-note-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const userId = e.target.dataset.userid;
                    editFriendNote(userId);
                });
            });
            friendsList.querySelectorAll('.call-friend-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const userId = e.target.dataset.userid;
                    callFriend(userId);
                });
            });
        }

        /**
         * Adds a friend to the friends list.
         * @param {string} userId - The user ID to add.
         * @param {string} nickname - The nickname of the user.
         */
        function addFriend(userId, nickname) {
            if (!friends.some(friend => friend.userId === userId)) {
                friends.push({ userId: userId, nickname: nickname, note: '' });
                saveFriends();
                renderFriendsList();
                alert(`${nickname} added to your friends list!`);
            } else {
                alert(`${nickname} is already in your friends list.`);
            }
        }

        /**
         * Edits the note for a friend.
         * @param {string} userId - The user ID of the friend to edit.
         */
        function editFriendNote(userId) {
            const friend = friends.find(f => f.userId === userId);
            if (friend) {
                const currentNote = friend.note;
                const newNote = prompt(`Edit note for ${friend.nickname}:`, currentNote);
                if (newNote !== null) { // If user didn't cancel
                    friend.note = newNote;
                    saveFriends();
                    renderFriendsList(); // Re-render to show updated note
                }
            }
        }

        /**
         * Initiates a call to a friend from the friends list.
         * @param {string} userId - The user ID of the friend to call.
         */
        async function callFriend(userId) {
            if (isCalling) {
                alert('You are already in a call. Please hang up first.');
                return;
            }
            targetUserIdInput.value = userId; // Set target user ID
            // Automatically start the call
            startCallButton.click();
        }

        /**
         * Starts screensharing.
         */
        async function startScreenshare() {
            try {
                if (screenShareStream) {
                    // Already screensharing, stop it
                    screenShareStream.getTracks().forEach(track => track.stop());
                    screenShareStream = null;
                    startScreenshareButton.textContent = 'Screenshare';
                    // Re-add local camera video if it was active
                    if (localStream) {
                        localStream.getVideoTracks().forEach(track => {
                            peerConnection.removeTrack(peerConnection.getSenders().find(sender => sender.track === track));
                        });
                        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
                        localVideo.srcObject = localStream;
                        toggleVideoButton.textContent = 'Disable Video';
                        toggleAudioButton.textContent = 'Mute Audio';
                        toggleVideoButton.classList.remove('hidden');
                        toggleAudioButton.classList.remove('hidden');
                    }
                    return;
                }

                // Request screen share
                screenShareStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });

                if (localStream) {
                    // Replace local video track with screen share track
                    localStream.getVideoTracks().forEach(track => {
                        peerConnection.removeTrack(peerConnection.getSenders().find(sender => sender.track === track));
                        track.stop(); // Stop original camera track
                    });
                    localStream.getAudioTracks().forEach(track => {
                        peerConnection.removeTrack(peerConnection.getSenders().find(sender => sender.track === track));
                    });
                    localStream = null; // Clear localStream
                }


                screenShareStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, screenShareStream);
                    track.onended = () => {
                        // User stopped screenshare from browser UI
                        startScreenshare(); // Call again to clean up and potentially restart camera
                    };
                });
                localVideo.srcObject = screenShareStream;
                startScreenshareButton.textContent = 'Stop Screenshare';

                // Hide video/audio controls while screensharing
                toggleVideoButton.classList.add('hidden');
                toggleAudioButton.classList.add('hidden');

            } catch (error) {
                console.error("Error starting screenshare:", error);
                callStatus.textContent = `Screenshare failed: ${error.message}`;
                startScreenshareButton.textContent = 'Screenshare';
            }
        }

        // --- Firebase Functions ---

        /**
         * Initializes Firebase authentication and Firestore.
         * Sets up the authentication state listener.
         */
        async function initializeFirebase() {
            try {
                await signInAnonymously(auth);
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        localStorage.setItem('wChatUserId', currentUserId);
                        userIdDisplay.textContent = `Your ID: ${currentUserId.substring(0, 8)}...`; // Display a short version of ID
                        setupRealtimeListeners();
                        loadNickname();
                        loadChannel();
                        renderFriendsList(); // Initial render of friends list
                    } else {
                        console.log("No user is signed in.");
                        userIdDisplay.textContent = 'Your ID: Not logged in';
                    }
                });
            } catch (error) {
                console.error("Error initializing Firebase:", error);
                userIdDisplay.textContent = 'Firebase Error';
            }
        }

        /**
         * Loads nickname from local storage or sets a default.
         */
        function loadNickname() {
            const savedNickname = localStorage.getItem('wChatNickname');
            if (savedNickname) {
                currentNickname = savedNickname;
                nicknameInput.value = savedNickname;
            } else {
                nicknameInput.value = currentNickname;
            }
        }

        /**
         * Loads channel from local storage or sets a default.
         */
        function loadChannel() {
            const savedChannel = localStorage.getItem('wChatChannelId');
            if (savedChannel) {
                currentChannelId = savedChannel;
                channelInput.value = savedChannel;
                currentChannelDisplay.textContent = `Current: #${savedChannel}`;
            } else {
                channelInput.value = currentChannelId;
                currentChannelDisplay.textContent = `Current: #${currentChannelId}`;
            }
        }

        /**
         * Sets up real-time listeners for messages and public channels.
         */
        function setupRealtimeListeners() {
            // Unsubscribe from previous listeners if they exist
            if (unsubscribeMessages) {
                unsubscribeMessages();
            }
            if (unsubscribePublicChannels) {
                unsubscribePublicChannels();
            }

            // Messages listener
            const messagesRef = collection(db, `artifacts/${app.options.appId}/public/data/channels/${currentChannelId}/messages`);
            const q = query(messagesRef, orderBy('timestamp'));

            unsubscribeMessages = onSnapshot(q, (snapshot) => {
                loadingIndicator.classList.add('hidden'); // Hide loading indicator once data is received
                messagesListContainer.innerHTML = ''; // Clear messages again before rendering
                const messages = [];
                // Show/hide no messages placeholder based on snapshot emptiness
                if (snapshot.empty) {
                    noMessagesPlaceholder.classList.remove('hidden');
                } else {
                    noMessagesPlaceholder.classList.add('hidden');
                }
                // Populate messages array with data and document IDs
                snapshot.forEach((doc) => {
                    messages.push({ ...doc.data(), id: doc.id });
                });
                renderMessages(messages); // Render the fetched messages
                scrollToBottom(); // Scroll to the latest message
            }, (error) => {
                console.error("Error listening to messages:", error);
                // Optionally display an error message to the user
            });

            // Public channels listener
            const publicChannelsRef = collection(db, `artifacts/${app.options.appId}/public/data/public_channels`);
            unsubscribePublicChannels = onSnapshot(publicChannelsRef, (snapshot) => {
                publicChannelList.innerHTML = '';
                snapshot.forEach((doc) => {
                    const channelData = doc.data();
                    const li = document.createElement('li');
                    li.className = 'mb-1';
                    li.innerHTML = `
                        <button class="channel-item block w-full text-left p-2 rounded-lg hover:bg-blue-200 dark:hover:bg-gray-700 transition-colors duration-200 text-gray-800 dark:text-gray-100" data-channel-id="${channelData.id}">
                            #${channelData.id} <span class="text-sm text-gray-500 dark:text-gray-400">(${channelData.users || 0} users)</span>
                        </button>
                    `;
                    publicChannelList.appendChild(li);
                });

                // Add event listeners for channel items
                publicChannelList.querySelectorAll('.channel-item').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const newChannel = e.target.dataset.channelId;
                        if (newChannel && newChannel !== currentChannelId) {
                            currentChannelId = newChannel;
                            localStorage.setItem('wChatChannelId', currentChannelId);
                            currentChannelDisplay.textContent = `Current: #${currentChannelId}`;
                            setupRealtimeListeners(); // Re-subscribe to new channel's messages
                            toggleSidebar(); // Close sidebar after channel selection
                        }
                    });
                });
            }, (error) => {
                console.error("Error listening to public channels:", error);
            });
        }

        /**
         * Renders messages in the chat interface.
         * @param {Array} messages - An array of message objects.
         */
        async function renderMessages(messages) {
            messagesListContainer.innerHTML = ''; // Clear existing messages
            for (const msg of messages) {
                const messageBubble = document.createElement('div');
                const isMyMessage = msg.userId === currentUserId;
                messageBubble.className = `flex ${isMyMessage ? 'justify-end' : 'justify-start'} items-start`;

                let displayName = msg.nickname || 'Anonymous';
                if (msg.userId === currentUserId) {
                    displayName = 'You';
                }

                messageBubble.innerHTML = `
                    <div class="flex flex-col ${isMyMessage ? 'items-end' : 'items-start'} max-w-xs sm:max-w-md md:max-w-lg">
                        <span class="text-xs ${isMyMessage ? 'text-gray-500' : 'text-blue-600 dark:text-blue-400'} font-semibold mb-1">
                            ${displayName}
                        </span>
                        <div class="relative p-3 rounded-lg shadow-md ${isMyMessage ? 'bg-blue-500 text-white' : 'bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-100'}">
                            <p class="text-sm break-words whitespace-pre-wrap">${msg.text || ''}</p>
                            ${isMyMessage ? `
                            <div class="absolute bottom-1 right-1 flex space-x-1">
                                <button class="edit-message-button text-white text-xs opacity-75 hover:opacity-100" data-message-id="${msg.id}" data-message-text="${msg.text || ''}">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                                        <path d="M13.586 3.586a2 2 0 112.828 2.828l-7.414 7.414A2 2 0 018 14.172V12h-2v2.172a2 2 0 01-.586 1.414L3.586 17.414a2 2 0 11-2.828-2.828l7.414-7.414A2 2 0 0113.586 3.586z" />
                                    </svg>
                                </button>
                                <button class="delete-message-button text-white text-xs opacity-75 hover:opacity-100" data-message-id="${msg.id}">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M9 2a1 1 0 00-1 1v1H5a1 1 0 000 2h1v9a2 2 0 002 2h4a2 2 0 002-2V6h1a1 1 0 100-2h-3V3a1 1 0 00-1-1H9zm1 2H9v1h2V4zm0 3a1 1 0 100 2v5a1 1 0 102 0V9a1 1 0 000-2h-2z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                            ` : ''}
                        </div>
                        <span class="text-xs text-gray-400 mt-1">
                            ${msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleString() : 'Just now'}
                        </span>
                    </div>
                `;

                // Display image if available
                if (msg.imageDataUrl) {
                    const imgElement = document.createElement('img');
                    imgElement.src = msg.imageDataUrl;
                    imgElement.className = "mt-2 rounded-lg max-w-full h-auto";
                    imgElement.alt = "Shared image";
                    imgElement.onload = () => { scrollToBottom(); }; // Scroll after image loads
                    imgElement.onclick = () => window.open(msg.imageDataUrl, '_blank'); // Open image in new tab
                    messageBubble.querySelector('.relative').appendChild(imgElement);
                }

                // Display audio if available
                if (msg.audioDataUrl) {
                    const audioPlayer = document.createElement('audio');
                    audioPlayer.controls = true;
                    audioPlayer.src = msg.audioDataUrl;
                    audioPlayer.className = "my-2 rounded-lg"; // Tailwind classes for styling
                    messageBubble.querySelector('.relative').appendChild(audioPlayer);
                }

                // Display video if available
                if (msg.videoDataUrl) {
                    const videoPlayer = document.createElement('video');
                    videoPlayer.controls = true;
                    videoPlayer.src = msg.videoDataUrl;
                    videoPlayer.className = "my-2 rounded-lg max-w-full h-auto"; // Tailwind classes for styling
                    videoPlayer.onloadstart = () => { scrollToBottom(); }; // Scroll when video starts loading
                    messageBubble.querySelector('.relative').appendChild(videoPlayer);
                }

                messagesListContainer.appendChild(messageBubble);

                // Add event listeners for edit and delete buttons
                if (isMyMessage) {
                    messageBubble.querySelector('.edit-message-button').addEventListener('click', async (e) => {
                        const messageId = e.target.dataset.messageId;
                        const originalText = e.target.dataset.messageText;
                        const newText = prompt("Edit your message:", originalText);
                        if (newText !== null && newText.trim() !== "") {
                            const messageRef = doc(db, `artifacts/${app.options.appId}/public/data/channels/${currentChannelId}/messages`, messageId);
                            await updateDoc(messageRef, {
                                text: newText.trim(),
                                editedAt: serverTimestamp()
                            });
                        }
                    });

                    messageBubble.querySelector('.delete-message-button').addEventListener('click', async (e) => {
                        if (confirm("Are you sure you want to delete this message?")) {
                            const messageId = e.target.dataset.messageId;
                            await deleteDoc(doc(db, `artifacts/${app.options.appId}/public/data/channels/${currentChannelId}/messages`, messageId));
                        }
                    });
                }
            }
            scrollToBottom();
        }

        /**
         * Sends a message to Firestore.
         * @param {string} text - The message text.
         * @param {string|null} imageDataUrl - Base64 encoded image data URL.
         * @param {string|null} audioDataUrl - Base64 encoded audio data URL.
         * @param {string|null} videoDataUrl - Base64 encoded video data URL.
         */
        async function sendMessage(text, imageDataUrl = null, audioDataUrl = null, videoDataUrl = null) {
            try {
                await addDoc(collection(db, `artifacts/${app.options.appId}/public/data/channels/${currentChannelId}/messages`), {
                    userId: currentUserId,
                    nickname: currentNickname,
                    text: text,
                    timestamp: serverTimestamp(),
                    imageDataUrl: imageDataUrl,
                    audioDataUrl: audioDataUrl,
                    videoDataUrl: videoDataUrl
                });
                newMessageInput.value = ''; // Clear input after sending
                clearAllMediaSelections(); // Clear any selected media
            } catch (e) {
                console.error("Error adding document: ", e);
            }
        }

        /**
         * Clears all selected media (image, audio, video).
         */
        function clearAllMediaSelections() {
            currentFile = null;
            currentAudioFile = null;
            currentVideoFile = null;
            fileInput.value = ''; // Clear file input
            mediaPreviewContainer.classList.add('hidden');
            selectedFileName.textContent = '';
            hideFileSizeMessage();
            sendButton.disabled = false; // Re-enable send button
            uploadProgressBarContainer.classList.add('hidden'); // Hide progress bar
            uploadProgressBar.style.width = '0%';
        }

        /**
         * Handles file selection for image/video.
         * @param {Event} e - The file input change event.
         */
        function handleFileSelection(e) {
            const file = e.target.files[0];
            if (!file) {
                clearAllMediaSelections();
                return;
            }

            if (file.size > MAX_RAW_FILE_SIZE_BEFORE_ENCODING) {
                showFileSizeMessage();
                sendButton.disabled = true;
                currentFile = null; // Ensure no large file is kept
                return;
            } else {
                hideFileSizeMessage();
                sendButton.disabled = false;
            }

            // Determine file type and assign to appropriate variable
            if (file.type.startsWith('image/')) {
                currentFile = file; // For image (old logic, needs refactor)
                currentAudioFile = null;
                currentVideoFile = null;
            } else if (file.type.startsWith('audio/')) {
                currentAudioFile = file;
                currentFile = null;
                currentVideoFile = null;
            } else if (file.type.startsWith('video/')) {
                currentVideoFile = file;
                currentFile = null;
                currentAudioFile = null;
            } else {
                alert("Unsupported file type.");
                clearAllMediaSelections();
                return;
            }

            selectedFileName.textContent = file.name;
            mediaPreviewContainer.classList.remove('hidden');
            // Hide recording status if a file is attached
            audioRecordingStatus.classList.add('hidden');
            isRecording = false; // Ensure recording state is false
        }

        // --- Audio Recording Functions ---
        async function startRecording() {
            try {
                clearAllMediaSelections(); // Ensure no media is selected before recording
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    currentAudioFile = audioBlob;
                    selectedFileName.textContent = `Recorded Audio (${(audioBlob.size / 1024).toFixed(2)} KB)`;
                    mediaPreviewContainer.classList.remove('hidden');
                    audioRecordingStatus.classList.add('hidden');
                    isRecording = false;
                    sendButton.disabled = false;
                    // Stop all tracks from the recording stream
                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.onstart = () => {
                    audioRecordingStatus.classList.remove('hidden');
                    sendButton.disabled = true; // Disable send button while recording
                    isRecording = true;
                    // Start timeout for max recording time
                    recordingTimeout = setTimeout(() => {
                        if (isRecording) {
                            stopRecording();
                            alert("Recording stopped automatically after 1 minute.");
                        }
                    }, MAX_RECORDING_TIME_MS);
                };

                mediaRecorder.onerror = (event) => {
                    console.error("MediaRecorder error:", event.error);
                    alert("Error during recording: " + event.error.name);
                    audioRecordingStatus.classList.add('hidden');
                    sendButton.disabled = false;
                    isRecording = false;
                    if (recordingTimeout) clearTimeout(recordingTimeout);
                    stream.getTracks().forEach(track => track.stop()); // Stop all tracks
                };

                mediaRecorder.start();
                console.log("Recording started...");
            } catch (err) {
                console.error('Error accessing microphone:', err);
                alert('Could not access microphone. Please ensure it is connected and permissions are granted.');
                sendButton.disabled = false;
                audioRecordingStatus.classList.add('hidden');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                console.log("Recording stopped.");
                if (recordingTimeout) clearTimeout(recordingTimeout);
            }
        }

        function cancelRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop(); // This will trigger onstop, which cleans up
                console.log("Recording cancelled.");
                currentAudioFile = null;
                audioChunks = [];
                audioRecordingStatus.classList.add('hidden');
                isRecording = false;
                sendButton.disabled = false;
                if (recordingTimeout) clearTimeout(recordingTimeout);
                // Stop all tracks from the stream if still active
                if (mediaRecorder.stream) {
                    mediaRecorder.stream.getTracks().forEach(track => track.stop());
                }
            }
            clearAllMediaSelections(); // Clear any visual indicators
        }

        // --- WebRTC Functions ---

        /**
         * Initializes a new RTCPeerConnection.
         */
        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(rtcConfig);

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // Send candidate to the other peer via Firestore signaling
                    sendWebRTCSignalingMessage('candidate', event.candidate, callTargetUserId);
                }
            };

            peerConnection.ontrack = (event) => {
                remoteStream = event.streams[0];
                remoteVideo.srcObject = remoteStream;
                videoFeedsContainer.classList.remove('hidden'); // Show video container
                enlargeRemoteVideoButton.classList.remove('hidden'); // Show enlarge button
            };

            // Log ICE connection state changes for debugging
            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE connection state changed:', peerConnection.iceConnectionState);
                callStatus.textContent = `ICE status: ${peerConnection.iceConnectionState}`;
                // Update UI if connected or disconnected
                if (peerConnection.iceConnectionState === 'connected') {
                    connectSound.play().catch(e => console.warn("Connect sound play failed:", e)); // Play connect sound
                    callStatus.textContent = `Call status: Connected with ${callTargetUserId.substring(0, 8)}...`;
                    addFriendFromCallButton.classList.remove('hidden'); // Show add friend button
                } else if (peerConnection.iceConnectionState === 'disconnected' || peerConnection.iceConnectionState === 'failed') {
                    handleHangup();
                    callStatus.textContent = `Call ended due to ${peerConnection.iceConnectionState} state.`;
                    addFriendFromCallButton.classList.add('hidden'); // Hide add friend button
                }
            };

            peerConnection.onconnectionstatechange = () => {
                console.log('Peer connection state changed:', peerConnection.connectionState);
                callStatus.textContent = `Call status: ${peerConnection.connectionState}`; // Update UI with more detail
                if (peerConnection.connectionState === 'connected') {
                    connectSound.play().catch(e => console.warn("Connect sound play failed:", e)); // Play connect sound
                } else if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                    handleHangup();
                    callStatus.textContent = `Call ended due to ${peerConnection.connectionState} state.`;
                }
            };

            // Log signaling state changes
            peerConnection.onsignalingstatechange = () => {
                console.log('Signaling state changed:', peerConnection.signalingState);
            };
        }

        /**
         * Sends a WebRTC signaling message through Firestore.
         * @param {string} type - 'offer', 'answer', 'candidate', 'hangup'.
         * @param {Object} data - The SDP offer/answer or ICE candidate.
         * @param {string} targetUserId - The ID of the user to send the message to.
         */
        async function sendWebRTCSignalingMessage(type, data, targetUserId) {
            try {
                // Store signaling messages in a subcollection under the target user's ID
                // This simulates a simple signaling server using Firestore
                const signalingRef = collection(db, `artifacts/${app.options.appId}/private/data/webrtc_signals/${targetUserId}/inbox`);
                await addDoc(signalingRef, {
                    senderId: currentUserId,
                    type: type,
                    data: JSON.stringify(data), // Store data as JSON string
                    timestamp: serverTimestamp()
                });
                console.log(`Sent ${type} signal to ${targetUserId}`);
            } catch (error) {
                console.error("Error sending WebRTC signaling message:", error);
            }
        }

        /**
         * Listens for incoming WebRTC signaling messages.
         */
        function listenForWebRTCSignals() {
            // Listen for messages in the current user's inbox
            const inboxRef = collection(db, `artifacts/${app.options.appId}/private/data/webrtc_signals/${currentUserId}/inbox`);
            const q = query(inboxRef, orderBy('timestamp'));

            onSnapshot(q, async (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added') {
                        const signal = change.doc.data();
                        const signalData = JSON.parse(signal.data); // Parse the JSON string back to object

                        if (signal.senderId === currentUserId) {
                            // Ignore messages sent by self
                            return;
                        }

                        console.log(`Received ${signal.type} signal from ${signal.senderId}`);

                        if (signal.type === 'offer') {
                            if (isCalling) {
                                console.log("Already in a call, rejecting new offer.");
                                // Optionally send a busy signal back
                                return;
                            }
                            isCalling = true;
                            callTargetUserId = signal.senderId; // Set the sender as the target
                            incomingCallSound.play().catch(e => console.warn("Incoming call sound play failed:", e));
                            callStatus.textContent = `Incoming call from ${callTargetUserId.substring(0, 8)}...`;
                            startCallButton.classList.add('hidden');
                            answerCallButton.classList.remove('hidden');
                            endCallButton.classList.remove('hidden');

                            createPeerConnection();
                            await handleOffer(signalData);
                        } else if (signal.type === 'answer') {
                            if (peerConnection && peerConnection.signalingState !== 'stable') {
                                await peerConnection.setRemoteDescription(new RTCSessionDescription(signalData));
                                console.log("Remote description set (answer)");
                                callStatus.textContent = `Call status: Connecting with ${callTargetUserId.substring(0, 8)}...`;
                            }
                        } else if (signal.type === 'candidate') {
                            if (peerConnection) {
                                try {
                                    await peerConnection.addIceCandidate(new RTCIceCandidate(signalData));
                                    console.log("ICE candidate added");
                                } catch (e) {
                                    console.error("Error adding received ICE candidate:", e);
                                }
                            }
                        } else if (signal.type === 'hangup') {
                            handleHangup();
                            callStatus.textContent = `Call ended by ${signal.senderId.substring(0, 8)}...`;
                        }

                        // Delete the processed signal from inbox
                        await deleteDoc(doc(db, `artifacts/${app.options.appId}/private/data/webrtc_signals/${currentUserId}/inbox`, change.doc.id));
                    }
                });
            }, (error) => {
                console.error("Error listening for WebRTC signals:", error);
            });
        }

        /**
         * Starts a WebRTC call by creating an offer.
         */
        async function startCall() {
            if (isCalling) {
                alert('Already in a call.');
                return;
            }

            let targetId = targetUserIdInput.value.trim();
            const callCode = callCodeInput.value.trim();

            if (!targetId && !callCode) {
                alert('Please enter a Target User ID or a 4-digit Call Code to start a call.');
                return;
            }

            if (callCode) {
                // If call code is provided, fetch target user ID from Firestore
                try {
                    const q = query(collection(db, `artifacts/${app.options.appId}/public/data/call_codes`), where('code', '==', callCode));
                    const querySnapshot = await getDocs(q);
                    if (!querySnapshot.empty) {
                        targetId = querySnapshot.docs[0].data().userId;
                        if (targetId === currentUserId) {
                            alert("You cannot call yourself using a call code. Use direct ID if testing.");
                            return;
                        }
                    } else {
                        alert("Invalid 4-digit call code.");
                        return;
                    }
                } catch (error) {
                    console.error("Error fetching user ID from call code:", error);
                    alert("Failed to retrieve user ID from call code.");
                    return;
                }
            }

            if (targetId === currentUserId) {
                alert("You cannot call yourself.");
                return;
            }

            callTargetUserId = targetId;
            isCalling = true;
            createPeerConnection();

            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                videoFeedsContainer.classList.remove('hidden'); // Show video container
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                sendWebRTCSignalingMessage('offer', offer, callTargetUserId);

                callStatus.textContent = `Calling ${callTargetUserId.substring(0, 8)}...`;
                startCallButton.classList.add('hidden');
                endCallButton.classList.remove('hidden');
                toggleVideoButton.classList.remove('hidden');
                toggleAudioButton.classList.remove('hidden');
                startScreenshareButton.classList.remove('hidden'); // Show screenshare button
            } catch (error) {
                console.error("Error starting call:", error);
                callStatus.textContent = `Call failed: ${error.message}. Please check microphone/camera permissions and try again.`;
                startCallButton.disabled = false;
                toggleVideoButton.classList.add('hidden'); // Hide video toggle on error
                toggleAudioButton.classList.add('hidden'); // Hide audio toggle on error
                startScreenshareButton.classList.add('hidden'); // Hide screenshare button on error
                enlargeRemoteVideoButton.classList.add('hidden'); // Hide enlarge remote video button
                hideLocalVideoButton.classList.add('hidden'); // Hide hide local video button
                handleHangup(); // Clean up if call fails to start
            }
        }

        /**
         * Handles an incoming SDP offer and sends back an answer.
         * @param {Object} offer - The received SDP offer.
         */
        async function handleOffer(offer) {
            if (!peerConnection) {
                createPeerConnection(); // Ensure peerConnection is created
            }

            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                videoFeedsContainer.classList.remove('hidden'); // Show video container
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                sendWebRTCSignalingMessage('answer', answer, callTargetUserId);

                answerCallButton.classList.add('hidden'); // Hide answer button
                startCallButton.classList.add('hidden');
                endCallButton.classList.remove('hidden');
                toggleVideoButton.classList.remove('hidden');
                toggleAudioButton.classList.remove('hidden');
                startScreenshareButton.classList.remove('hidden'); // Show screenshare button
                callStatus.textContent = `Call status: Answered from ${callTargetUserId.substring(0, 8)}...`;
            } catch (error) {
                console.error("Error handling offer:", error);
                callStatus.textContent = `Failed to answer call: ${error.message}.`;
                handleHangup(); // Clean up on error
            }
        }

        /**
         * Ends the current WebRTC call.
         */
        async function handleHangup() {
            if (peerConnection) {
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                if (remoteStream) {
                    remoteStream.getTracks().forEach(track => track.stop());
                }
                if (screenShareStream) { // Stop screenshare stream
                    screenShareStream.getTracks().forEach(track => track.stop());
                    screenShareStream = null;
                }
                peerConnection.close();
                peerConnection = null;
            }
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            videoFeedsContainer.classList.add('hidden'); // Hide video container
            isCalling = false;
            callTargetUserId = null;
            incomingCallSound.pause();
            incomingCallSound.currentTime = 0;
            callStatus.textContent = 'Call status: Idle';

            startCallButton.classList.remove('hidden');
            answerCallButton.classList.add('hidden');
            endCallButton.classList.add('hidden');
            toggleVideoButton.classList.add('hidden');
            toggleAudioButton.classList.add('hidden');
            startScreenshareButton.classList.add('hidden'); // Hide screenshare button
            enlargeRemoteVideoButton.classList.add('hidden');
            hideLocalVideoButton.classList.add('hidden');
            toggleVideoButton.textContent = 'Enable Video'; // Reset button text
            toggleAudioButton.textContent = 'Mute Audio'; // Reset button text
            addFriendFromCallButton.classList.add('hidden'); // Hide add friend button
        }

        /**
         * Toggles local video on/off.
         */
        function toggleVideo() {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.enabled = !videoTrack.enabled;
                    toggleVideoButton.textContent = videoTrack.enabled ? 'Disable Video' : 'Enable Video';
                    localVideo.classList.toggle('hidden', !videoTrack.enabled);
                    isLocalVideoHidden = !videoTrack.enabled;
                } else {
                    console.warn("No local video track found.");
                    // Attempt to get video stream if it was previously off or failed
                    navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then(stream => {
                        localStream = stream; // Update localStream
                        localVideo.srcObject = localStream;
                        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
                        toggleVideoButton.textContent = 'Disable Video';
                        localVideo.classList.remove('hidden');
                        isLocalVideoHidden = false;
                    }).catch(e => {
                        console.error("Error enabling video:", e);
                        alert("Could not enable video. Check camera permissions.");
                    });
                }
            } else {
                alert("No local stream available to toggle video.");
            }
        }

        /**
         * Toggles local audio mute/unmute.
         */
        function toggleAudio() {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = !track.enabled;
                    toggleAudioButton.textContent = track.enabled ? 'Mute Audio' : 'Unmute Audio';
                });
            } else {
                alert("No local stream available to toggle audio.");
            }
        }

        /**
         * Toggles the size of the remote video feed.
         */
        function toggleRemoteVideoSize() {
            remoteVideo.classList.toggle('full-screen');
            enlargeRemoteVideoButton.textContent = remoteVideo.classList.contains('full-screen') ? 'Shrink Remote Video' : 'Enlarge Remote Video';
        }

        /**
         * Toggles the visibility of the local video feed.
         */
        function toggleLocalVideoDisplay() {
            if (!localVideo.srcObject) {
                callStatus.textContent = 'No local video stream active to display.';
                return;
            }

            if (isLocalVideoHidden) {
                // If the video element is hidden (e.g., due to stream not being active) but our state says it should be visible,
                // then this button should attempt to show it if a stream is active.
                if (localStream && localStream.getVideoTracks().length > 0 && localStream.getVideoTracks()[0].enabled) {
                    localVideo.classList.remove('hidden');
                    hideLocalVideoButton.textContent = 'Hide My Video';
                    isLocalVideoHidden = false;
                    callStatus.textContent = 'My Video Visible';
                } else {
                    callStatus.textContent = 'No local video stream active to display.';
                }
                return;
            }

            localVideo.classList.add('hidden');
            hideLocalVideoButton.textContent = 'Show My Video';
            isLocalVideoHidden = true;
            callStatus.textContent = 'My Video Hidden';
        }

        /**
         * Generates and stores a 4-digit call code.
         */
        async function generateCallCode() {
            const code = Math.floor(1000 + Math.random() * 9000).toString(); // Generate 4-digit code
            try {
                // Store the code with current user's ID in Firestore
                await setDoc(doc(db, `artifacts/${app.options.appId}/public/data/call_codes`, code), {
                    code: code,
                    userId: currentUserId,
                    createdAt: serverTimestamp()
                });
                generatedCallCodeDisplay.textContent = code;
                alert(`Your call code is: ${code}. Share it with the person you want to call!`);

                // Set a listener to delete the code if another user joins
                const codeRef = doc(db, `artifacts/${app.options.appId}/public/data/call_codes`, code);
                const unsubscribeCode = onSnapshot(codeRef, (docSnapshot) => {
                    if (!docSnapshot.exists() && isCalling) { // If code is deleted and a call is active
                        alert("Your call code has been used or deleted.");
                        unsubscribeCode(); // Stop listening
                    }
                });

                // Automatically delete code after a period (e.g., 5 minutes) if not used
                setTimeout(async () => {
                    const docSnap = await getDoc(codeRef);
                    if (docSnap.exists() && docSnap.data().userId === currentUserId && !isCalling) { // Check if it's still ours and not in call
                        await deleteCallCode(code);
                        alert(`Call code ${code} expired.`);
                    }
                }, 5 * 60 * 1000); // 5 minutes
            } catch (error) {
                console.error("Error generating call code:", error);
                alert("Failed to generate call code. Try again.");
            }
        }

        /**
         * Deletes a call code from Firestore.
         * @param {string} codeToDelete - The 4-digit code to delete.
         */
        async function deleteCallCode(codeToDelete) {
            if (!db) return; // Ensure db is initialized
            try {
                const q = query(collection(db, `artifacts/${app.options.appId}/public/data/call_codes`), where('code', '==', codeToDelete));
                const querySnapshot = await getDocs(q);
                querySnapshot.forEach(async (docRef) => {
                    await deleteDoc(doc(db, `artifacts/${app.options.appId}/public/data/call_codes`, docRef.id));
                    console.log(`Call code ${codeToDelete} deleted from Firestore.`);
                });
            } catch (error) {
                console.error(`Error deleting call code ${codeToDelete}:`, error);
            }
        }

        // --- Event Listeners ---

        // Update nickname in localStorage on input
        nicknameInput.addEventListener('input', (e) => {
            currentNickname = e.target.value.trim();
            localStorage.setItem('wChatNickname', currentNickname);
        });

        // Handle message form submission
        messageForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const messageText = newMessageInput.value.trim();

            if (messageText === '' && !currentFile && !currentAudioFile && !currentVideoFile) {
                alert('Please enter a message or select a file to send.');
                return;
            }

            if (currentFile) { // For images (old logic, needs refactor)
                const reader = new FileReader();
                reader.onload = async () => {
                    const imageDataUrl = reader.result;
                    await sendMessage(messageText, imageDataUrl, null, null);
                };
                reader.readAsDataURL(currentFile);
            } else if (currentAudioFile) {
                const reader = new FileReader();
                reader.onload = async () => {
                    const audioDataUrl = reader.result;
                    await sendMessage(messageText, null, audioDataUrl, null);
                };
                reader.readAsDataURL(currentAudioFile);
            } else if (currentVideoFile) {
                const reader = new FileReader();
                reader.onload = async () => {
                    const videoDataUrl = reader.result;
                    await sendMessage(messageText, null, null, videoDataUrl);
                };
                reader.readAsDataURL(currentVideoFile);
            } else {
                // Send plain text message if no file selected
                await sendMessage(messageText);
            }
        });

        // Auto-resize textarea
        newMessageInput.addEventListener('input', () => {
            newMessageInput.style.height = 'auto';
            newMessageInput.style.height = (newMessageInput.scrollHeight) + 'px';
        });

        // File attachment button click
        attachFileButton.addEventListener('click', () => {
            fileInput.click(); // Trigger the hidden file input
        });

        // Handle file input change
        fileInput.addEventListener('change', handleFileSelection);

        // Cancel media selection
        cancelMediaSelection.addEventListener('click', clearAllMediaSelections);

        // Join Channel button
        joinChannelButton.addEventListener('click', () => {
            const newChannel = channelInput.value.trim().toLowerCase().replace(/[^a-z0-9-]/g, ''); // Sanitize input
            if (!newChannel) {
                console.warn("Channel name cannot be empty or contain only special characters.");
                return;
            }
            // Only switch if the new channel is different from the current one
            if (newChannel && newChannel !== currentChannelId) {
                currentChannelId = newChannel;
                localStorage.setItem('wChatChannelId', currentChannelId);
                currentChannelDisplay.textContent = `Current: #${currentChannelId}`;
                setupRealtimeListeners(); // Re-subscribe to new channel's messages
                // Optionally close the channel control area
                if (window.innerWidth < 768) { // Only close on smaller screens
                    channelControlArea.classList.add('max-h-0');
                    channelControlArea.classList.remove('max-h-full');
                    channelToggleIcon.classList.add('rotate-180');
                    channelToggleIcon.classList.remove('rotate-0');
                }
            }
        });

        // Channel toggle button
        channelToggleButton.addEventListener('click', toggleChannelControlArea);

        // Sidebar toggle button
        sidebarToggle.addEventListener('click', toggleSidebar);

        // User settings button
        userSettingsButton.addEventListener('click', () => {
            userSettingsModal.classList.remove('hidden');
        });

        // Close user settings modal
        closeSettingsModalButton.addEventListener('click', () => {
            userSettingsModal.classList.add('hidden');
        });

        // Theme toggle
        themeToggle.addEventListener('change', (e) => {
            applyTheme(e.target.checked ? 'dark' : 'light');
        });

        // Clear Cache button
        clearCacheButton.addEventListener('click', () => {
            confirmationModal.classList.remove('hidden');
        });

        // Confirmation modal: Yes
        confirmDeleteYes.addEventListener('click', () => {
            localStorage.removeItem('wChatUserId');
            localStorage.removeItem('wChatNickname');
            localStorage.removeItem('wChatChannelId');
            localStorage.removeItem('wChatFriends'); // Clear friends list
            // Reload the page to apply changes
            location.reload();
        });

        // Confirmation modal: No
        confirmDeleteNo.addEventListener('click', () => {
            confirmationModal.classList.add('hidden');
        });

        // Audio Recording Button (replace send button for recording)
        audioRecordingButton.addEventListener('click', () => {
            // Clear any media selected and text input BEFORE starting or stopping recording
            clearAllMediaSelections();
            newMessageInput.value = '';
            if (isRecording) {
                stopRecording(); // If already recording, stop (this will hide the status via onstop callback)
            } else {
                startRecording(); // If not recording, start (this will make the status visible)
            }
        });

        stopRecordingButton.addEventListener('click', stopRecording);
        cancelRecordingButton.addEventListener('click', cancelRecording);

        // WebRTC Call Button Listeners
        startCallButton.addEventListener('click', startCall);
        answerCallButton.addEventListener('click', () => handleOffer(null)); // Offer handled by signal listener, just trigger answer process
        endCallButton.addEventListener('click', async () => {
            await sendWebRTCSignalingMessage('hangup', {}, callTargetUserId); // Send hangup signal
            handleHangup(); // Local cleanup
        });
        toggleVideoButton.addEventListener('click', toggleVideo);
        toggleAudioButton.addEventListener('click', toggleAudio);
        startScreenshareButton.addEventListener('click', startScreenshare); // Screenshare button
        enlargeRemoteVideoButton.addEventListener('click', toggleRemoteVideoSize);
        hideLocalVideoButton.addEventListener('click', toggleLocalVideoDisplay);

        // WebRTC Panel Toggle
        webrtcToggleButton.addEventListener('click', toggleWebRTCPanel);

        // Generate Call Code Button
        generateCallCodeButton.addEventListener('click', generateCallCode);

        // Add Friend from Call Button
        addFriendFromCallButton.addEventListener('click', () => {
            if (callTargetUserId) {
                // In a real app, you might fetch the nickname from a user directory
                // For now, use a placeholder or prompt
                const friendNickname = prompt(`Enter nickname for ${callTargetUserId.substring(0, 8)}...`, `User-${callTargetUserId.substring(0, 4)}`);
                if (friendNickname !== null) {
                    addFriend(callTargetUserId, friendNickname.trim() || `User-${callTargetUserId.substring(0, 4)}`);
                }
            } else {
                alert("No active call to add a friend from.");
            }
        });

        // Friends List Toggle Button
        friendsListToggle.addEventListener('click', toggleFriendsListSidebar);

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeFirebase();
            applyTheme(localStorage.getItem('wChatTheme') || 'dark'); // Apply theme on load

            // Adjust channel control area visibility based on screen width on load
            if (window.innerWidth >= 768) {
                 channelControlArea.classList.remove('max-h-0');
                 channelControlArea.classList.add('max-h-full');
                 channelToggleIcon.classList.add('rotate-0');
                 channelToggleIcon.classList.remove('rotate-180');
                 // Also ensure WebRTC controls are visible on larger screens by default
                 webrtcMainPanel.classList.remove('hidden'); // Show the panel
                 webrtcToggleIcon.classList.add('rotate-0');
                 webrtcToggleIcon.classList.remove('rotate-180');
                 // Friends list sidebar hidden by default on load, user can toggle
                 friendsListSidebar.classList.add('w-0');
                 friendsListSidebar.classList.remove('w-64');
                 friendsListToggleIcon.classList.add('rotate-180');
                 friendsListToggleIcon.classList.remove('rotate-0');
            } else {
                 channelControlArea.classList.add('max-h-0');
                 channelControlArea.classList.remove('max-h-full');
                 channelToggleIcon.classList.add('rotate-180');
                 channelToggleIcon.classList.remove('rotate-0');
                 // Make WebRTC controls collapsible on smaller screens
                 webrtcMainPanel.classList.add('hidden'); // Hide the panel
                 webrtcToggleIcon.classList.add('rotate-180'); // Arrow points down
                 webrtcToggleIcon.classList.remove('rotate-0');
                 // Friends list sidebar hidden by default on load, user can toggle
                 friendsListSidebar.classList.add('w-0');
                 friendsListSidebar.classList.remove('w-64');
                 friendsListToggleIcon.classList.add('rotate-180');
                 friendsListToggleIcon.classList.remove('rotate-0');
            }
            listenForWebRTCSignals(); // Start listening for WebRTC signals
        });

        // Adjust layout on window resize
        window.addEventListener('resize', () => {
            if (window.innerWidth >= 768) {
                // On larger screens, ensure WebRTC panel is visible
                webrtcMainPanel.classList.remove('hidden');
                webrtcToggleIcon.classList.remove('rotate-180');
                webrtcToggleIcon.classList.add('rotate-0');
            } else {
                // On smaller screens, allow WebRTC panel to be collapsible
                webrtcMainPanel.classList.add('hidden');
                webrtcToggleIcon.classList.add('rotate-180');
                webrtcToggleIcon.classList.remove('rotate-0');
            }
        });
    </script>
</body>
</html>
