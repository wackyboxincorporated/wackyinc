<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wChat 2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Link to the external CSS file -->
    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body class="flex flex-col h-screen bg-gray-100 text-gray-900 font-sans">

    <header class="bg-gradient-to-r from-blue-600 to-indigo-700 p-4 shadow-md rounded-b-xl flex justify-between items-center">
        <h1 class="text-3xl font-extrabold text-white">wChat 2</h1>
        <div class="flex items-center space-x-4">
            <button id="userSettingsButton" class="text-white text-2xl p-2 rounded-full hover:bg-white hover:bg-opacity-20 transition-colors duration-200">
                &#x2699;
            </button>
            <!-- Your User ID Display -->
            <span id="userIdDisplayHeader" class="text-sm text-white font-medium bg-blue-500 py-1 px-3 rounded-full shadow-inner">
                Your ID: Loading...
            </span>
            <input
                type="text"
                id="nicknameInput"
                placeholder="Set your nickname"
                class="p-2 rounded-lg bg-white bg-opacity-20 text-white placeholder-gray-200 focus:outline-none focus:ring-2 focus:ring-white transition-all duration-300 w-32 md:w-48"
                maxlength="20"
            />
        </div>
    </header>

    <!-- Removed the channel control section from here -->

    <main class="flex flex-1 overflow-hidden relative">
        <button id="sidebarToggle" class="absolute top-4 left-4 p-1 rounded-full bg-blue-500 text-white shadow-md z-10 transition-transform duration-300 hover:scale-110">
            <svg id="toggleIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 transform rotate-0" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
            </svg>
        </button>

        <aside id="sidebar" class="w-0 bg-gray-200 dark:bg-gray-800 transition-all duration-300 ease-in-out overflow-hidden flex-shrink-0">
            <div id="channelListContent" class="p-4 pt-10 h-full overflow-y-auto">
                <!-- Channel Control Area - NOW INSIDE SIDEBAR -->
                <div id="channelControlArea" class="bg-gray-100 dark:bg-gray-700 p-3 rounded-lg shadow-inner mb-4">
                    <button id="channelToggleButton" class="w-full text-left font-semibold text-gray-800 dark:text-gray-100 flex justify-between items-center py-1">
                        Channel Settings
                        <svg id="channelToggleIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 transform rotate-180" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <div id="channelInputContent" class="max-h-0 overflow-hidden transition-all duration-300 ease-in-out">
                        <div class="flex flex-col space-y-2 pt-2">
                            <div class="flex items-center space-x-2 w-full">
                                <label for="channelInput" class="text-gray-700 dark:text-gray-300 font-semibold text-sm whitespace-nowrap">Channel:</label>
                                <input
                                    type="text"
                                    id="channelInput"
                                    placeholder="Enter name (password)"
                                    class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-100 transition-all duration-300"
                                    value="general-chat"
                                />
                            </div>
                            <button
                                id="joinChannelButton"
                                class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 w-full"
                            >
                                Join/Create
                            </button>
                            <span id="currentChannelDisplay" class="text-blue-700 dark:text-blue-300 font-semibold text-sm w-full text-center">
                                Current: #general-chat
                            </span>
                        </div>
                    </div>
                </div>

                <h3 class="text-lg font-semibold mb-2 text-gray-800 dark:text-gray-100">Public Channels</h3>
                <ul id="publicChannelList" class="space-y-1">
                </ul>
            </div>
        </aside>

        <div id="chatContentArea" class="flex-1 flex flex-col overflow-hidden">
            <div id="messagesListContainer" class="flex-1 relative overflow-y-auto p-4 space-y-3 custom-scrollbar">
                <div id="noMessagesPlaceholder" class="absolute inset-0 flex items-center justify-center hidden">
                    <p class="text-gray-600 dark:text-gray-400 text-lg">No messages yet. Start the conversation!</p>
                </div>
                <div id="loadingIndicator" class="absolute inset-0 flex items-center justify-center">
                    <div class="text-lg font-semibold animate-pulse">Loading chat...</div>
                </div>
            </div>
        </div>

        <!-- Friends List Sidebar -->
        <button id="friendsToggleButton" class="absolute top-4 right-4 p-1 rounded-full bg-blue-500 text-white shadow-md z-10 transition-transform duration-300 hover:scale-110">
            <svg id="friendsToggleIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 transform rotate-180" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
            </svg>
        </button>
        <aside id="friendsSidebar" class="w-0 bg-gray-200 dark:bg-gray-800 transition-all duration-300 ease-in-out overflow-hidden flex-shrink-0">
            <div id="friendsListContent" class="p-4 pt-10 h-full overflow-y-auto">
                <h3 class="text-lg font-semibold mb-2 text-gray-800 dark:text-gray-100">Friends</h3>
                
                <!-- Add Friend by Code Panel -->
                <div id="addFriendByCodePanel" class="bg-gray-100 dark:bg-gray-700 p-3 rounded-lg shadow-inner mb-4">
                    <button id="addFriendByCodeToggleButton" class="w-full text-left font-semibold text-gray-800 dark:text-gray-100 flex justify-between items-center py-1">
                        Add Friend by Code
                        <svg id="addFriendByCodeToggleIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 transform rotate-180" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <div id="addFriendByCodeContent" class="max-h-0 overflow-hidden transition-all duration-300 ease-in-out">
                        <div class="flex items-center space-x-2 mt-2">
                            <label for="friendCodeInput" class="text-gray-700 dark:text-gray-300 text-sm whitespace-nowrap">Code:</label>
                            <input
                                type="text"
                                id="friendCodeInput"
                                placeholder="4-digit code"
                                class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-100 text-center font-mono text-lg"
                                maxlength="4"
                            />
                        </div>
                        <button type="button" id="addFriendByCodeButton" class="mt-3 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 w-full">
                            Add Friend
                        </button>
                    </div>
                </div>

                <h3 class="text-lg font-semibold mb-2 text-gray-800 dark:text-gray-100">Your ID: <span id="userIdDisplayFriendsList" class="text-blue-500 dark:text-blue-300 text-base font-medium bg-blue-100 dark:bg-blue-900 py-1 px-2 rounded-full shadow-inner flex-shrink-0 max-w-[150px] overflow-x-auto whitespace-nowrap custom-scrollbar">Loading...</span></h3>
                
                <ul id="friendsList" class="space-y-2">
                    <!-- Friends will be dynamically added here -->
                    <li class="text-gray-600 dark:text-gray-400">No friends yet.</li>
                </ul>
            </div>
        </aside>
    </main>

    <form id="messageForm" class="p-4 bg-white dark:bg-gray-800 shadow-md rounded-t-xl flex flex-col space-y-3">
        <!-- WebRTC Call Controls -->
        <div class="flex items-center space-x-2">
            <!-- The toggle button remains visible -->
            <button id="webrtcToggleButton" class="p-1 rounded-full bg-blue-500 text-white shadow-md z-10 transition-transform duration-300 hover:scale-110">
                <svg id="webrtcToggleIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 transform rotate-0" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
            </button>
            <!-- The main WebRTC panel that will be hidden/shown -->
            <div id="webrtcMainPanel" class="flex-1 bg-gray-50 dark:bg-gray-700 p-3 rounded-lg shadow-inner">
                <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-100 mb-2">WebRTC Audio/Video Call</h3>
                <div class="flex flex-col md:flex-row items-center space-y-2 md:space-y-0 md:space-x-4 mb-2">
                    <div class="flex items-center space-x-2 w-full">
                        <label for="targetUserIdInput" class="text-gray-700 dark:text-gray-300 text-sm whitespace-nowrap">Target User ID:</label>
                        <input
                            type="text"
                            id="targetUserIdInput"
                            placeholder="Enter User ID to call"
                            class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-100"
                        />
                    </div>
                    <span class="text-gray-500 dark:text-gray-400 font-semibold">OR</span>
                    <div class="flex items-center space-x-2 w-full">
                        <label for="callCodeInput" class="text-gray-700 dark:text-gray-300 text-sm whitespace-nowrap">4-Digit Code:</label>
                        <input
                            type="text"
                            id="callCodeInput"
                            placeholder="Enter 4-digit code to join"
                            class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-100 text-center font-mono text-lg"
                            maxlength="4"
                        />
                        <button type="button" id="generateCallCodeButton" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-1.5 px-3 rounded-lg shadow-md transition-all duration-300 whitespace-nowrap text-sm">Generate Code</button>
                    </div>
                </div>
                <div class="text-sm font-semibold text-gray-800 dark:text-gray-100 text-center mb-2">
                    Your generated code: <span id="generatedCallCodeDisplay" class="text-green-600 dark:text-green-400 font-bold">N/A</span>
                </div>
                <div class="flex flex-wrap gap-2 mb-2">
                    <button type="button" id="startCallButton" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white font-bold py-1.5 px-3 rounded-lg shadow-md transition-all duration-300 text-sm">Call</button>
                    <button type="button" id="answerCallButton" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-1.5 px-3 rounded-lg shadow-md transition-all duration-300 hidden text-sm">Answer</button>
                    <button type="button" id="endCallButton" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-bold py-1.5 px-3 rounded-lg shadow-md transition-all duration-300 hidden text-sm">Hang Up</button>
                    <button type="button" id="toggleVideoButton" class="flex-1 bg-purple-500 hover:bg-purple-600 text-white font-bold py-1.5 px-3 rounded-lg shadow-md transition-all duration-300 hidden text-sm">Enable Video</button>
                    <button type="button" id="toggleAudioButton" class="flex-1 bg-orange-500 hover:bg-orange-600 text-white font-bold py-1.5 px-3 rounded-lg shadow-md transition-all duration-300 hidden text-sm">Mute Audio</button>
                    <button type="button" id="toggleScreenShareButton" class="flex-1 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1.5 px-3 rounded-lg shadow-md transition-all duration-300 hidden text-sm">Share Screen</button>
                    <button type="button" id="enlargeRemoteVideoButton" class="flex-1 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-1.5 px-3 rounded-lg shadow-md transition-all duration-300 hidden text-sm">Enlarge Video</button>
                </div>
                <div id="callStatus" class="text-sm text-gray-700 dark:text-gray-300 text-center mt-2 flex items-center justify-center gap-2">
                    Idle
                    <button id="addFriendFromCallButton" class="text-blue-500 hover:text-blue-700 hidden text-base" title="Add current caller to friends list">
                        <i class="fas fa-user-plus"></i>
                    </button>
                </div>
                <div class="flex flex-col md:flex-row gap-2 mt-2" id="videoFeedsContainer">
                    <video id="localVideo" class="w-full md:w-1/2 h-32 rounded-lg bg-gray-200 dark:bg-gray-600 object-cover hidden" autoplay muted></video>
                    <video id="remoteVideo" class="w-full md:w-1/2 h-32 rounded-lg bg-gray-200 dark:bg-gray-600 object-cover hidden" autoplay></video>
                    <audio id="remoteAudio" controls class="w-full md:w-1/2 mt-2 hidden"></audio>
                </div>
            </div>
        </div>


        <div id="imagePreviewContainer" class="hidden flex items-center justify-between p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700">
            <img id="imagePreview" src="" alt="Image Preview" class="max-w-xs max-h-24 rounded-md object-contain mr-4">
            <span id="imageFileName" class="text-sm text-gray-700 dark:text-gray-300 truncate flex-1"></span>
            <div id="imageActions" class="flex flex-col space-y-2 ml-4">
                <button type="button" id="cancelImageButton" class="p-1 rounded-full text-red-500 hover:bg-red-100 dark:hover:bg-red-900 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                </button>
                <button type="button" id="scaleImageButton" class="hidden bg-yellow-500 hover:bg-yellow-600 text-white text-xs py-1 px-2 rounded-lg shadow-sm transition-colors">
                    Scale Down
                </button>
            </div>
        </div>

        <div id="audioUploadPreviewContainer" class="hidden flex items-center justify-between p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700">
            <audio id="audioUploadPreview" controls class="max-w-xs"></audio>
            <span id="audioFileName" class="text-sm text-gray-700 dark:text-gray-300 truncate flex-1 ml-4"></span>
            <div id="audioActions" class="flex flex-col space-y-2 ml-4">
                <button type="button" id="cancelAudioUploadButton" class="p-1 rounded-full text-red-500 hover:bg-red-100 dark:hover:bg-red-900 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
        </div>

        <div id="videoUploadPreviewContainer" class="hidden flex flex-col items-center justify-between p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700">
            <video id="videoUploadPreview" controls class="max-w-full max-h-48 rounded-md object-contain mb-2"></video>
            <span id="videoFileName" class="text-sm text-gray-700 dark:text-gray-300 truncate w-full text-center mb-2"></span>
            <div id="videoActions" class="flex justify-center space-x-2 w-full">
                <button type="button" id="cancelVideoButton" class="p-1 rounded-full text-red-500 hover:bg-red-100 dark:hover:bg-red-900 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                </button>
                <button type="button" id="scaleVideoButton" class="hidden bg-yellow-500 hover:bg-yellow-600 text-white text-xs py-1 px-2 rounded-lg shadow-sm transition-colors">
                    Scale Down
                </button>
            </div>
        </div>


        <div id="uploadProgressBarContainer" class="hidden w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
            <div id="uploadProgressBar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
        </div>

        <div id="fileSizeError" class="hidden bg-red-100 dark:bg-red-900 border border-red-400 text-red-700 dark:text-red-300 px-4 py-3 rounded-lg relative text-sm" role="alert">
            <strong class="font-bold">Error:</strong>
            <span class="block sm:inline" id="fileSizeErrorMessage">File size exceeds limit.</span>
        </div>

        <div id="audioRecordingStatus" class="hidden bg-blue-100 dark:bg-blue-900 border border-blue-400 text-blue-700 dark:text-blue-300 px-4 py-3 rounded-lg relative text-sm flex items-center justify-between" role="status">
            <span id="recordingMessage" class="flex items-center">
                <svg class="animate-pulse h-4 w-4 mr-2" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0c0 3.042 1.135 5.824 3 7.938V19a1 1 0 102 0v-2.062A8.001 8.001 0 0014 12c0-2.454-1.192-4.636-3-6.065V10a1 1 0 102 0V5a1 1 0 10-2 0v5.935z" clip-rule="evenodd"></path></svg>
                Recording voice message...
            </span>
            <button type="button" id="cancelRecordingButton" class="ml-4 p-1 rounded-full text-red-500 hover:bg-red-100 dark:hover:bg-red-900 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
            </button>
        </div>


        <div class="flex items-center space-x-3">
            <input
                type="file"
                id="fileInput"
                accept="image/*,audio/mpeg,audio/ogg,audio/webm,video/mp4,video/webm"
                class="hidden"
                aria-hidden="true" style="display: none;"
            />
            <button type="button" id="attachFileButton" class="p-2 rounded-lg bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 shadow-sm transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
            </button>
            <button type="button" id="recordButton" class="p-2 rounded-lg bg-red-500 hover:bg-red-600 text-white shadow-sm transition-colors flex items-center justify-center text-2xl">
                üéôÔ∏è
            </button>
            <input
                type="text"
                id="newMessageInput"
                placeholder="Type your message here..."
                class="flex-1 p-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-100 transition-all duration-300"
            />
            <button
                type="submit"
                id="sendButton"
                class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
            >
                <span id="sendButtonText">Send</span>
            </button>
        </div>
    </form>

    <div id="confirmationModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl text-center max-w-sm w-full">
            <p class="text-lg font-semibold mb-4 text-gray-900 dark:text-gray-100">Delete Message?</p>
            <p class="text-gray-700 dark:text-gray-300 mb-6">Are you sure you want to delete your message?</p>
            <div class="flex justify-center space-x-4">
                <button id="confirmDeleteYes" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 active:scale-95">
                    Yes, Delete
                </button>
                <button id="confirmDeleteNo" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 active:scale-95">
                    No, Keep
                </button>
            </div>
        </div>
    </div>

    <div id="userSettingsModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl text-center max-w-md w-full relative">
            <button id="closeSettingsModalButton" class="absolute top-3 right-3 text-gray-400 hover:text-gray-600 dark:hover:text-gray-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <h2 class="text-2xl font-bold mb-6 text-gray-900 dark:text-gray-100">User Settings</h2>

            <div class="mb-4">
                <label for="userColorInput" class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2">Message Color:</label>
                <input type="color" id="userColorInput" class="w-full h-10 rounded-lg cursor-pointer" value="#4CAF50">
            </div>

            <div class="mb-6">
                <label for="themeSelect" class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2">App Theme:</label>
                <select id="themeSelect" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-100">
                    <option value="light">Light</option>
                    <option value="dark">Dark</option>
                    <option value="midnight">Midnight (OLED Optimized)</option>
                    <option value="autumn">Autumn</option>
                    <option value="terminal">Terminal</option>
                    <option value="mario">Super Mario Bros.</option>
                    <option value="windows95">Windows 95</option>
                    <option value="windowsxp">Windows XP</option>
                    <option value="windows7">Windows 7</option>
                    <option value="windows10">Windows 10</option>
                    <option value="wackybox">Wackybox (Ugly Mode)</option>
                    <option value="system">System</option>
                </select>
            </div>

            <button id="saveUserSettingsButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 active:scale-95">
                Save Settings
            </button>
        </div>
    </div>

    <!-- Friend Details Modal - NOW FOR NICKNAME AND NOTE -->
    <div id="friendDetailsModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl text-center max-w-sm w-full relative">
            <button id="closeFriendDetailsModalButton" class="absolute top-3 right-3 text-gray-400 hover:text-gray-600 dark:hover:text-gray-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <h2 class="text-2xl font-bold mb-6 text-gray-900 dark:text-gray-100">Friend Details</h2>
            <p id="friendDetailsTargetId" class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">ID: </p>
            
            <div class="mb-4">
                <label for="friendNicknameInput" class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2">Nickname:</label>
                <input
                    type="text"
                    id="friendNicknameInput"
                    placeholder="Set a nickname for this friend"
                    class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-100"
                    maxlength="20"
                />
            </div>

            <div class="mb-6">
                <label for="friendNoteInput" class="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2">Personal Note:</label>
                <textarea
                    id="friendNoteInput"
                    placeholder="Add a personal note about this friend..."
                    class="w-full h-24 p-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-100 resize-none"
                    maxlength="200"
                ></textarea>
            </div>
            <button id="saveFriendDetailsButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105 active:scale-95">
                Save Details
            </button>
        </div>
    </div>

    <!-- Fullscreen Video Modal -->
    <div id="fullscreenVideoModal" class="fixed inset-0 bg-black bg-opacity-95 flex items-center justify-center z-50 hidden">
        <button id="closeFullscreenVideoButton" class="absolute top-4 right-4 text-white text-3xl p-2 rounded-full hover:bg-gray-700 transition-colors">
            &times;
        </button>
        <video id="fullscreenVideo" class="max-w-full max-h-full object-contain" controls autoplay></video>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, onSnapshot, serverTimestamp, doc, deleteDoc, updateDoc, where, getDocs, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"; 

        // IMPORTANT: In a real application, consider externalizing Firebase config securely.
        // This config is exposed for the purpose of this interactive demo.
        const firebaseConfig = {
            apiKey: "AIzaSyCbIMQv9Z44Ms2zNZh2SAmELkS8AJKsYvo",
            authDomain: "chat-5c6f4.firebaseapp.com",
            projectId: "chat-5c6f4",
            storageBucket: "chat-5c6f4.firebaseapp.com",
            messagingSenderId: "450004774412",
            appId: "1:450004774412:web:160c2275021b82745b4829",
            measurementId: "G-2Y6JBMK2CP"
        };

        // Use the explicit appId provided by the user
        const appId = 'chat-5c6f4';

        let db;
        let auth;
        let currentUserId = null;
        let currentUserName = localStorage.getItem('wChatUserName') || '';
        let currentChannelId = localStorage.getItem('wChatCurrentChannel') || 'general-chat';
        let currentColor = localStorage.getItem('wChatUserColor') || '#4CAF50';
        let currentTheme = localStorage.getItem('wChatTheme') || 'dark';
        let messageListenerInitialized = false;
        let messageIdToDelete = null;
        let messageIdToEdit = null;
        let originalMessageText = null;
        let unsubscribeMessages = null;
        let currentImageFile = null;
        let currentVideoFile = null; 
        let fileErrorTimeout = null;
        
        // Firestore document size limit in bytes (1 MiB)
        const FIRESTORE_MAX_DOC_SIZE = 1048576; // Corrected to 1 MiB
        // Maximum raw file size before Base64 encoding to ensure it fits within Firestore's 1MB limit.
        // Base64 encoding adds approximately 33% overhead (multiply by 0.75 for safety).
        const MAX_RAW_FILE_SIZE_BEFORE_ENCODING = Math.floor(FIRESTORE_MAX_DOC_SIZE * 0.75);

        // Voice Recording related variables
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let recordingTimeout;
        const MAX_RECORDING_TIME_MS = 60000; // 1 minute maximum recording
        let currentAudioFile = null; // To hold the recorded audio Blob or uploaded audio file


        const userIdDisplayHeader = document.getElementById('userIdDisplayHeader'); // This is the one in the header
        const userIdDisplayFriendsList = document.getElementById('userIdDisplayFriendsList'); // This is the one in the sidebar
        const nicknameInput = document.getElementById('nicknameInput');
        const messagesListContainer = document.getElementById('messagesListContainer');
        const newMessageInput = document.getElementById('newMessageInput');
        const messageForm = document.getElementById('messageForm');
        const noMessagesPlaceholder = document.getElementById('noMessagesPlaceholder');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const confirmationModal = document.getElementById('confirmationModal');
        const confirmDeleteYes = document.getElementById('confirmDeleteYes');
        const confirmDeleteNo = document.getElementById('confirmDeleteNo');
        const channelInput = document.getElementById('channelInput');
        const joinChannelButton = document.getElementById('joinChannelButton');
        const currentChannelDisplay = document.getElementById('currentChannelDisplay');
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebarToggle');
        const toggleIcon = document.getElementById('toggleIcon');
        const publicChannelList = document.getElementById('publicChannelList');
        const sendButton = document.getElementById('sendButton');
        const sendButtonText = document.getElementById('sendButtonText');

        // Image elements
        const imagePreviewContainer = document.getElementById('imagePreviewContainer');
        const imagePreview = document.getElementById('imagePreview');
        const imageFileName = document.getElementById('imageFileName');
        const cancelImageButton = document.getElementById('cancelImageButton');
        const scaleImageButton = document.getElementById('scaleImageButton');

        // Audio Upload elements
        const audioUploadPreviewContainer = document.getElementById('audioUploadPreviewContainer');
        const audioUploadPreview = document.getElementById('audioUploadPreview');
        const audioFileName = document.getElementById('audioFileName');
        const cancelAudioUploadButton = document.getElementById('cancelAudioUploadButton');

        // Video Upload elements
        const videoUploadPreviewContainer = document.getElementById('videoUploadPreviewContainer');
        const videoUploadPreview = document.getElementById('videoUploadPreview');
        const videoFileName = document.getElementById('videoFileName');
        const cancelVideoButton = document.getElementById('cancelVideoButton');
        const scaleVideoButton = document.getElementById('scaleVideoButton');

        // Unified File Input elements
        const fileInput = document.getElementById('fileInput');
        const attachFileButton = document.getElementById('attachFileButton');


        const uploadProgressBarContainer = document.getElementById('uploadProgressBarContainer');
        const uploadProgressBar = document.getElementById('uploadProgressBar');
        const fileSizeError = document.getElementById('fileSizeError'); 
        const fileSizeErrorMessage = document.getElementById('fileSizeErrorMessage'); 

        const channelToggleButton = document.getElementById('channelToggleButton'); // NEW: This is the button inside the sidebar
        const channelToggleIcon = document.getElementById('channelToggleIcon');
        const channelControlArea = document.getElementById('channelControlArea'); // This entire div is now in the sidebar
        const channelInputContent = document.getElementById('channelInputContent'); // New div to toggle visibility of channel inputs

        const userSettingsButton = document.getElementById('userSettingsButton');
        const userSettingsModal = document.getElementById('userSettingsModal');
        const closeSettingsModalButton = document.getElementById('closeSettingsModalButton');
        const userColorInput = document.getElementById('userColorInput');
        const themeSelect = document.getElementById('themeSelect');
        const saveUserSettingsButton = document.getElementById('saveUserSettingsButton');

        // Voice Recording elements
        const recordButton = document.getElementById('recordButton');
        const audioRecordingStatus = document.getElementById('audioRecordingStatus');
        const recordingMessage = document.getElementById('recordingMessage');
        const cancelRecordingButton = document.getElementById('cancelRecordingButton');

        // WebRTC elements
        const webrtcMainPanel = document.getElementById('webrtcMainPanel'); 
        const targetUserIdInput = document.getElementById('targetUserIdInput');
        const startCallButton = document.getElementById('startCallButton');
        const answerCallButton = document.getElementById('answerCallButton');
        const endCallButton = document.getElementById('endCallButton');
        const callStatus = document.getElementById('callStatus');
        const remoteAudio = document.getElementById('remoteAudio');
        const localVideo = document.getElementById('localVideo'); 
        const remoteVideo = document.getElementById('remoteVideo'); 
        const toggleVideoButton = document.getElementById('toggleVideoButton'); 
        const toggleAudioButton = document.getElementById('toggleAudioButton'); 
        const toggleScreenShareButton = document.getElementById('toggleScreenShareButton'); 
        const videoFeedsContainer = document.getElementById('videoFeedsContainer'); 
        const webrtcToggleButton = document.getElementById('webrtcToggleButton'); 
        const webrtcToggleIcon = document.getElementById('webrtcToggleIcon');   
        
        // 4-digit code elements
        const generatedCallCodeDisplay = document.getElementById('generatedCallCodeDisplay');
        const generateCallCodeButton = document.getElementById('generateCallCodeButton');
        const callCodeInput = document.getElementById('callCodeInput');

        // Friends List Elements
        const friendsSidebar = document.getElementById('friendsSidebar');
        const friendsToggleButton = document.getElementById('friendsToggleButton');
        const friendsToggleIcon = document.getElementById('friendsToggleIcon');
        const friendsList = document.getElementById('friendsList');
        const addFriendFromCallButton = document.getElementById('addFriendFromCallButton'); 
        
        // Friend Details Modal elements (formerly Friend Note Modal)
        const friendDetailsModal = document.getElementById('friendDetailsModal'); 
        const closeFriendDetailsModalButton = document.getElementById('closeFriendDetailsModalButton'); 
        const friendDetailsTargetId = document.getElementById('friendDetailsTargetId'); 
        const friendNicknameInput = document.getElementById('friendNicknameInput'); 
        const friendNoteInput = document.getElementById('friendNoteInput'); 
        const saveFriendDetailsButton = document.getElementById('saveFriendDetailsButton'); 

        // New elements for Add Friend by Code
        const addFriendByCodePanel = document.getElementById('addFriendByCodePanel');
        const addFriendByCodeToggleButton = document.getElementById('addFriendByCodeToggleButton');
        const addFriendByCodeToggleIcon = document.getElementById('addFriendByCodeToggleIcon');
        const addFriendByCodeContent = document.getElementById('addFriendByCodeContent');
        const friendCodeInput = document.getElementById('friendCodeInput');
        const addFriendByCodeButton = document.getElementById('addFriendByCodeButton');

        // Fullscreen Video Elements
        const fullscreenVideoModal = document.getElementById('fullscreenVideoModal');
        const fullscreenVideo = document.getElementById('fullscreenVideo');
        const closeFullscreenVideoButton = document.getElementById('closeFullscreenVideoButton');
        const enlargeRemoteVideoButton = document.getElementById('enlargeRemoteVideoButton');

        // WebRTC specific variables
        let peerConnection;
        let localStream; // Combined camera and mic stream
        let screenShareStream; // Separate stream for screen share
        let callTargetUserId = null;
        let webrtcMessageListenerUnsubscribe = null;
        let iceCandidatesQueue = []; 
        let isScreenSharing = false; // Flag to track screen sharing status
        let currentGeneratedCallCode = null; // Store the currently generated 4-digit code
        let isLocalVideoEnabled = false; // Track if local camera video is intentionally enabled
        let isLocalAudioEnabled = true; // Track if local audio is intentionally enabled (default true)


        // Friends list specific variables
        let friendsListenerUnsubscribe = null;
        let currentFriends = {}; // Map of friendUserId to friend object {userId: {nickname, note}}
        let currentFriendIdForDetails = null; // Stores the friendId for whom the details modal is open

        // WebRTC configuration (STUN/TURN servers)
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
            ]
        };

        // Audio elements for connect and disconnect sounds
        const connectSound = new Audio('https://file.garden/ZMbUnW5nmTe-x54m/connect.mp3');
        const disconnectSound = new Audio('https://file.garden/ZPjrzSdXf2vX5mNF/disconnect.mp3');

        // List of public channels available
        const publicChannels = [
            'info-and-rules', 'general', 'general2', 'chat', 'public',
            'math', 'science', 'algebra', 'chemistry', 'studies',
            'history', 'trig', 'ffa', 'geometry', 'geography',
            'paisley', 'rants'
        ];

        /**
         * Applies the selected theme to the body element.
         * Handles both predefined themes and system preference.
         * @param {string} theme - The name of the theme to apply.
         */
        function applyTheme(theme) {
            const body = document.body;
            // Remove all existing theme classes to prevent conflicts
            body.classList.remove('light', 'dark', 'midnight', 'autumn', 'terminal', 'mario', 'windows95', 'windowsxp', 'windows7', 'windows10', 'wackybox');

            if (theme === 'system') {
                // Apply 'dark' or 'light' based on user's system preference
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    body.classList.add('dark');
                } else {
                    body.classList.add('light');
                }
            } else {
                // Apply the selected custom theme
                body.classList.add(theme);
            }
        }

        // Apply theme on initial load based on localStorage or default to 'dark'
        applyTheme(localStorage.getItem('wChatTheme') || 'dark');

        // Initialize input fields with stored values
        nicknameInput.value = currentUserName;
        channelInput.value = currentChannelId;
        currentChannelDisplay.textContent = `Current: #${currentChannelId}`;

        /**
         * Resets the message input area from edit mode to send mode.
         */
        function resetEditMode() {
            messageIdToEdit = null;
            originalMessageText = null;
            newMessageInput.value = '';
            sendButtonText.textContent = 'Send';
        }

        /**
         * Clears any selected image file and hides the image preview elements.
         */
        function clearImageSelection() {
            if (imagePreview.src && imagePreview.src.startsWith('blob:')) {
                URL.revokeObjectURL(imagePreview.src); // Clean up old object URL
            }
            currentImageFile = null;
            imagePreview.src = '';
            imageFileName.textContent = '';
            imagePreviewContainer.classList.add('hidden');
            scaleImageButton.classList.add('hidden'); // Hide scale button
            hideFileSizeMessage(); // Use the new hide function
        }

        /**
         * Clears any selected audio file (either uploaded or recorded) and hides related UI elements.
         */
        function clearAudioFileSelection() {
            if (audioUploadPreview.src && audioUploadPreview.src.startsWith('blob:')) {
                URL.revokeObjectURL(audioUploadPreview.src); // Clean up old object URL
            }
            currentAudioFile = null;
            audioUploadPreview.src = '';
            audioFileName.textContent = '';
            audioUploadPreviewContainer.classList.add('hidden');
            hideFileSizeMessage(); // Use the new hide function
        }

        /**
         * Clears any selected video file and hides the video preview elements.
         */
        function clearVideoSelection() {
            if (videoUploadPreview.src && videoUploadPreview.src.startsWith('blob:')) {
                URL.revokeObjectURL(videoUploadPreview.src); // Clean up old object URL
            }
            currentVideoFile = null;
            videoUploadPreview.src = '';
            videoFileName.textContent = '';
            videoUploadPreviewContainer.classList.add('hidden');
            scaleVideoButton.classList.add('hidden'); // Hide scale button
            hideFileSizeMessage(); // Use the new hide function
        }


        /**
         * Clears all media selections and associated UI elements.
         */
        function clearAllMediaSelections() {
            fileInput.value = ''; // Crucially clears the single file input
            clearImageSelection();
            clearAudioFileSelection(); // Clears uploaded audio preview
            clearVideoSelection(); // Clear video selection
            audioRecordingStatus.classList.add('hidden'); // Ensure recording status is hidden if a new media type is selected or text is typed
        }

        /**
         * Displays a message related to file size (error or success).
         * @param {string} message - The message to display.
         * @param {boolean} isSuccess - True if it's a success message, false for error.
         */
        function showFileSizeMessage(message, isSuccess = false) {
            fileSizeErrorMessage.textContent = message;
            fileSizeError.classList.remove('hidden');
            if (isSuccess) {
                fileSizeError.classList.remove('bg-red-100', 'border-red-400', 'text-red-700', 'dark:bg-red-900', 'dark:text-red-300');
                fileSizeError.classList.add('bg-green-100', 'border-green-400', 'text-green-700', 'dark:bg-green-900', 'dark:text-green-300');
                fileSizeError.querySelector('strong').textContent = 'Success:';
            } else {
                fileSizeError.classList.remove('bg-green-100', 'border-green-400', 'text-green-700', 'dark:bg-green-900', 'dark:text-green-300');
                fileSizeError.classList.add('bg-red-100', 'border-red-400', 'text-red-700', 'dark:bg-red-900', 'dark:text-red-300');
                fileSizeError.querySelector('strong').textContent = 'Error:';
            }

            if (fileErrorTimeout) {
                clearTimeout(fileErrorTimeout);
            }
            fileErrorTimeout = setTimeout(() => {
                hideFileSizeMessage();
            }, 5000); // Message fades after 5 seconds
        }

        /**
         * Hides the file size message.
         */
        function hideFileSizeMessage() {
            fileSizeError.classList.add('hidden');
            if (fileErrorTimeout) {
                clearTimeout(fileErrorTimeout);
                fileErrorTimeout = null;
            }
        }


        /**
         * Scrolls the messages container to the bottom.
         */
        function scrollToBottom() {
            messagesListContainer.scrollTop = messagesListContainer.scrollHeight;
        }

        /**
         * Ensures the user's private friends collection exists in Firestore by creating a placeholder document.
         */
        async function ensureFriendsCollectionExists() {
            if (!db || !currentUserId) {
                console.warn("Firestore or currentUserId not ready to ensure friends collection exists.");
                return;
            }
            try {
                // Create a placeholder document. Using 'FriendsHere' as a doc ID.
                // setDoc with merge:true ensures it won't overwrite existing data if friends are added later.
                await setDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/friends`, 'FriendsHere'), {}, { merge: true });
                console.log(`Ensured friends collection exists for user ${currentUserId} with placeholder document.`);
            } catch (error) {
                console.error("Error ensuring friends collection exists:", error);
            }
        }

        /**
         * Initializes Firebase authentication and Firestore.
         * Sets up the authentication state listener.
         */
        async function initializeFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Listen for authentication state changes
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        userIdDisplayHeader.textContent = `Your ID: ${currentUserId}`; // Update the userIdDisplay in the header
                        userIdDisplayFriendsList.textContent = currentUserId; // Update the userIdDisplay in the sidebar
                        // Once authenticated, setup WebRTC signaling listener
                        setupWebRTCSignalingListener();
                        await ensureFriendsCollectionExists(); // Ensure friends collection exists after auth
                        setupFriendsListener(); // Initialize friends listener
                    } else {
                        // If no user is signed in, sign in anonymously or with custom token if available
                        try {
                             if (typeof __initial_auth_token !== 'undefined') {
                                await signInWithCustomToken(auth, __initial_auth_token);
                            } else {
                                await signInAnonymously(auth);
                            }
                            currentUserId = auth.currentUser.uid; 
                            userIdDisplayHeader.textContent = `Your ID: ${currentUserId}`; // Update the userIdDisplay in the header
                            userIdDisplayFriendsList.textContent = currentUserId; // Update the userIdDisplay in the sidebar
                            setupWebRTCSignalingListener();
                            await ensureFriendsCollectionExists(); // Ensure friends collection exists after auth
                            setupFriendsListener(); // Initialize friends listener
                        } catch (error) {
                            console.error("Error during anonymous sign-in:", error);
                            currentUserId = crypto.randomUUID(); // Fallback to random ID if auth fails
                            userIdDisplayHeader.textContent = `Your ID: ${currentUserId} (Unauthenticated)`; // Update the userIdDisplay in the header
                            userIdDisplayFriendsList.textContent = `${currentUserId} (Unauthenticated)`; // Update the userIdDisplay in the sidebar
                            console.warn("Authentication failed. User will have limited functionality.");
                        }
                    }

                    // Once authentication is ready, set up the message listener
                    if (!messageListenerInitialized) {
                        loadingIndicator.classList.add('hidden');
                        setupMessageListener();
                        messageListenerInitialized = true;
                    }
                });
            } catch (error) {
                console.error("Error initializing Firebase App:", error);
                console.error("Firebase Config being used:", firebaseConfig); // Log the config for debugging
                loadingIndicator.textContent = "Error loading chat: Firebase App init failed. Check your Firebase config and network.";
            }
        }

        /**
         * Sets up a real-time listener for messages in the current channel.
         * Unsubscribes from previous listeners if any.
         */
        function setupMessageListener() {
            // Unsubscribe from previous listener if it exists
            if (unsubscribeMessages) {
                unsubscribeMessages();
            }

            if (!db || !currentChannelId) {
                console.warn("Firestore or currentChannelId not ready for message listener.");
                return;
            }

            // Show loading indicator and hide placeholder
            loadingIndicator.classList.remove('hidden');
            noMessagesPlaceholder.classList.add('hidden');
            messagesListContainer.innerHTML = ''; // Clear existing messages
            resetEditMode(); // Reset input field
            clearAllMediaSelections(); // Clear any media selection and recording status visual

            // Create a query to fetch messages for the current channel, ordered by timestamp
            // Removed 'where('type', '==', 'chat')' to avoid requiring a composite index.
            // Filtering will now happen in renderMessages.
            const q = query(
                collection(db, `artifacts/${appId}/public/data/messages`),
                where('channelId', '==', currentChannelId),
                orderBy('timestamp') 
            );

            // Set up the real-time listener
            unsubscribeMessages = onSnapshot(q, (snapshot) => {
                loadingIndicator.classList.add('hidden'); // Hide loading indicator once data is received
                messagesListContainer.innerHTML = ''; // Clear messages again before rendering
                const chatMessages = [];

                // Filter for chat messages only
                snapshot.forEach((doc) => {
                    const msg = { ...doc.data(), id: doc.id };
                    if (msg.type === 'chat') {
                        chatMessages.push(msg);
                    }
                });

                // Show/hide no messages placeholder based on filtered message list emptiness
                if (chatMessages.length === 0) {
                    noMessagesPlaceholder.classList.remove('hidden');
                } else {
                    noMessagesPlaceholder.classList.add('hidden');
                }

                renderMessages(chatMessages); // Render the filtered messages
                scrollToBottom(); // Scroll to the latest message
            }, (error) => {
                console.error("Error fetching messages:", error);
                loadingIndicator.classList.add('hidden');
                messagesListContainer.innerHTML = `<div class="text-center text-red-500 dark:text-red-400">Error loading messages: ${error.message}</div>`;
            });
        }

        /**
         * Renders an array of message objects into the messages list container.
         * @param {Array<Object>} messages - An array of message objects to render.
         */
        function renderMessages(messages) {
            messages.forEach(msg => {
                // Skip WebRTC signaling messages from being displayed in the chat feed
                // This check is redundant now as `setupMessageListener` filters by type, but kept for safety.
                if (msg.type && msg.type.startsWith('webrtc-')) {
                    return;
                }

                const messageDiv = document.createElement('div');
                // Align messages based on sender
                messageDiv.className = `flex ${msg.userId === currentUserId ? 'justify-end' : 'justify-start'}`;

                const messageBubble = document.createElement('div');
                const isImageMessage = msg.imageDataUrl && (!msg.text || msg.text.trim() === '');
                const isAudioMessage = msg.audioDataUrl && (!msg.text || msg.text.trim() === '');
                const isVideoMessage = msg.videoDataUrl && (!msg.text || msg.text.trim() === ''); 

                // Apply styling based on sender and whether it's an image-only or audio-only message
                messageBubble.className = `max-w-xs md:max-w-md lg:max-w-lg p-3 rounded-xl shadow-lg relative break-words
                    ${msg.userId === currentUserId
                        ? 'bg-blue-500 text-white rounded-br-none'
                        : 'bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 rounded-bl-none'
                    }
                    ${isImageMessage || isAudioMessage || isVideoMessage ? 'p-1' : ''} `; // Smaller padding for media-only messages

                // Display user's nickname
                const userNameP = document.createElement('p');
                userNameP.className = `text-xs font-semibold mb-1`;
                userNameP.textContent = msg.userName || 'Anonymous';
                userNameP.style.color = msg.senderColor || '#000000'; // Apply custom color
                messageBubble.appendChild(userNameP);

                // Display image if available
                if (msg.imageDataUrl) {
                    const imgElement = document.createElement('img');
                    imgElement.src = msg.imageDataUrl;
                    imgElement.alt = "Shared Image";
                    imgElement.className = "max-w-full h-auto rounded-lg mb-2 cursor-pointer";
                    imgElement.style.maxWidth = '250px'; // Limit image size
                    imgElement.style.maxHeight = '250px';
                    imgElement.loading = "lazy"; // Lazy load images
                    imgElement.onerror = (e) => {
                        // Fallback for broken images
                        e.target.onerror = null;
                        e.target.src = "https://placehold.co/200x200/cccccc/333333?text=Image+Load+Error";
                        e.target.alt = "Image failed to load.";
                    };
                    imgElement.onclick = () => window.open(msg.imageDataUrl, '_blank'); // Open image in new tab
                    messageBubble.appendChild(imgElement);
                }

                // Display audio if available
                if (msg.audioDataUrl) {
                    const audioPlayer = document.createElement('audio');
                    audioPlayer.controls = true;
                    audioPlayer.src = msg.audioDataUrl;
                    audioPlayer.className = "my-2 rounded-lg"; 

                    // Define min/max widths and max duration for scaling
                    const minAudioWidthPx = 150; // Minimum width in pixels
                    const maxAudioWidthPx = 350; // Maximum width in pixels
                    const maxAudioDurationForScaling = 60; // Max duration (seconds) for full width scaling

                    // Set an initial minimum width while metadata loads
                    audioPlayer.style.width = `${minAudioWidthPx}px`;

                    // Listen for metadata to load to get the duration and adjust width proportionally
                    audioPlayer.addEventListener('loadedmetadata', () => {
                        let duration = audioPlayer.duration; // Duration in seconds

                        if (isNaN(duration) || duration <= 0) {
                            // If duration is invalid, keep min width
                            audioPlayer.style.width = `${minAudioWidthPx}px`;
                            return;
                        }

                        // Calculate width based on duration, clamped between min and max
                        let calculatedWidth = minAudioWidthPx +
                            (duration / maxAudioDurationForScaling) * (maxAudioWidthPx - minAudioWidthPx);

                        calculatedWidth = Math.max(minAudioWidthPx, Math.min(maxAudioWidthPx, calculatedWidth));

                        audioPlayer.style.width = `${calculatedWidth}px`;
                        console.log(`Audio duration: ${duration.toFixed(2)}s, Calculated width: ${calculatedWidth.toFixed(2)}px`);
                    });

                    messageBubble.appendChild(audioPlayer);
                }

                // Display video if available
                if (msg.videoDataUrl) {
                    const videoElement = document.createElement('video');
                    videoElement.controls = true;
                    videoElement.src = msg.videoDataUrl;
                    videoElement.className = "max-w-full h-auto rounded-lg mb-2 cursor-pointer";
                    videoElement.style.maxWidth = '300px'; // Limit video size
                    videoElement.style.maxHeight = '200px';
                    videoElement.loading = "lazy"; // Lazy load videos
                    videoElement.onerror = (e) => {
                        // Fallback for broken videos
                        e.target.onerror = null;
                        e.target.src = "https://placehold.co/300x200/cccccc/333333?text=Video+Load+Error";
                        e.target.alt = "Video failed to load.";
                    };
                    videoElement.onclick = () => window.open(msg.videoDataUrl, '_blank'); // Open video in new tab
                    messageBubble.appendChild(videoElement);
                }

                // Display message text if available
                if (msg.text && msg.text.trim() !== '') {
                    const messageTextP = document.createElement('p');
                    messageTextP.className = 'text-base';
                    messageTextP.textContent = msg.text;
                    messageBubble.appendChild(messageTextP);
                }

                // Display timestamp
                const timestampSpan = document.createElement('span');
                timestampSpan.className = 'text-xs text-opacity-75 block text-right mt-1';
                if (msg.timestamp && typeof msg.timestamp.toDate === 'function') {
                    // Firestore Timestamp object
                    timestampSpan.textContent = msg.timestamp.toDate().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                } else if (msg.timestamp) {
                     // Fallback for plain timestamp (e.g., from initial object)
                     timestampSpan.textContent = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                }
                messageBubble.appendChild(timestampSpan);
                messageDiv.appendChild(messageBubble);

                // Add edit and delete buttons for the current user's messages
                if (msg.userId === currentUserId) {
                    const editButton = document.createElement('button');
                    editButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                                              <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zm-6.071 6.071l-1.414 1.414 4.243 4.243 1.414-1.414-4.243-4.243z" />
                                              <path fill-rule="evenodd" d="M3 6a2 2 0 012-2h4a1 1  0 010 2H5v9h9V8a1 1 0 012 0v8a2 2 0 01-2 2H5a2 2 0 01-2-2V6z" clip-rule="evenodd" />
                                            </svg>`;
                    editButton.className = 'absolute -top-2 left-2 bg-blue-500 hover:bg-blue-600 text-white p-1 rounded-full shadow-md transition-transform duration-200 transform hover:scale-110';
                    editButton.title = 'Edit Message';
                    editButton.onclick = () => {
                        messageIdToEdit = msg.id;
                        originalMessageText = msg.text;
                        newMessageInput.value = msg.text || ''; // Pre-fill input with message text
                        sendButtonText.textContent = 'Save Edits'; // Change button text
                        newMessageInput.focus(); // Focus on the input field
                        clearAllMediaSelections(); // Clear any existing media selections for editing text
                        scrollToBottom(); // Scroll to the input area
                    };
                    messageBubble.appendChild(editButton);

                    const deleteButton = document.createElement('button');
                    deleteButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                                                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1  0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1zm1 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1zm1 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" clip-rule="evenodd" />
                                              </svg>`;
                    deleteButton.className = 'absolute -top-2 -right-2 bg-red-500 hover:bg-red-600 text-white p-1 rounded-full shadow-md transition-transform duration-200 transform hover:scale-110';
                    deleteButton.title = 'Delete Message';
                    deleteButton.onclick = () => {
                        messageIdToDelete = { id: msg.id }; // Store message ID for deletion
                        confirmationModal.classList.remove('hidden'); // Show confirmation modal
                    };
                    messageBubble.appendChild(deleteButton);
                }

                messagesListContainer.appendChild(messageDiv);
            });
        }

        /**
         * Sends a WebRTC signaling message via Firestore.
         * @param {string} type - Type of WebRTC message (offer, answer, candidate, hangup).
         * @param {Object} data - The SDP or ICE candidate data.
         * @param {string} targetUserId - The ID of the user to send the message to.
         * @param {string|null} callCode - Optional 4-digit code used for call initiation.
         */
        async function sendWebRTCSignalingMessage(type, data, targetId, callCode = null) {
            if (!db || !currentUserId || !targetId) {
                console.error("Cannot send WebRTC signaling message: DB, currentUserId, or targetId not available.");
                return;
            }

            try {
                const messagePayload = {
                    type: `webrtc-${type}`, // e.g., 'webrtc-offer', 'webrtc-answer', 'webrtc-candidate', 'webrtc-hangup'
                    senderUserId: currentUserId,
                    targetUserId: targetId,
                    data: JSON.stringify(data), // Stringify complex objects for Firestore
                    timestamp: serverTimestamp(),
                    channelId: currentChannelId // Still associate with the channel for general context/filtering
                };

                if (callCode) {
                    messagePayload.callCode = callCode; // Add callCode if present
                }

                await addDoc(collection(db, `artifacts/${appId}/public/data/messages`), messagePayload);
                console.log(`WebRTC signaling message (${type}) sent to ${targetId}`);
            } catch (error) {
                console.error("Error sending WebRTC signaling message:", error);
            }
        }


        /**
         * Sets up a real-time listener for incoming WebRTC signaling messages
         * targeted at the current user.
         */
        function setupWebRTCSignalingListener() {
            if (webrtcMessageListenerUnsubscribe) {
                webrtcMessageListenerUnsubscribe(); // Unsubscribe from previous listener
            }

            if (!db || !currentUserId) {
                console.warn("Firestore or currentUserId not ready for WebRTC signaling listener.");
                return;
            }

            // Listen for signaling messages where this user is the target
            const q = query(
                collection(db, `artifacts/${appId}/public/data/messages`),
                where('targetUserId', '==', currentUserId)
            );

            webrtcMessageListenerUnsubscribe = onSnapshot(q, async (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === "added") {
                        const msg = change.doc.data();
                        // Only process WebRTC signaling messages
                        if (msg.type && msg.type.startsWith('webrtc-')) {
                            const signalingData = JSON.parse(msg.data);
                            console.log(`Received WebRTC signaling message (${msg.type}) from ${msg.senderUserId}:`, signalingData);

                            switch (msg.type) {
                                case 'webrtc-offer':
                                    // Check if this is a new call or if already calling same person
                                    if (callTargetUserId === null || callTargetUserId === msg.senderUserId) { 
                                        callTargetUserId = msg.senderUserId;
                                        let statusText = `Incoming call from ${msg.senderUserId}!`;
                                        if (msg.callCode) {
                                            statusText += ` (Code: ${msg.callCode})`;
                                        }
                                        callStatus.textContent = statusText;
                                        startCallButton.classList.add('hidden');
                                        answerCallButton.classList.remove('hidden');
                                        endCallButton.classList.remove('hidden');
                                        updateAddFriendButtonVisibility(); // Update button visibility
                                        enlargeRemoteVideoButton.classList.remove('hidden'); // Show enlarge button
                                        await handleOffer(signalingData);
                                    } else {
                                        console.warn(`Already in a call with ${callTargetUserId}, rejecting offer from ${msg.senderUserId}`);
                                        // Send a reject message or handle gracefully
                                    }
                                    break;
                                case 'webrtc-answer':
                                    if (peerConnection) {
                                        await peerConnection.setRemoteDescription(new RTCSessionDescription(signalingData));
                                        // Process any queued ICE candidates after setting remote description
                                        while (iceCandidatesQueue.length > 0) {
                                            const candidate = iceCandidatesQueue.shift();
                                            try {
                                                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                                            } catch (e) {
                                                console.error('Error adding queued ICE candidate:', e);
                                            }
                                        }
                                        callStatus.textContent = `Call established with ${msg.senderUserId}.`;
                                        connectSound.play().catch(e => console.warn("Connect sound play failed:", e)); 
                                        // If an answer is received, it means the code was successfully used to establish a call
                                        // Delete the code from firestore if it was used by THIS user (the one who generated it)
                                        if (currentGeneratedCallCode) {
                                            deleteCallCode(currentGeneratedCallCode);
                                            generatedCallCodeDisplay.textContent = 'N/A';
                                            currentGeneratedCallCode = null;
                                        }
                                        updateAddFriendButtonVisibility(); // Update button visibility
                                        enlargeRemoteVideoButton.classList.remove('hidden'); // Show enlarge button
                                    }
                                    break;
                                case 'webrtc-candidate':
                                    if (peerConnection) {
                                        // Add candidate directly if remote description is already set
                                        if (peerConnection.remoteDescription) {
                                            try {
                                                await peerConnection.addIceCandidate(new RTCIceCandidate(signalingData));
                                            } catch (e) {
                                                console.error('Error adding received ICE candidate:', e);
                                            }
                                        } else {
                                            // Queue candidate if remote description is not yet set
                                            console.log('Queueing ICE candidate (remote description not set yet):', signalingData);
                                            iceCandidatesQueue.push(signalingData);
                                        }
                                    }
                                    break;
                                case 'webrtc-hangup':
                                    handleHangup();
                                    callStatus.textContent = `${msg.senderUserId} ended the call.`;
                                    // If a hangup is received, also clear any generated code for this user
                                    if (currentGeneratedCallCode) {
                                        deleteCallCode(currentGeneratedCallCode);
                                        generatedCallCodeDisplay.textContent = 'N/A';
                                        currentGeneratedCallCode = null;
                                    }
                                    break;
                            }
                            // Delete the signaling message after processing to keep Firestore clean
                            await deleteDoc(change.doc.ref);
                        }
                    }
                });
            }, (error) => {
                console.error("Error listening for WebRTC signaling messages:", error);
            });
        }

        /**
         * Generates a unique 4-digit code and stores it in Firestore.
         */
        async function generateFourDigitCode() {
            if (!db || !currentUserId) {
                callStatus.textContent = "Error: Not authenticated to generate code. Please wait for authentication.";
                console.error("Firestore or currentUserId not ready for generateFourDigitCode.");
                return;
            }

            // Clear any previously generated code for this user from Firestore
            if (currentGeneratedCallCode) {
                await deleteCallCode(currentGeneratedCallCode);
                currentGeneratedCallCode = null; // Clear local state
            }
            
            generatedCallCodeDisplay.textContent = 'Generating...';
            generateCallCodeButton.disabled = true;

            let newCode;
            let isUnique = false;
            let attempts = 0;
            const MAX_ATTEMPTS = 10;

            while (!isUnique && attempts < MAX_ATTEMPTS) {
                newCode = String(Math.floor(1000 + Math.random() * 9000)); // Generate 4-digit number
                
                // Check if code already exists and is active
                const q = query(collection(db, `artifacts/${appId}/public/data/call_codes`), where('code', '==', newCode));
                const querySnapshot = await getDocs(q);
                
                if (querySnapshot.empty) {
                    isUnique = true;
                } else {
                    console.log(`Code ${newCode} already exists, retrying...`);
                    attempts++;
                }
            }

            if (!isUnique) {
                callStatus.textContent = "Failed to generate a unique code. Please try again.";
                generatedCallCodeDisplay.textContent = 'Error';
                generateCallCodeButton.disabled = false;
                return;
            }

            try {
                await addDoc(collection(db, `artifacts/${appId}/public/data/call_codes`), {
                    code: newCode,
                    userId: currentUserId,
                    timestamp: serverTimestamp(),
                    active: true // Mark as active
                });
                currentGeneratedCallCode = newCode;
                generatedCallCodeDisplay.textContent = newCode;
                callStatus.textContent = `Share code ${newCode} to receive a call.`;
            } catch (error) {
                console.error("Error saving call code:", error);
                callStatus.textContent = `Error generating code: ${error.message}`;
                generatedCallCodeDisplay.textContent = 'Error';
            } finally {
                generateCallCodeButton.disabled = false;
            }
        }

        /**
         * Deletes a specific call code from Firestore.
         * @param {string} codeToDelete - The 4-digit code to delete.
         */
        async function deleteCallCode(codeToDelete) {
            if (!db || !currentUserId) {
                console.warn("Firestore or currentUserId not ready for deleteCallCode.");
                return;
            }
            try {
                const q = query(collection(db, `artifacts/${appId}/public/data/call_codes`), where('code', '==', codeToDelete));
                const querySnapshot = await getDocs(q);
                querySnapshot.forEach(async (docRef) => {
                    await deleteDoc(doc(db, `artifacts/${appId}/public/data/call_codes`, docRef.id));
                    console.log(`Call code ${codeToDelete} deleted from Firestore.`);
                });
            } catch (error) {
                console.error(`Error deleting call code ${codeToDelete}:`, error);
            }
        }


        /**
         * Initializes WebRTC peer connection and gets local audio stream.
         * Now handles both direct User ID calls and 4-digit code calls.
         * Camera is off by default.
         */
        async function startCall() {
            if (!db || !currentUserId) {
                callStatus.textContent = "Error: Not authenticated. Please wait for authentication.";
                console.error("Firestore or currentUserId not ready for startCall.");
                return;
            }

            let targetId = targetUserIdInput.value.trim();
            const codeToJoin = callCodeInput.value.trim();
            let isCodeBasedCall = false;

            // Determine call type
            if (targetId && codeToJoin) {
                callStatus.textContent = "Please use either User ID or 4-digit code, not both.";
                return;
            } else if (codeToJoin) {
                isCodeBasedCall = true;
                // Lookup targetUserId from the code
                callStatus.textContent = `Looking up code ${codeToJoin}...`;
                try {
                    const q = query(collection(db, `artifacts/${appId}/public/data/call_codes`), where('code', '==', codeToJoin));
                    const querySnapshot = await getDocs(q);
                    if (querySnapshot.empty) {
                        callStatus.textContent = `Code ${codeToJoin} not found or expired.`;
                        return;
                    }
                    const codeDoc = querySnapshot.docs[0].data();
                    targetId = codeDoc.userId;
                    // Delete the code immediately after successful lookup for single-use logic
                    await deleteDoc(doc(db, `artifacts/${appId}/public/data/call_codes`, querySnapshot.docs[0].id));
                    console.log(`Code ${codeToJoin} used and deleted.`);
                } catch (error) {
                    console.error("Error looking up call code:", error);
                    callStatus.textContent = `Error with code lookup: ${error.message}`;
                    return;
                }
            }

            if (!targetId || targetId === currentUserId) {
                callStatus.textContent = "Please enter a valid target User ID or 4-digit code (not your own).";
                return;
            }

            callTargetUserId = targetId; // Set the actual target user ID
            callStatus.textContent = `Calling ${callTargetUserId}...`;
            startCallButton.disabled = true;
            toggleAudioButton.classList.remove('hidden'); 
            toggleVideoButton.classList.remove('hidden'); // Always show, even if camera is off by default
            toggleScreenShareButton.classList.remove('hidden'); 
            enlargeRemoteVideoButton.classList.remove('hidden');
            updateAddFriendButtonVisibility(); // Update visibility here too, initial state hidden based on currentFriends[callTargetUserId]

            try {
                // Request only audio initially
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    },
                    video: false // Camera off by default
                });
                if (!localStream) {
                    throw new Error("Failed to get local audio stream. Microphone access denied or not available.");
                }
                // localVideo.srcObject will not be set initially as video is off.
                localVideo.classList.add('hidden'); // Ensure local video is hidden
                toggleVideoButton.textContent = 'Enable Video'; // Button reflects current state

                remoteAudio.srcObject = null; // Clear any previous remote audio
                remoteVideo.srcObject = null; // Clear any previous remote video

                peerConnection = new RTCPeerConnection(rtcConfig);

                // Log peer connection state changes
                peerConnection.onconnectionstatechange = () => {
                    console.log('Peer connection state changed:', peerConnection.connectionState);
                    callStatus.textContent = `Call status: ${peerConnection.connectionState}`; 
                    if (peerConnection.connectionState === 'connected') {
                        connectSound.play().catch(e => console.warn("Connect sound play failed:", e)); 
                        updateAddFriendButtonVisibility(); // Update button visibility on connection
                    } else if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                        handleHangup();
                        callStatus.textContent = `Call ended due to ${peerConnection.connectionState} state.`;
                    }
                };

                // Log ICE connection state changes
                peerConnection.oniceconnectionstatechange = () => {
                    console.log('ICE connection state changed:', peerConnection.iceConnectionState);
                    callStatus.textContent = `ICE status: ${peerConnection.iceConnectionState}`; 
                    if (peerConnection.iceConnectionState === 'failed' || peerConnection.iceConnectionState === 'disconnected') {
                        handleHangup();
                        callStatus.textContent = `Call ended: ICE connection ${peerConnection.iceConnectionState}.`;
                    }
                };

                // Add local stream's tracks to the peer connection
                localStream.getTracks().forEach(track => { 
                    peerConnection.addTrack(track, localStream);
                });

                // Event handler for when remote tracks are received
                peerConnection.ontrack = (event) => {
                    console.log('Remote track received:', event.track.kind, event.streams[0]);
                    if (event.track.kind === 'audio') {
                        if (remoteAudio.srcObject !== event.streams[0]) {
                            remoteAudio.srcObject = event.streams[0];
                            remoteAudio.play().catch(e => console.error("Error playing remote audio:", e));
                            remoteAudio.classList.remove('hidden');
                        }
                    } else if (event.track.kind === 'video') {
                        if (remoteVideo.srcObject !== event.streams[0]) {
                            remoteVideo.srcObject = event.streams[0];
                            remoteVideo.play().catch(e => console.error("Error playing remote video:", e));
                            remoteVideo.classList.remove('hidden');
                        }
                    }
                };

                // Event handler for ICE candidates (network information)
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('Sending ICE candidate:', event.candidate);
                        sendWebRTCSignalingMessage('candidate', event.candidate.toJSON(), callTargetUserId, isCodeBasedCall ? codeToJoin : null);
                    }
                };
                
                // Create and send SDP offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                console.log('Sending SDP offer:', offer);
                sendWebRTCSignalingMessage('offer', offer, callTargetUserId, isCodeBasedCall ? codeToJoin : null);

                callStatus.textContent = `Waiting for ${callTargetUserId} to answer...`;
                startCallButton.classList.add('hidden');
                answerCallButton.classList.add('hidden'); 
                endCallButton.classList.remove('hidden');
                endCallButton.disabled = false;

                targetUserIdInput.value = ''; // Clear target ID input after call initiation
                callCodeInput.value = ''; // Clear call code input

            } catch (error) {
                console.error("Error starting call:", error);
                callStatus.textContent = `Call failed: ${error.message}. Please check microphone permissions and try again.`;
                startCallButton.disabled = false;
                toggleVideoButton.classList.add('hidden'); 
                toggleAudioButton.classList.add('hidden'); 
                toggleScreenShareButton.classList.add('hidden');
                enlargeRemoteVideoButton.classList.add('hidden');
                updateAddFriendButtonVisibility(); // Ensure hidden on error
                handleHangup(); // Clean up if call fails to start
            }
        }

        /**
         * Handles an incoming SDP offer and sends back an answer.
         * Default camera is off when answering.
         * @param {Object} offer - The received SDP offer.
         */
        async function handleOffer(offer) {
            if (!peerConnection) {
                peerConnection = new RTCPeerConnection(rtcConfig);
                // Set up handlers for the new peerConnection
                peerConnection.onconnectionstatechange = () => {
                    console.log('Peer connection state changed (answer):', peerConnection.connectionState);
                    callStatus.textContent = `Call status: ${peerConnection.connectionState}`;
                    if (peerConnection.connectionState === 'connected') {
                        connectSound.play().catch(e => console.warn("Connect sound play failed:", e)); 
                        updateAddFriendButtonVisibility(); // Update button visibility on connection
                    } else if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                        handleHangup();
                        callStatus.textContent = `Call ended due to ${peerConnection.connectionState} state.`;
                    }
                };
                peerConnection.oniceconnectionstatechange = () => {
                    console.log('ICE connection state changed (answer):', peerConnection.iceConnectionState);
                    callStatus.textContent = `ICE status: ${peerConnection.iceConnectionState}`;
                    if (peerConnection.iceConnectionState === 'failed' || peerConnection.iceConnectionState === 'disconnected') {
                        handleHangup();
                        callStatus.textContent = `Call ended: ICE connection ${peerConnection.iceConnectionState}.`;
                    }
                };
                peerConnection.ontrack = (event) => {
                    console.log('Remote track received during answer:', event.track.kind, event.streams[0]);
                    if (event.track.kind === 'audio') {
                        if (remoteAudio.srcObject !== event.streams[0]) {
                            remoteAudio.srcObject = event.streams[0];
                            remoteAudio.play().catch(e => console.error("Error playing remote audio:", e));
                            remoteAudio.classList.remove('hidden');
                        }
                    } else if (event.track.kind === 'video') {
                        if (remoteVideo.srcObject !== event.streams[0]) {
                            remoteVideo.srcObject = event.streams[0];
                            remoteVideo.play().catch(e => console.error("Error playing remote video:", e));
                            remoteVideo.classList.remove('hidden');
                        }
                    }
                };
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('Sending ICE candidate (answer):', event.candidate);
                        sendWebRTCSignalingMessage('candidate', event.candidate.toJSON(), callTargetUserId); 
                    }
                };

                 // Add local audio tracks if we haven't already and the user has a microphone
                try {
                    if (!localStream) { 
                        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false }); // Camera off by default
                        if (!localStream) {
                            throw new Error("Failed to get local stream for answering call. Microphone access denied or not available.");
                        }
                    }
                    localStream.getTracks().forEach(track => { 
                        // Check if sender for this track kind already exists
                        const existingSender = peerConnection.getSenders().find(s => s.track && s.track.kind === track.kind);
                        if (!existingSender) {
                            peerConnection.addTrack(track, localStream);
                        }
                    });
                    localVideo.classList.add('hidden'); // Local video remains hidden by default
                    toggleVideoButton.textContent = 'Enable Video'; // Button reflects current state
                } catch (e) {
                    console.warn("Could not get local audio stream for answering call. Continuing without sending own media:", e);
                    callStatus.textContent = `Incoming call (no local media): ${e.message}`; 
                }

            }

            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                // Process any queued ICE candidates after setting remote description
                while (iceCandidatesQueue.length > 0) {
                    const candidate = iceCandidatesQueue.shift();
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                    } catch (e) {
                        console.error('Error adding queued ICE candidate:', e);
                    }
                }

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log('Sending SDP answer:', answer);
                sendWebRTCSignalingMessage('answer', answer, callTargetUserId, offer.callCode || null);

                callStatus.textContent = `Call established with ${callTargetUserId}.`;
                startCallButton.classList.add('hidden');
                answerCallButton.classList.add('hidden');
                endCallButton.classList.remove('hidden');
                endCallButton.disabled = false;
                toggleVideoButton.classList.remove('hidden'); 
                toggleAudioButton.classList.remove('hidden'); 
                toggleScreenShareButton.classList.remove('hidden');
                enlargeRemoteVideoButton.classList.remove('hidden'); // Show enlarge button
                updateAddFriendButtonVisibility(); // Update button visibility

            }
            catch (error) {
                console.error("Error handling offer:", error);
                callStatus.textContent = `Call failed: ${error.message}`;
                handleHangup();
            }
        }

        /**
         * Ends the current WebRTC call and cleans up resources.
         */
        function handleHangup() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (screenShareStream) { // Stop screen share stream if active
                screenShareStream.getTracks().forEach(track => track.stop());
                screenShareStream = null;
                isScreenSharing = false;
                toggleScreenShareButton.textContent = 'Share Screen';
            }
            if (remoteAudio.srcObject) {
                remoteAudio.srcObject.getTracks().forEach(track => track.stop());
                remoteAudio.srcObject = null;
            }
            if (remoteVideo.srcObject) { 
                remoteVideo.srcObject.getTracks().forEach(track => track.stop());
                remoteVideo.srcObject = null;
            }
            remoteAudio.classList.add('hidden');
            localVideo.classList.add('hidden'); 
            remoteVideo.classList.add('hidden'); 
            iceCandidatesQueue = []; 

            callTargetUserId = null;
            callStatus.textContent = "Call ended.";
            startCallButton.classList.remove('hidden');
            startCallButton.disabled = false;
            answerCallButton.classList.add('hidden');
            endCallButton.classList.add('hidden');
            toggleVideoButton.classList.add('hidden'); 
            toggleAudioButton.classList.add('hidden'); 
            toggleScreenShareButton.classList.add('hidden'); // Hide screen share toggle
            enlargeRemoteVideoButton.classList.add('hidden'); // Hide enlarge button
            updateAddFriendButtonVisibility(); // Ensure hidden on hangup

            toggleVideoButton.textContent = 'Enable Video'; // Reset button text
            toggleAudioButton.textContent = 'Mute Audio'; // Reset button text
            toggleScreenShareButton.textContent = 'Share Screen'; // Reset button text
            isLocalVideoEnabled = false; // Reset video enabled state
            isLocalAudioEnabled = true; // Reset audio enabled state (default to enabled)

            // Play disconnect sound
            disconnectSound.play().catch(e => console.warn("Disconnect sound play failed:", e));

            // If a generated code was active, delete it on hangup
            if (currentGeneratedCallCode) {
                deleteCallCode(currentGeneratedCallCode);
                generatedCallCodeDisplay.textContent = 'N/A';
                currentGeneratedCallCode = null;
            }
        }

        /**
         * Toggles the local video stream (on/off).
         */
        async function toggleLocalVideo() {
            if (!peerConnection) {
                console.warn("Cannot toggle video: Call not active.");
                callStatus.textContent = "Cannot toggle video: Call not active.";
                return;
            }

            if (isScreenSharing) {
                callStatus.textContent = "Cannot toggle camera video while screen sharing is active. Stop screen sharing first.";
                return;
            }

            let videoTrack = localStream ? localStream.getVideoTracks()[0] : null;

            if (isLocalVideoEnabled) { // If video is currently enabled, disable it
                if (videoTrack) {
                    videoTrack.enabled = false;
                    videoTrack.stop(); // Stop the track to release camera
                    localStream.removeTrack(videoTrack); // Remove from local stream
                    
                    const videoSender = peerConnection.getSenders().find(sender => sender.track && sender.track.kind === 'video');
                    if (videoSender) {
                        await videoSender.replaceTrack(null); // Stop sending video
                    }
                }
                localVideo.classList.add('hidden');
                toggleVideoButton.textContent = 'Enable Video';
                callStatus.textContent = 'Camera Video Off';
                isLocalVideoEnabled = false;
            } else { // If video is currently disabled, enable it
                try {
                    const newCameraStream = await navigator.mediaDevices.getUserMedia({ video: { width: 128, height: 128 } });
                    const newCameraVideoTrack = newCameraStream.getVideoTracks()[0];
                    
                    const videoSender = peerConnection.getSenders().find(sender => sender.track && sender.track.kind === 'video');

                    if (videoSender) {
                        await videoSender.replaceTrack(newCameraVideoTrack);
                    } else {
                        peerConnection.addTrack(newCameraVideoTrack, localStream);
                    }
                    
                    localStream.addTrack(newCameraVideoTrack); // Add to local stream object
                    localVideo.srcObject = new MediaStream([newCameraVideoTrack]); // Set srcObject to new stream
                    localVideo.classList.remove('hidden');
                    toggleVideoButton.textContent = 'Disable Video';
                    callStatus.textContent = 'Camera Video On';
                    isLocalVideoEnabled = true;

                } catch (error) {
                    console.error("Error enabling local video:", error);
                    callStatus.textContent = `Video error: ${error.message}`;
                    toggleVideoButton.textContent = 'Enable Video'; // Revert button state
                    localVideo.classList.add('hidden');
                    isLocalVideoEnabled = false;
                }
            }
        }

        /**
         * Toggles screen sharing.
         */
        async function toggleScreenShare() {
            if (!peerConnection) {
                callStatus.textContent = "Cannot share screen: Call not active.";
                return;
            }

            const videoSender = peerConnection.getSenders().find(sender => sender.track && sender.track.kind === 'video');

            if (isScreenSharing) {
                // Stop screen sharing
                if (screenShareStream) {
                    screenShareStream.getTracks().forEach(track => track.stop());
                    screenShareStream = null;
                }

                if (videoSender) {
                    // Try to revert to camera stream if it was previously enabled
                    if (isLocalVideoEnabled) {
                        try {
                            const cameraStream = await navigator.mediaDevices.getUserMedia({ video: { width: 128, height: 128 } });
                            const cameraVideoTrack = cameraStream.getVideoTracks()[0];
                            
                            await videoSender.replaceTrack(cameraVideoTrack);
                            
                            // Update localStream to reflect camera
                            localStream.getVideoTracks().forEach(track => track.stop()); // Stop old video tracks
                            localStream = new MediaStream([...localStream.getAudioTracks(), cameraVideoTrack]); // Create new stream with audio and camera video

                            localVideo.srcObject = localStream; // Show camera feed again
                            localVideo.classList.remove('hidden');
                            toggleVideoButton.textContent = 'Disable Video'; 
                            callStatus.textContent = 'Switched to camera.';

                        } catch (cameraError) {
                            console.warn("Could not revert to camera after stopping screen share:", cameraError);
                            // If no camera available or error, remove video track entirely
                            await videoSender.replaceTrack(null); // Stop sending video
                            localStream.getVideoTracks().forEach(track => track.stop()); // Stop local video track
                            localStream = new MediaStream(localStream.getAudioTracks()); // Only audio remains
                            localVideo.classList.add('hidden'); // Hide local video
                            toggleVideoButton.textContent = 'Enable Video'; 
                            callStatus.textContent = 'Screen sharing stopped. No camera available.';
                            isLocalVideoEnabled = false; // Camera is now off
                        }
                    } else { // If camera was off before screen share, just stop screen and keep camera off
                        await videoSender.replaceTrack(null);
                        localStream.getVideoTracks().forEach(track => track.stop());
                        localStream = new MediaStream(localStream.getAudioTracks()); // Only audio remains
                        localVideo.classList.add('hidden');
                        toggleVideoButton.textContent = 'Enable Video';
                        callStatus.textContent = 'Screen sharing stopped. Camera remains off.';
                    }
                }

                isScreenSharing = false;
                toggleScreenShareButton.textContent = 'Share Screen';
            } else {
                // Start screen sharing
                try {
                    const displayStream = await navigator.mediaDevices.getDisplayMedia({
                        video: {
                            cursor: "always",
                            width: { ideal: 1920, max: 1920 },
                            height: { ideal: 1080, max: 1080 },
                            frameRate: { ideal: 15, max: 20 },
                        },
                        audio: true // Request system audio from screen share
                    });

                    screenShareStream = displayStream;
                    isScreenSharing = true;

                    const screenVideoTrack = screenShareStream.getVideoTracks()[0];
                    const screenAudioTrack = screenShareStream.getAudioTracks()[0]; // Get audio track from display media

                    // Stop current local video track (if any, e.g., camera)
                    localStream.getVideoTracks().forEach(track => track.stop());
                    
                    if (videoSender) {
                        await videoSender.replaceTrack(screenVideoTrack);
                    } else {
                        peerConnection.addTrack(screenVideoTrack, localStream);
                    }
                    
                    // Add screen audio track to peer connection if available and no existing audio track from microphone
                    if (screenAudioTrack) {
                        const audioSender = peerConnection.getSenders().find(sender => sender.track && sender.track.kind === 'audio');
                        if (audioSender) {
                            await audioSender.replaceTrack(screenAudioTrack);
                        } else {
                            peerConnection.addTrack(screenAudioTrack, localStream);
                        }
                        // Stop microphone audio if system audio is being shared
                        localStream.getAudioTracks().forEach(track => {
                            if (track !== screenAudioTrack) track.stop();
                        });
                    }

                    // Update localStream object to reflect current tracks
                    localStream = new MediaStream([
                        ...localStream.getAudioTracks().filter(track => track === screenAudioTrack), // Keep screen audio if exists
                        screenVideoTrack
                    ]);


                    localVideo.srcObject = localStream; // Show screen share locally
                    localVideo.classList.remove('hidden');
                    toggleScreenShareButton.textContent = 'Stop Sharing';
                    callStatus.textContent = 'Screen sharing active.';
                    toggleVideoButton.textContent = 'Disable Video'; // Video is now "on" (screen share)
                    isLocalVideoEnabled = true; // Treat screen share as video being enabled


                    // Listen for 'ended' event on screen share track (e.g., user stops sharing from browser UI)
                    screenVideoTrack.onended = () => {
                        console.log('Screen share track ended. Stopping sharing.');
                        toggleScreenShare(); // Call toggle function to clean up
                    };

                } catch (error) {
                    console.error("Error starting screen share:", error);
                    callStatus.textContent = `Screen share failed: ${error.message}.`;
                    isScreenSharing = false;
                    toggleScreenShareButton.textContent = 'Share Screen';
                    // Revert local video display to camera if screen share fails and camera was active
                    if (isLocalVideoEnabled && localStream && localStream.getVideoTracks().length === 0) {
                        // Attempt to re-enable camera if it was on
                        await toggleLocalVideo(); // This will try to re-acquire camera
                    } else if (!isLocalVideoEnabled) {
                        // If camera was off, ensure local video is still hidden
                        localVideo.classList.add('hidden');
                    }
                }
            }
        }

        /**
         * Toggles the local audio stream (mute/unmute).
         */
        function toggleLocalAudio() {
            if (!localStream) {
                console.warn("Cannot toggle audio: No local stream.");
                callStatus.textContent = "Cannot toggle audio: No local stream.";
                return;
            }
            const audioTracks = localStream.getAudioTracks();
            if (audioTracks.length > 0) {
                audioTracks.forEach(track => {
                    track.enabled = !track.enabled;
                });
                isLocalAudioEnabled = audioTracks[0].enabled;
                toggleAudioButton.textContent = isLocalAudioEnabled ? 'Mute Audio' : 'Unmute Audio';
                console.log(`Local audio muted: ${!isLocalAudioEnabled}`);
                callStatus.textContent = isLocalAudioEnabled ? 'Audio Unmuted' : 'Audio Muted';
            } else {
                console.warn("No audio track found in local stream.");
                callStatus.textContent = "No audio track to mute/unmute.";
            }
        }

        /**
         * Toggles the remote video element into and out of fullscreen mode.
         */
        function toggleFullscreenRemoteVideo() {
            if (!remoteVideo.srcObject) {
                showModalMessage("No Remote Video", "There is no remote video feed to enlarge.");
                return;
            }

            fullscreenVideoModal.classList.remove('hidden');
            fullscreenVideo.srcObject = remoteVideo.srcObject;
            
            // Attempt to go fullscreen using the browser's Fullscreen API
            if (fullscreenVideo.requestFullscreen) {
                fullscreenVideo.requestFullscreen();
            } else if (fullscreenVideo.webkitRequestFullscreen) { /* Safari */
                fullscreenVideo.webkitRequestFullscreen();
            } else if (fullscreenVideo.msRequestFullscreen) { /* IE11 */
                fullscreenVideo.msRequestFullscreen();
            }

            fullscreenVideo.play().catch(e => console.error("Error playing fullscreen video:", e));
        }

        // Event listener for exiting fullscreen for the modal
        document.addEventListener('fullscreenchange', (event) => {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                // If exited fullscreen and the fullscreen modal is still open, close it
                if (!fullscreenVideoModal.classList.contains('hidden')) {
                    fullscreenVideoModal.classList.add('hidden');
                    fullscreenVideo.srcObject = null; // Clear stream
                }
            }
        });


        /**
         * Handles sending or updating a message.
         * @param {Event} e - The submit event from the message form.
         */
        async function sendMessage(e) {
            e.preventDefault(); // Prevent default form submission

            const messageText = newMessageInput.value.trim();

            // Basic validation for authentication and channel
            if (!currentUserId || !db || !currentChannelId) {
                if (!currentUserId) {
                    console.error("Cannot send message: User is not authenticated.");
                } else if (!currentChannelId) {
                    console.error("Cannot send message: No channel selected.");
                }
                return;
            }

            // Don't send empty messages unless there's an image, audio, or video
            if (messageText === '' && !currentImageFile && !currentAudioFile && !currentVideoFile) {
                console.warn("Cannot send empty message or without an image/audio/video.");
                return;
            }

            try {
                if (messageIdToEdit) {
                    // Update existing message
                    const messageDocRef = doc(db, `artifacts/${appId}/public/data/messages`, messageIdToEdit);
                    await updateDoc(messageDocRef, {
                        text: messageText,
                        // Media data cannot be updated for existing messages in this current logic
                    });
                    console.log("Message updated successfully:", messageIdToEdit);
                } else {
                    // Send a new message
                    let imageDataUrl = null;
                    let audioDataUrl = null;
                    let videoDataUrl = null; 
                    
                    // Show progress bar and disable send button during upload
                    uploadProgressBarContainer.classList.remove('hidden');
                    uploadProgressBar.style.width = '50%';
                    sendButton.disabled = true;

                    if (currentImageFile) {
                        // Read image file as Data URL
                        const reader = new FileReader();
                        imageDataUrl = await new Promise((resolve, reject) => {
                            reader.onload = () => resolve(reader.result);
                            reader.onerror = error => reject(error);
                            reader.readAsDataURL(currentImageFile);
                        });
                    } else if (currentAudioFile) {
                        // Read audio file as Data URL
                        const reader = new FileReader();
                        audioDataUrl = await new Promise((resolve, reject) => {
                            reader.onload = () => resolve(reader.result);
                            reader.onerror = error => reject(error);
                            reader.readAsDataURL(currentAudioFile);
                        });
                    } else if (currentVideoFile) { 
                        // Read video file as Data URL
                        const reader = new FileReader();
                        videoDataUrl = await new Promise((resolve, reject) => {
                            reader.onload = () => resolve(reader.result);
                            reader.onerror = error => reject(error);
                            reader.readAsDataURL(currentVideoFile);
                        });
                    }

                    uploadProgressBar.style.width = '100%';
                    
                    // Re-enable send button after media processing
                    sendButton.disabled = false;
                    uploadProgressBarContainer.classList.add('hidden');
                    uploadProgressBar.style.width = '0%';

                    // Construct the message object conditionally
                    const messageData = {
                        userId: currentUserId,
                        userName: currentUserName || 'Anonymous',
                        senderColor: currentColor,
                        text: messageText,
                        channelId: currentChannelId,
                        timestamp: serverTimestamp(), // Use server timestamp for consistency
                        type: 'chat' // Explicitly mark as a chat message
                    };

                    if (imageDataUrl) {
                        messageData.imageDataUrl = imageDataUrl;
                    }
                    if (audioDataUrl) {
                        messageData.audioDataUrl = audioDataUrl;
                        messageData.audioMimeType = currentAudioFile.type; 
                    }
                    if (videoDataUrl) { 
                        messageData.videoDataUrl = videoDataUrl;
                        messageData.videoMimeType = currentVideoFile.type;
                    }

                    await addDoc(collection(db, `artifacts/${appId}/public/data/messages`), messageData);
                    console.log("Message sent successfully.");
                }
                resetEditMode(); // Clear input and reset button text
                clearAllMediaSelections(); // Clear all media previews and inputs (including hiding audioRecordingStatus)
                currentAudioFile = null; // Ensure this is explicitly cleared as it can come from recording or upload
                currentVideoFile = null; // Ensure video file is cleared
            }
            catch (error) {
                console.error("Error sending/updating message or uploading media:", error);
                // Hide progress bar and re-enable send button on error
                uploadProgressBarContainer.classList.add('hidden');
                uploadProgressBar.style.width = '0%';
                sendButton.disabled = false;
            }
        }

        /**
         * Deletes a message from Firestore.
         * @param {Object} msgInfo - An object containing the ID of the message to delete.
         */
        async function performDeleteMessage(msgInfo) {
            if (!db || !msgInfo || !msgInfo.id) {
                console.error("Database or message ID not valid for deletion.");
                return;
            }

            try {
                const messageDocRef = doc(db, `artifacts/${appId}/public/data/messages`, msgInfo.id);
                await deleteDoc(messageDocRef);
                console.log("Message deleted successfully from Firestore:", msgInfo.id);
            } catch (error) {
                console.error("Error deleting message:", error);
                console.error("Failed to delete message. Please check console for details.");
            }
        }

        /**
         * Joins or creates a chat channel based on the input field.
         */
        function joinChannel() {
            const newChannel = channelInput.value.trim().toLowerCase().replace(/[^a-z0-9-]/g, ''); // Sanitize input
            if (!newChannel) {
                console.warn("Channel name cannot be empty or contain only special characters.");
                return;
            }

            // Only switch if the new channel is different from the current one
            if (newChannel && newChannel !== currentChannelId) {
                currentChannelId = newChannel;
                localStorage.setItem('wChatCurrentChannel', currentChannelId); // Save to local storage
                currentChannelDisplay.textContent = `Current: #${currentChannelId}`;
                if (db) {
                    setupMessageListener(); // Re-initialize message listener for the new channel
                } else {
                    console.warn("Firebase DB not initialized yet, cannot join channel immediately.");
                }
            } else if (newChannel === currentChannelId) {
                console.log("Already in this channel.");
            }
        }

        /**
         * Populates the public channels list in the sidebar.
         */
        function populateChannelList() {
            publicChannelList.innerHTML = ''; // Clear existing list items
            publicChannels.forEach(channel => {
                const listItem = document.createElement('li');
                const channelLink = document.createElement('a');
                channelLink.href = '#';
                // Apply the new combined class for default and theme-specific styling
                channelLink.className = 'public-channel-item';
                channelLink.textContent = `#${channel}`;
                channelLink.onclick = (e) => {
                    e.preventDefault();
                    channelInput.value = channel; // Set channel input value
                    joinChannel(); // Join the selected channel
                    // Close sidebar on mobile after selecting a channel
                    if (window.innerWidth < 768) {
                        sidebar.classList.remove('w-64');
                        sidebar.classList.add('w-0');
                        toggleIcon.classList.remove('rotate-180');
                    }
                };
                listItem.appendChild(channelLink);
                publicChannelList.appendChild(listItem);
            });
        }

        /**
         * Toggles the visibility of the sidebar.
         */
        function toggleSidebar() {
            const isExpanded = sidebar.classList.contains('w-64');

            if (isExpanded) {
                sidebar.classList.remove('w-64');
                sidebar.classList.add('w-0');
                toggleIcon.classList.remove('rotate-180');
            } else {
                sidebar.classList.remove('w-0');
                sidebar.classList.add('w-64');
                toggleIcon.classList.add('rotate-180');
            }
        }

        /**
         * Toggles the visibility of the channel control area (now inside sidebar).
         */
        function toggleChannelControl() {
            const isExpanded = !channelInputContent.classList.contains('max-h-0');

            if (isExpanded) {
                channelInputContent.classList.add('max-h-0');
                channelInputContent.classList.remove('max-h-full');
                channelToggleIcon.classList.remove('rotate-0');
                channelToggleIcon.classList.add('rotate-180');
            } else {
                channelInputContent.classList.remove('max-h-0');
                channelInputContent.classList.add('max-h-full');
                channelToggleIcon.classList.remove('rotate-180');
                channelToggleIcon.classList.add('rotate-0');
            }
        }

        /**
         * Toggles the visibility of the WebRTC controls area.
         */
        function toggleWebRTCControls() {
            const isHidden = webrtcMainPanel.classList.contains('hidden');

            if (isHidden) {
                webrtcMainPanel.classList.remove('hidden');
                webrtcToggleIcon.classList.remove('rotate-180');
                webrtcToggleIcon.classList.add('rotate-0');
            } else {
                webrtcMainPanel.classList.add('hidden');
                webrtcToggleIcon.classList.remove('rotate-0');
                webrtcToggleIcon.classList.add('rotate-180');
            }
        }

        /**
         * Toggles the visibility of the friends sidebar.
         */
        function toggleFriendsSidebar() {
            const isExpanded = friendsSidebar.classList.contains('w-64');

            if (isExpanded) {
                friendsSidebar.classList.remove('w-64');
                friendsSidebar.classList.add('w-0');
                friendsToggleIcon.classList.remove('rotate-0');
                friendsToggleIcon.classList.add('rotate-180'); // Arrow points right
            } else {
                friendsSidebar.classList.remove('w-0');
                friendsSidebar.classList.add('w-64');
                friendsToggleIcon.classList.remove('rotate-180');
                friendsToggleIcon.classList.add('rotate-0'); // Arrow points left
            }
        }

        /**
         * Opens the user settings modal.
         */
        function openUserSettingsModal() {
            userSettingsModal.classList.remove('hidden');
            userColorInput.value = currentColor; // Set current color
            themeSelect.value = localStorage.getItem('wChatTheme') || 'dark'; // Set current theme
        }

        /**
         * Closes the user settings modal.
         */
        function closeUserSettingsModal() {
            userSettingsModal.classList.add('hidden');
        }

        /**
         * Saves user settings (nickname color and app theme) to localStorage.
         */
        function saveUserSettings() {
            currentColor = userColorInput.value;
            localStorage.setItem('wChatUserColor', currentColor);

            currentTheme = themeSelect.value;
            localStorage.setItem('wChatTheme', currentTheme);
            applyTheme(currentTheme); // Apply the newly selected theme

            closeUserSettingsModal();
        }

        /**
         * Starts recording audio from the microphone.
         */
        async function startRecording() {
            try {
                // Request microphone access
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 12000, 
                        bitsPerSample: 8,  
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                // Set up MediaRecorder with desired mimeType
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' }); 

                audioChunks = [];
                mediaRecorder.ondataavailable = event => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm;codecs=opus' });
                    currentAudioFile = audioBlob; 
                    
                    console.log("Audio recording finished. Audio data ready for sending.");
                    audioRecordingStatus.classList.add('hidden'); 
                    isRecording = false;
                    recordButton.classList.remove('bg-gray-500', 'animate-pulse');
                    recordButton.classList.add('bg-red-500', 'hover:bg-red-600');
                    clearTimeout(recordingTimeout);
                    
                    // If no text, auto-send the audio
                    if (newMessageInput.value.trim() === '') {
                        sendMessage(new Event('submit'));
                    }
                };

                mediaRecorder.start();
                isRecording = true;
                audioRecordingStatus.classList.remove('hidden'); 
                
                recordButton.classList.remove('bg-red-500', 'hover:bg-red-600');
                recordButton.classList.add('bg-gray-500', 'animate-pulse');
                
                console.log("Recording started..."); 

                // Stop recording automatically after MAX_RECORDING_TIME_MS
                recordingTimeout = setTimeout(() => {
                    if (isRecording) {
                        stopRecording();
                        console.log("Recording stopped automatically after 1 minute.");
                        recordingMessage.textContent = "Recording stopped automatically (1 min limit).";
                    }
                }, MAX_RECORDING_TIME_MS);

            } catch (err) {
                console.error("Error accessing microphone:", err);
                // Use a modal for error messages instead of alert
                showModalMessage("Microphone Access Error", "Could not access microphone. Please ensure it's connected and permissions are granted.");
            }
        }

        /**
         * Displays a custom modal message.
         * @param {string} title - The title of the message.
         * @param {string} message - The message content.
         */
        function showModalMessage(title, message) {
            const modal = document.createElement('div');
            // Using a timestamp for the ID to ensure absolute uniqueness if multiple modals are ever shown concurrently
            modal.id = `customMessageModal-${Date.now()}`; 
            modal.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl text-center max-w-sm w-full relative">
                    <h2 class="text-2xl font-bold mb-4 text-gray-900 dark:text-gray-100">${title}</h2>
                    <p class="text-gray-700 dark:text-gray-300 mb-6">${message}</p>
                    <button id="closeMessageModalButton-${modal.id.split('-')[1]}" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300">
                        OK
                    </button>
                </div>
            `;
            document.body.appendChild(modal);

            // Get the button element using the `modal` as context immediately after appending
            // Use the dynamically generated ID for the button as well
            const closeButton = modal.querySelector(`#closeMessageModalButton-${modal.id.split('-')[1]}`);
            if (closeButton) {
                closeButton.addEventListener('click', () => {
                    console.log(`Closing modal with ID: ${modal.id}`); // Log for debugging
                    modal.remove(); // Remove the entire modal element from the DOM
                });
            } else {
                console.error("Error: closeMessageModalButton not found in dynamically created modal.");
            }
        }


        /**
         * Stops recording audio.
         */
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                // Stopping the stream tracks explicitly to turn off mic indicator
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
        }

        /**
         * Cancels the current recording and clears audio data.
         */
        function cancelRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.onstop = null; // Prevent onstop from firing final processing
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                audioChunks = [];
                currentAudioFile = null; // Clear recorded audio
                isRecording = false;
                audioRecordingStatus.classList.add('hidden');
                recordButton.classList.remove('bg-gray-500', 'animate-pulse');
                recordButton.classList.add('bg-red-500', 'hover:bg-red-600');
                clearTimeout(recordingTimeout);
                console.log("Recording cancelled.");
            }
        }

        /**
         * Attempts to scale down an image file to reduce its size.
         * @param {File} file - The image file to scale.
         * @returns {Promise<Blob>} A promise that resolves with the scaled image Blob.
         */
        async function scaleImage(file) {
            scaleImageButton.disabled = true;
            scaleImageButton.textContent = "Scaling...";
            sendButton.disabled = true;
            showFileSizeMessage("Scaling image...", false); // Indicate ongoing process

            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        const MAX_DIMENSION = 1920; // Max width or height for scaling down
                        let width = img.width;
                        let height = img.height;

                        // Calculate new dimensions while maintaining aspect ratio
                        if (width > height) {
                            if (width > MAX_DIMENSION) {
                                height *= MAX_DIMENSION / width;
                                width = MAX_DIMENSION;
                            }
                        } else {
                            if (height > MAX_DIMENSION) {
                                width *= MAX_DIMENSION / height;
                                height = MAX_DIMENSION;
                            }
                        }

                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);

                        let quality = 0.9; // Start with high quality for JPEG
                        let attempts = 0;
                        const maxAttempts = 9; // Max 9 decrements of 0.1 quality (from 0.9 down to 0.1)

                        const tryCompress = () => {
                            // Using image/jpeg for compression as it allows quality adjustment.
                            // If the original image is PNG, this will convert it to JPEG.
                            canvas.toBlob((blob) => {
                                if (!blob) { 
                                    reject(new Error("Failed to create blob from canvas."));
                                    return;
                                }
                                
                                // Target the Firestore document size limit for the final blob
                                if (blob.size <= FIRESTORE_MAX_DOC_SIZE || quality <= 0.1 || attempts >= maxAttempts) {
                                    resolve(blob);
                                    return;
                                }
                                quality -= 0.1;
                                attempts++;
                                tryCompress(); 
                            }, 'image/jpeg', quality);
                        };
                        
                        tryCompress(); 
                    };
                    img.onerror = () => {
                        reject("Failed to load image for scaling.");
                        showFileSizeMessage("Error: Failed to load image for scaling.", false); 
                    };
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    reject("Failed to read image file.");
                    showFileSizeMessage("Error: Failed to read image file.", false); 
                };
                reader.readAsDataURL(file);
            }).finally(() => {
                scaleImageButton.disabled = false;
                scaleImageButton.textContent = "Scale Down";
                if (currentImageFile && currentImageFile.size <= FIRESTORE_MAX_DOC_SIZE) {
                    sendButton.disabled = false; 
                } else {
                    sendButton.disabled = true; 
                }
            });
        }

        /**
         * Attempts to re-encode a video file to reduce its size, preserving audio.
         * Note: Client-side video compression is highly resource-intensive and limited.
         * Success for typical video sizes is NOT guaranteed due to the 1MB Firestore limit.
         * @param {File} videoFile - The video file to scale.
         * @returns {Promise<Blob>} A promise that resolves with the scaled video Blob.
         */
        async function scaleVideo(videoFile) {
            scaleVideoButton.disabled = true;
            scaleVideoButton.textContent = "Scaling...";
            sendButton.disabled = true;
            showFileSizeMessage("Scaling video with audio (this may take time and reduce quality significantly). Please be patient...", false);

            let videoElement = document.createElement('video');
            videoElement.preload = 'metadata';
            videoElement.muted = true; 
            videoElement.autoplay = false;

            let audioContext;
            let audioSource;
            let audioDestination;

            let canvas;
            let ctx;
            let videoStream;
            let audioStream;
            let combinedStream;
            let mediaRecorder;
            let animationFrameId;

            return new Promise((resolve, reject) => {
                videoElement.onloadedmetadata = async () => {
                    const videoDuration = videoElement.duration; 

                    // Define target sizes for different durations
                    const SHORTEST_VIDEO_DURATION_FOR_MAX_QUALITY_SECONDS = 5; 
                    const LONGEST_VIDEO_DURATION_FOR_FIXED_QUALITY_SECONDS = 60; 
                    const MAX_QUALITY_TARGET_SIZE_KB = 800; 
                    const BASE_QUALITY_TARGET_SIZE_KB = 200; 

                    let targetBlobSizeBytes;

                    if (videoDuration <= SHORTEST_VIDEO_DURATION_FOR_MAX_QUALITY_SECONDS) {
                        targetBlobSizeBytes = MAX_QUALITY_TARGET_SIZE_KB * 1024;
                    } else if (videoDuration >= LONGEST_VIDEO_DURATION_FOR_FIXED_QUALITY_SECONDS) {
                        targetBlobSizeBytes = BASE_QUALITY_TARGET_SIZE_KB * 1024;
                    } else {
                        // Linear interpolation for target size between max and base quality
                        
                        const ratio = (videoDuration - SHORTEST_VIDEO_DURATION_FOR_MAX_QUALITY_SECONDS) /
                                      (LONGEST_VIDEO_DURATION_FOR_FIXED_QUALITY_SECONDS - SHORTEST_VIDEO_DURATION_FOR_MAX_QUALITY_SECONDS); 
                        targetBlobSizeBytes = (MAX_QUALITY_TARGET_SIZE_KB - BASE_QUALITY_TARGET_SIZE_KB) * (1 - ratio) * 1024 + (BASE_QUALITY_TARGET_SIZE_KB * 1024);
                    }

                    // Ensure targetBlobSizeBytes does not exceed FIRESTORE_MAX_DOC_SIZE directly
                    targetBlobSizeBytes = Math.min(targetBlobSizeBytes, FIRESTORE_MAX_DOC_SIZE - 50 * 1024); 

                    // Calculate desired total bitrate based on target size and duration
                    let calculatedTotalBitrate = (targetBlobSizeBytes * 8) / videoDuration;

                    // Cap bitrate to avoid excessively high or low values
                    const MAX_BITRATE = 800000; 
                    const MIN_BITRATE = 50000;  

                    calculatedTotalBitrate = Math.max(MIN_BITRATE, Math.min(MAX_BITRATE, calculatedTotalBitrate));

                    // Distribute bitrate between video and audio. A common ratio is 80% video, 20% audio.
                    const videoBitrateRatio = 0.8;
                    const audioBitrateRatio = 0.2;

                    let TARGET_VIDEO_BITRATE = calculatedTotalBitrate * videoBitrateRatio;
                    let TARGET_AUDIO_BITRATE = calculatedTotalBitrate * audioBitrateRatio;

                    // Ensure minimum audio bitrate for intelligibility if it falls too low
                    const MIN_AUDIO_BITRATE = 24000; 
                    TARGET_AUDIO_BITRATE = Math.max(MIN_AUDIO_BITRATE, TARGET_AUDIO_BITRATE);

                    // Adjust video bitrate downwards if audio minimum pushed it too high
                    TARGET_VIDEO_BITRATE = Math.max(0, calculatedTotalBitrate - TARGET_AUDIO_BITRATE); 

                    const ACTUAL_TOTAL_BITRATE = TARGET_VIDEO_BITRATE + TARGET_AUDIO_BITRATE;


                    const originalAudioTrack = videoElement.captureStream().getAudioTracks()[0]; 

                    // Setup video canvas and stream
                    canvas = document.createElement('canvas');
                    ctx = canvas.getContext('2d');

                    const MAX_VIDEO_WIDTH = 320; 
                    const MAX_VIDEO_HEIGHT = 240;


                    let width = videoElement.videoWidth;
                    let height = videoElement.videoHeight;

                    // Downscale dimensions while maintaining aspect ratio
                    if (width > height) {
                        if (width > MAX_VIDEO_WIDTH) {
                            height *= MAX_VIDEO_WIDTH / width;
                            width = MAX_VIDEO_WIDTH;
                        }
                    } else {
                        if (height > MAX_VIDEO_HEIGHT) {
                            width *= MAX_VIDEO_HEIGHT / height;
                            height = MAX_VIDEO_HEIGHT;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;

                    try {
                        // Video stream from canvas
                        videoStream = canvas.captureStream(10); 
                        
                        // Audio stream from original video if available
                        if (originalAudioTrack) {
                            audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            audioSource = audioContext.createMediaStreamSource(new MediaStream([originalAudioTrack]));
                            audioDestination = audioContext.createMediaStreamDestination();
                            audioSource.connect(audioDestination);
                            audioStream = audioDestination.stream;
                        }

                        // Combine streams
                        combinedStream = new MediaStream();
                        if (videoStream.getVideoTracks().length > 0) {
                            combinedStream.addTrack(videoStream.getVideoTracks()[0]);
                        }
                        if (audioStream && audioStream.getAudioTracks().length > 0) {
                            combinedStream.addTrack(audioStream.getAudioTracks()[0]);
                        } else if (originalAudioTrack) { 
                            combinedStream.addTrack(originalAudioTrack);
                        }


                        if (combinedStream.getTracks().length === 0) {
                             throw new Error("No media tracks available for recording after combining streams.");
                        }

                        mediaRecorder = new MediaRecorder(combinedStream, {
                            mimeType: 'video/webm;codecs=vp8,opus', 
                            bitsPerSecond: ACTUAL_TOTAL_BITRATE 
                        });

                    } catch (e) {
                        console.error("MediaRecorder video init error:", e);
                        reject(new Error(`Failed to initialize video recorder: ${e.message}. Ensure your browser supports MediaRecorder for canvas streams with webm/vp8 and opus codecs.`));
                        return;
                    }
                    
                    let videoChunks = [];
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            videoChunks.push(event.data);
                        }
                    };

                    const drawFrame = () => {
                        if (videoElement.paused || videoElement.ended) {
                            cancelAnimationFrame(animationFrameId);
                            return;
                        }
                        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                        animationFrameId = requestAnimationFrame(drawFrame);
                    };

                    mediaRecorder.onstop = () => {
                        const scaledBlob = new Blob(videoChunks, { type: 'video/webm' });
                        
                        // Clean up all resources
                        videoElement.pause();
                        videoElement.removeAttribute('src');
                        videoElement.load();
                        if (videoElement.src && videoElement.src.startsWith('blob:')) URL.revokeObjectURL(videoElement.src);
                        if (videoStream) videoStream.getTracks().forEach(track => track.stop());
                        if (audioStream) audioStream.getTracks().forEach(track => track.stop());
                        if (combinedStream) combinedStream.getTracks().forEach(track => track.stop());
                        if (audioSource) audioSource.disconnect();
                        if (audioDestination) audioDestination.disconnect();
                        if (audioContext) audioContext.close();
                        cancelAnimationFrame(animationFrameId);

                        if (scaledBlob.size <= FIRESTORE_MAX_DOC_SIZE) {
                            resolve(scaledBlob);
                        } else {
                            reject(new Error(`Scaled video is still too large (${(scaledBlob.size / 1024).toFixed(2)} KB). Target: ${(FIRESTORE_MAX_DOC_SIZE / 1024).toFixed(2)} KB. Please try a much shorter or lower quality video.`));
                        }
                    };

                    mediaRecorder.onerror = (event) => {
                        const error = event.error;
                        console.error("MediaRecorder video error:", error);
                        reject(new Error(`Video recording error: ${error.message}.`));
                        // Ensure cleanup on error as well
                        videoElement.pause();
                        if (videoElement.src && videoElement.src.startsWith('blob:')) URL.revokeObjectURL(videoElement.src);
                        if (videoStream) videoStream.getTracks().forEach(track => track.stop());
                        if (audioStream) audioStream.getTracks().forEach(track => track.stop());
                        if (combinedStream) combinedStream.getTracks().forEach(track => track.stop());
                        if (audioSource) audioSource.disconnect();
                        if (audioDestination) audioDestination.disconnect();
                        if (audioContext) audioContext.close();
                        cancelAnimationFrame(animationFrameId);
                    };

                    videoElement.play().then(() => {
                        mediaRecorder.start();
                        drawFrame(); 
                        // Stop recording after video duration plus a small buffer
                        setTimeout(() => {
                            if (mediaRecorder.state === 'recording') {
                                mediaRecorder.stop();
                            }
                        }, videoDuration * 1000 + 500); 
                    }).catch(err => {
                        console.error("Video playback error for scaling:", err);
                        reject(new Error(`Video playback error: ${err.message}. Ensure the video file is not corrupted.`));
                    });
                };

                videoElement.onerror = (e) => {
                    console.error("Error loading video for scaling:", e);
                    reject(new Error("Failed to load video for scaling. Check video file integrity or format compatibility."));
                };

                videoElement.src = URL.createObjectURL(videoFile);
            }).finally(() => {
                scaleVideoButton.disabled = false;
                scaleVideoButton.textContent = "Scale Down";
                if (currentVideoFile && currentVideoFile.size <= FIRESTORE_MAX_DOC_SIZE) {
                         sendButton.disabled = false;
                } else {
                    sendButton.disabled = true;
                }
            });
        }


        // --- Friends List Functions ---

        /**
         * Sets up a real-time listener for the current user's friends list.
         */
        function setupFriendsListener() {
            if (friendsListenerUnsubscribe) {
                friendsListenerUnsubscribe(); // Unsubscribe from previous listener
            }

            if (!db || !currentUserId) {
                console.warn("Firestore or currentUserId not ready for friends listener.");
                return;
            }

            const q = query(
                collection(db, `artifacts/${appId}/users/${currentUserId}/friends`),
                orderBy('addedTimestamp')
            );

            friendsListenerUnsubscribe = onSnapshot(q, (snapshot) => {
                currentFriends = {}; // Clear existing friends
                friendsList.innerHTML = ''; // Clear UI list
                let hasFriends = false;
                snapshot.forEach((doc) => {
                    // Skip the placeholder document when rendering the list
                    if (doc.id === 'FriendsHere') {
                        return;
                    }
                    const friendData = doc.data();
                    currentFriends[doc.id] = { ...friendData, id: doc.id };
                    friendsList.appendChild(createFriendListItem(currentFriends[doc.id]));
                    hasFriends = true;
                });

                // If after filtering, the list is empty, show the "No friends yet" message
                if (!hasFriends) {
                    const listItem = document.createElement('li');
                    listItem.className = "text-gray-600 dark:text-gray-400 text-sm";
                    listItem.textContent = "No friends yet. Add someone from a call!";
                    friendsList.appendChild(listItem);
                }
                // Call the unified visibility function after friends are loaded
                updateAddFriendButtonVisibility(); 
            }, (error) => {
                console.error("Error fetching friends list:", error);
                friendsList.innerHTML = `<li class="text-red-500 dark:text-red-400 text-sm">Error loading friends: ${error.message}</li>`;
            });
        }

        /**
         * Creates an HTML list item for a friend.
         * @param {Object} friend - The friend object from Firestore.
         * @returns {HTMLElement} The created list item.
         */
        function createFriendListItem(friend) {
            const listItem = document.createElement('li');
            listItem.className = "flex flex-col p-2 bg-gray-100 dark:bg-gray-700 rounded-lg shadow-sm";
            listItem.setAttribute('data-friend-id', friend.id); // Store friend ID on the element

            const friendInfoDiv = document.createElement('div');
            friendInfoDiv.className = "flex justify-between items-center mb-1";

            const friendDisplaySpan = document.createElement('span'); // Use one span for combined display
            // Added flex-1, min-w-0, pr-2, and truncate for better handling of long IDs/nicknames
            friendDisplaySpan.className = "font-semibold text-gray-800 dark:text-gray-100 flex-1 min-w-0 pr-2 truncate";
            
            // Display nickname (if set) and ID, or just ID if no nickname
            if (friend.nickname && friend.nickname.trim() !== '') {
                friendDisplaySpan.textContent = `${friend.nickname} (${friend.id})`;
            } else {
                friendDisplaySpan.textContent = friend.id;
            }

            const buttonsDiv = document.createElement('div');
            buttonsDiv.className = "flex space-x-2";

            const callButton = document.createElement('button');
            callButton.className = "text-blue-500 hover:text-blue-700 transition-colors"
            callButton.innerHTML = `<i class="fas fa-phone-alt"></i>`;
            callButton.title = `Call ${friend.nickname || friend.id}`;
            callButton.onclick = () => {
                targetUserIdInput.value = friend.id; // Pre-fill target ID
                startCall(); // Initiate call
            };

            const detailsButton = document.createElement('button'); // Renamed from noteButton
            detailsButton.className = "text-green-500 hover:text-green-700 transition-colors"
            detailsButton.innerHTML = `<i class="fas fa-user-edit"></i>`; // Changed icon for general details
            detailsButton.title = `Edit Details for ${friend.nickname || friend.id}`;
            detailsButton.onclick = () => openFriendDetailsModal(friend.id); // Open new details modal

            const removeButton = document.createElement('button');
            removeButton.className = "text-red-500 hover:text-red-700 transition-colors"
            removeButton.innerHTML = `<i class="fas fa-user-minus"></i>`;
            removeButton.title = `Remove ${friend.nickname || friend.id}`;
            removeButton.onclick = () => removeFriend(friend.id);

            friendInfoDiv.appendChild(friendDisplaySpan); // Append the single display span
            buttonsDiv.appendChild(callButton);
            buttonsDiv.appendChild(detailsButton); // Append the new details button
            buttonsDiv.appendChild(removeButton);

            friendInfoDiv.appendChild(buttonsDiv);
            listItem.appendChild(friendInfoDiv);

            if (friend.note && friend.note.trim() !== '') { // Only show note if it's not empty
                const noteP = document.createElement('p');
                noteP.className = "text-xs text-gray-700 dark:text-gray-300 italic mt-1";
                noteP.textContent = `Note: ${friend.note}`;
                listItem.appendChild(noteP);
            }

            return listItem;
        }

        /**
         * Adds a user to the current user's friends list.
         * @param {string} friendId - The user ID of the friend to add.
         */
        async function addFriend(friendId) { // Removed nickname parameter here
            if (!db || !currentUserId) {
                console.error("Cannot add friend: DB or user ID not available.");
                return;
            }
            if (friendId === currentUserId) {
                showModalMessage("Add Friend Error", "You cannot add yourself as a friend.");
                return;
            }
            if (currentFriends[friendId]) {
                showModalMessage("Add Friend Info", `${friendId} is already in your friends list!`);
                return;
            }

            try {
                // Initialize nickname as an empty string, so it defaults to displaying the ID
                // The user can then set a custom nickname via the details modal.
                await setDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/friends`, friendId), {
                    userId: friendId,
                    nickname: '', // Initialize as empty string
                    note: '', // Initialize with an empty note
                    addedTimestamp: serverTimestamp()
                });
                console.log(`Friend ${friendId} added.`);
                showModalMessage("Friend Added!", `${friendId} has been added to your friends list.`);
                updateAddFriendButtonVisibility(); // Update button visibility after adding friend
            }
            catch (error) {
                console.error("Error adding friend:", error);
                showModalMessage("Add Friend Error", `Failed to add friend: ${error.message}`);
            }
        }

        /**
         * Removes a friend from the current user's friends list.
         * @param {string} friendId - The user ID of the friend to remove.
         */
        async function removeFriend(friendId) {
            if (!db || !currentUserId) {
                console.error("Cannot remove friend: DB or user ID not available.");
                return;
            }

            const friend = currentFriends[friendId];
            const friendDisplayName = friend ? (friend.nickname || friend.id) : friendId;

            // Optional: Add a confirmation dialog before deleting
            const confirmRemove = confirm(`Are you sure you want to remove ${friendDisplayName} from your friends list?`);
            if (!confirmRemove) {
                return;
            }

            try {
                await deleteDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/friends`, friendId));
                console.log(`Friend ${friendId} removed.`);
                showModalMessage("Friend Removed", `${friendDisplayName} has been removed from your friends list.`);
                delete currentFriends[friendId]; // Remove from local cache
                updateAddFriendButtonVisibility(); // Update button visibility after removing friend
                // The onSnapshot listener will automatically update the UI
            } catch (error) {
                console.error("Error removing friend:", error);
                showModalMessage("Remove Friend Error", `Failed to remove friend: ${error.message}`);
            }
        }

        /**
         * Opens the modal to set/edit details (nickname and note) for a friend.
         * @param {string} friendId - The user ID of the friend.
         */
        function openFriendDetailsModal(friendId) { // Renamed from openFriendNoteModal
            currentFriendIdForDetails = friendId;
            const friend = currentFriends[friendId];
            if (friend) {
                friendDetailsTargetId.textContent = `ID: ${friend.id}`; // Display the friend's actual ID
                friendNicknameInput.value = friend.nickname || ''; // Populate nickname
                friendNoteInput.value = friend.note || ''; // Populate note
                friendDetailsModal.classList.remove('hidden');
            } else {
                console.error(`Friend with ID ${friendId} not found.`);
                showModalMessage("Error", "Friend not found for setting details.");
            }
        }

        /**
         * Closes the friend details modal.
         */
        function closeFriendDetailsModal() { // Renamed from closeFriendNoteModal
            friendDetailsModal.classList.add('hidden');
            currentFriendIdForDetails = null;
            friendNicknameInput.value = ''; // Clear nickname input
            friendNoteInput.value = ''; // Clear note input
        }

        /**
         * Saves the nickname and note for the current friend being edited.
         */
        async function saveFriendDetails() { // Renamed from saveFriendNote
            if (!db || !currentUserId || !currentFriendIdForDetails) {
                console.error("Cannot save details: DB, user ID, or friend ID not available.");
                return;
            }
            const newNickname = friendNicknameInput.value.trim();
            const newNote = friendNoteInput.value.trim();

            try {
                await updateDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/friends`, currentFriendIdForDetails), {
                    nickname: newNickname,
                    note: newNote
                });
                console.log(`Details for friend ${currentFriendIdForDetails} saved.`);
                showModalMessage("Details Saved", "Friend details saved successfully!");
                closeFriendDetailsModal();
            } catch (error) {
                console.error("Error saving friend details:", error);
                showModalMessage("Save Details Error", `Failed to save details: ${error.message}`);
            }
        }

        /**
         * Resolves a 4-digit call code to a user ID and adds that user to the friends list.
         */
        async function addFriendByCallCode() {
            const code = friendCodeInput.value.trim();
            if (code.length !== 4) {
                showModalMessage("Invalid Code", "Please enter a valid 4-digit code.");
                return;
            }

            if (!db || !currentUserId) {
                showModalMessage("Authentication Error", "You must be authenticated to add friends. Please wait for authentication.");
                console.error("Firestore or currentUserId not ready for addFriendByCallCode.");
                return;
            }

            addFriendByCodeButton.disabled = true;
            addFriendByCodeButton.textContent = "Adding...";

            try {
                const q = query(collection(db, `artifacts/${appId}/public/data/call_codes`), where('code', '==', code));
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    showModalMessage("Code Not Found", `The code "${code}" is not active or does not exist.`);
                    return;
                }

                const codeDoc = querySnapshot.docs[0].data();
                const targetFriendId = codeDoc.userId;

                if (targetFriendId === currentUserId) {
                    showModalMessage("Add Friend Error", "You cannot add yourself as a friend.");
                    return;
                }

                if (currentFriends[targetFriendId]) {
                    showModalMessage("Already Friends", `User ${targetFriendId} is already in your friends list!`);
                    return;
                }

                // Add the friend (nickname will be empty initially)
                await addFriend(targetFriendId); 

                showModalMessage("Friend Added!", `User ${targetFriendId} has been added to your friends list.`);
                friendCodeInput.value = ''; // Clear input

            } catch (error) {
                console.error("Error adding friend by call code:", error);
                showModalMessage("Error", `Failed to add friend by code: ${error.message}`);
            } finally {
                addFriendByCodeButton.disabled = false;
                addFriendByCodeButton.textContent = "Add Friend";
            }
        }

        /**
         * Updates the visibility of the Add Friend button based on call state and friend list.
         */
        function updateAddFriendButtonVisibility() {
            if (callTargetUserId && currentUserId && callTargetUserId !== currentUserId && !currentFriends[callTargetUserId]) {
                addFriendFromCallButton.classList.remove('hidden');
            } else {
                addFriendFromCallButton.classList.add('hidden');
            }
        }

        /**
         * Toggles the visibility of the "Add Friend by Code" panel.
         */
        function toggleAddFriendByCodePanel() {
            const isExpanded = !addFriendByCodeContent.classList.contains('max-h-0');

            if (isExpanded) {
                addFriendByCodeContent.classList.add('max-h-0');
                addFriendByCodeContent.classList.remove('max-h-full');
                addFriendByCodeToggleIcon.classList.remove('rotate-0');
                addFriendByCodeToggleIcon.classList.add('rotate-180');
            } else {
                addFriendByCodeContent.classList.remove('max-h-0');
                addFriendByCodeContent.classList.add('max-h-full');
                addFriendByCodeToggleIcon.classList.remove('rotate-180');
                addFriendByCodeToggleIcon.classList.add('rotate-0');
            }
        }

        // --- Event Listeners ---

        // Update nickname in localStorage on input
        nicknameInput.addEventListener('input', (e) => {
            currentUserName = e.target.value;
            localStorage.setItem('wChatUserName', currentUserName);
        });

        // Change send button text if message is being edited
        newMessageInput.addEventListener('input', () => {
            if (messageIdToEdit && newMessageInput.value.trim() !== originalMessageText) {
                 sendButtonText.textContent = 'Save Edits';
            } else if (!messageIdToEdit && newMessageInput.value.trim() === '') {
                sendButtonText.textContent = 'Send';
            }
            // If user types, clear any active media states, including hiding recording status
            if (newMessageInput.value.trim() !== '') {
                clearAllMediaSelections(); 
                if (isRecording) { 
                    cancelRecording();
                }
            }
        });

        // Handle message form submission
        messageForm.addEventListener('submit', sendMessage);

        // Join channel on button click
        joinChannelButton.addEventListener('click', joinChannel);

        // Join channel on Enter key press in channel input
        channelInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); 
                joinChannel();
            }
        });

        // Toggle sidebar visibility
        sidebarToggle.addEventListener('click', toggleSidebar);
        // Toggle channel control area visibility
        channelToggleButton.addEventListener('click', toggleChannelControl); // Now for the sidebar internal toggle
        // Toggle WebRTC control area visibility
        webrtcToggleButton.addEventListener('click', toggleWebRTCControls);
        // Toggle Friends sidebar visibility
        friendsToggleButton.addEventListener('click', toggleFriendsSidebar);

        // Confirmation modal for message deletion
        confirmDeleteYes.addEventListener('click', () => {
            if (messageIdToDelete) {
                performDeleteMessage(messageIdToDelete);
                messageIdToDelete = null;
            }
            confirmationModal.classList.add('hidden');
        });

        confirmDeleteNo.addEventListener('click', () => {
            messageIdToDelete = null;
            confirmationModal.classList.add('hidden');
        });

        // Unified File Attachment functionality
        attachFileButton.addEventListener('click', () => {
            fileInput.click(); 
            clearAllMediaSelections(); 
            if (isRecording) { 
                cancelRecording();
            }
        });

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) {
                clearAllMediaSelections();
                return;
            }

            // Clear all media states first, as a new file is being selected, and hide recording status
            clearAllMediaSelections();
            if (isRecording) { 
                cancelRecording();
            }
            resetEditMode(); 
            hideFileSizeMessage(); 

            if (file.type.startsWith('image/')) {
                // Display the image immediately
                if (imagePreview.src && imagePreview.src.startsWith('blob:')) {
                    URL.revokeObjectURL(imagePreview.src);
                }
                imagePreview.src = URL.createObjectURL(file);
                imageFileName.textContent = file.name;
                imagePreviewContainer.classList.remove('hidden');

                // Check size against MAX_RAW_FILE_SIZE_BEFORE_ENCODING
                if (file.size > MAX_RAW_FILE_SIZE_BEFORE_ENCODING) {
                    currentImageFile = file; 
                    showFileSizeMessage(`Image file is too large (${(file.size / 1024).toFixed(2)} KB). Max raw size is ${(MAX_RAW_FILE_SIZE_BEFORE_ENCODING / 1024).toFixed(2)} KB to fit Firestore's 1MB document limit after Base64 encoding.`, false);
                    scaleImageButton.classList.remove('hidden');
                    sendButton.disabled = true; 
                } else {
                    currentImageFile = file; 
                    sendButton.disabled = false;
                }
            } else if (file.type.startsWith('audio/')) {
                const validAudioTypes = ['audio/mpeg', 'audio/ogg', 'audio/webm'];
                if (!validAudioTypes.includes(file.type)) {
                    showFileSizeMessage("Invalid audio file type. Please upload MP3, Ogg/Opus, or WebM audio files.", false);
                    sendButton.disabled = true; 
                    return;
                }
                currentAudioFile = file; 
                audioFileName.textContent = file.name;
                if (audioUploadPreview.src && audioUploadPreview.src.startsWith('blob:')) {
                    URL.revokeObjectURL(audioUploadPreview.src);
                }
                audioUploadPreview.src = URL.createObjectURL(file);
                audioUploadPreviewContainer.classList.remove('hidden');

                // Check size against FIRESTORE_MAX_DOC_SIZE (no scaling, so check final size)
                if (file.size > FIRESTORE_MAX_DOC_SIZE) { 
                    showFileSizeMessage(`Audio file is too large (${(file.size / 1024).toFixed(2)} KB). Max direct upload size for audio is ${(FIRESTORE_MAX_DOC_SIZE / 1024).toFixed(2)} KB. Please try a smaller file.`, false);
                    sendButton.disabled = true; 
                } else {
                    sendButton.disabled = false; 
                }
            } else if (file.type.startsWith('video/')) { 
                const validVideoTypes = ['video/mp4', 'video/webm']; 
                if (!validVideoTypes.includes(file.type)) {
                    showFileSizeMessage("Invalid video file type. Please upload MP4 or WebM video files.", false);
                    sendButton.disabled = true;
                    return;
                }
                currentVideoFile = file;
                videoFileName.textContent = file.name;
                if (videoUploadPreview.src && videoUploadPreview.src.startsWith('blob:')) {
                    URL.revokeObjectURL(videoUploadPreview.src);
                }
                videoUploadPreview.src = URL.createObjectURL(file);
                videoUploadPreviewContainer.classList.remove('hidden');

                // Videos are almost certainly too large initially. Always show scale button.
                if (file.size > MAX_RAW_FILE_SIZE_BEFORE_ENCODING) { 
                    showFileSizeMessage(`Video file is very large (${(file.size / 1024).toFixed(2)} KB). Max direct upload size for video is ${(MAX_RAW_FILE_SIZE_BEFORE_ENCODING / 1024).toFixed(2)} KB to fit Firestore's 1MB document limit after Base64 encoding. Scaling is recommended.`, false);
                    scaleVideoButton.classList.remove('hidden');
                    sendButton.disabled = true; 
                } else {
                    showFileSizeMessage(`Video file size: ${(file.size / 1024).toFixed(2)} KB. Attempting to upload directly. Note: Base64 encoding will increase its size.`, true);
                    sendButton.disabled = false; 
                }
            }
            else {
                showFileSizeMessage("Unsupported file type. Please upload an image, audio, or video file.", false);
                sendButton.disabled = true; 
                return;
            }
        });

        // Handle image scaling attempt
        scaleImageButton.addEventListener('click', async () => {
            if (currentImageFile) {
                try {
                    const scaledBlob = await scaleImage(currentImageFile);
                    if (scaledBlob.size <= FIRESTORE_MAX_DOC_SIZE) { 
                        if (imagePreview.src && imagePreview.src.startsWith('blob:')) {
                            URL.revokeObjectURL(imagePreview.src);
                        }
                        currentImageFile = scaledBlob; 
                        imagePreview.src = URL.createObjectURL(scaledBlob); 
                        imageFileName.textContent = `Scaled: ${currentImageFile.name || 'image'} (${(currentImageFile.size / 1024).toFixed(2)} KB)`;
                        showFileSizeMessage("Image scaled successfully! Ready to send.", true);
                        scaleImageButton.classList.add('hidden'); 
                        sendButton.disabled = false; 
                    } else {
                        // Even after scaling, still too big
                        showFileSizeMessage(`Failed to scale image below ${(FIRESTORE_MAX_DOC_SIZE / 1024).toFixed(2)} KB. Current size: ${(scaledBlob.size / 1024).toFixed(2)} KB. Please choose a different image or try scaling again.`, false);
                    }
                } catch (error) {
                    console.error("Image scaling failed:", error);
                    showFileSizeMessage(`Image scaling failed: ${error.message || 'Unknown error'}. Please choose a different image.`, false);
                } finally {
                    scaleImageButton.disabled = false;
                    scaleImageButton.textContent = "Scale Down";
                    if (currentImageFile && currentImageFile.size <= FIRESTORE_MAX_DOC_SIZE) {
                         sendButton.disabled = false;
                    } else {
                        sendButton.disabled = true;
                    }
                }
            }
        });

        // Handle video scaling attempt
        scaleVideoButton.addEventListener('click', async () => {
            if (currentVideoFile) {
                try {
                    const scaledBlob = await scaleVideo(currentVideoFile);
                    if (scaledBlob.size <= FIRESTORE_MAX_DOC_SIZE) {
                        if (videoUploadPreview.src && videoUploadPreview.src.startsWith('blob:')) {
                            URL.revokeObjectURL(videoUploadPreview.src);
                        }
                        currentVideoFile = scaledBlob;
                        videoUploadPreview.src = URL.createObjectURL(scaledBlob);
                        videoFileName.textContent = `Scaled: ${currentVideoFile.name || 'video'} (${(currentVideoFile.size / 1024).toFixed(2)} KB)`;
                        showFileSizeMessage("Video scaled successfully! Ready to send.", true);
                        scaleVideoButton.classList.add('hidden');
                        sendButton.disabled = false;
                    } else {
                        showFileSizeMessage(`Failed to scale video below ${(FIRESTORE_MAX_DOC_SIZE / 1024).toFixed(2)} KB. Current size: ${(scaledBlob.size / 1024).toFixed(2)} KB. Please try a much shorter or lower quality video.`
                        , false);
                    }
                } catch (error) {
                    console.error("Video scaling failed:", error);
                    showModalMessage(`Video scaling failed: ${error.message || 'Unknown error'}. This feature has extreme limitations due to file size.`, false);
                } finally {
                    scaleVideoButton.disabled = false;
                    scaleVideoButton.textContent = "Scale Down";
                    if (currentVideoFile && currentVideoFile.size <= FIRESTORE_MAX_DOC_SIZE) {
                         sendButton.disabled = false;
                    } else {
                        sendButton.disabled = true;
                    }
                }
            }
        });


        cancelImageButton.addEventListener('click', clearAllMediaSelections);
        cancelAudioUploadButton.addEventListener('click', clearAllMediaSelections);
        cancelVideoButton.addEventListener('click', clearAllMediaSelections); 


        // User settings modal functionality
        userSettingsButton.addEventListener('click', openUserSettingsModal);
        closeSettingsModalButton.addEventListener('click', closeUserSettingsModal);
        saveUserSettingsButton.addEventListener('click', saveUserSettings);

        // Voice Recording Event Listeners
        recordButton.addEventListener('click', () => {
            clearAllMediaSelections(); 
            newMessageInput.value = ''; 

            if (isRecording) {
                stopRecording(); 
            } else {
                startRecording(); 
            }
        });
        cancelRecordingButton.addEventListener('click', cancelRecording);

        // WebRTC Call Button Listeners
        startCallButton.addEventListener('click', startCall);
        answerCallButton.addEventListener('click', async () => {
            if (peerConnection && peerConnection.remoteDescription) {
                try {
                    // Ensure localStream has audio (and video if user toggled it on) before answering
                    if (!localStream) { // Only get stream if not already available
                        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: isLocalVideoEnabled }); 
                        if (!localStream) {
                             throw new Error("Failed to get local stream for answering call. Microphone/Camera access denied or not available.");
                        }
                    }
                    
                    // Add tracks to peerConnection if they are not already there
                    localStream.getTracks().forEach(track => { 
                        // Check if sender for this track kind already exists
                        const existingSender = peerConnection.getSenders().find(s => s.track && s.track.kind === track.kind);
                        if (!existingSender) {
                            peerConnection.addTrack(track, localStream);
                        }
                    });
                    
                    if (isLocalVideoEnabled) {
                        localVideo.srcObject = localStream;
                        localVideo.classList.remove('hidden');
                    } else {
                        localVideo.classList.add('hidden');
                    }

                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    sendWebRTCSignalingMessage('answer', answer, callTargetUserId);
                    callStatus.textContent = `Call established with ${callTargetUserId}.`;
                    connectSound.play().catch(e => console.warn("Connect sound play failed:", e)); 
                    startCallButton.classList.add('hidden');
                    answerCallButton.classList.add('hidden');
                    endCallButton.classList.remove('hidden');
                    endCallButton.disabled = false;
                    toggleVideoButton.classList.remove('hidden'); 
                    toggleAudioButton.classList.remove('hidden'); 
                    toggleScreenShareButton.classList.remove('hidden'); 
                    enlargeRemoteVideoButton.classList.remove('hidden');
                    updateAddFriendButtonVisibility(); 

                } catch (e) {
                    console.error("Error creating/sending answer on explicit click:", e);
                    callStatus.textContent = `Error answering call: ${e.message}`;
                    handleHangup();
                }
            } else {
                callStatus.textContent = "No pending call to answer or peer connection not ready.";
            }
        });
        endCallButton.addEventListener('click', () => {
            sendWebRTCSignalingMessage('hangup', {}, callTargetUserId); 
            handleHangup();
            callStatus.textContent = "You ended the call.";
        });

        // New: Video and Audio toggle buttons
        toggleVideoButton.addEventListener('click', toggleLocalVideo);
        toggleAudioButton.addEventListener('click', toggleLocalAudio);
        toggleScreenShareButton.addEventListener('click', toggleScreenShare); 
        generateCallCodeButton.addEventListener('click', generateFourDigitCode); 

        // New: Add friend from call button
        addFriendFromCallButton.addEventListener('click', () => {
            if (callTargetUserId) {
                // Add friend without initial nickname, it will default to empty string
                addFriend(callTargetUserId); 
            } else {
                showModalMessage("Error", "No active call to add a friend from.");
            }
        });

        // Friend Details Modal Listeners (formerly Friend Note Modal)
        closeFriendDetailsModalButton.addEventListener('click', closeFriendDetailsModal);
        saveFriendDetailsButton.addEventListener('click', saveFriendDetails);

        // New "Add Friend by Code" listeners
        addFriendByCodeToggleButton.addEventListener('click', toggleAddFriendByCodePanel);
        addFriendByCodeButton.addEventListener('click', addFriendByCallCode);
        friendCodeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addFriendByCallCode();
            }
        });

        // Fullscreen Video Modal Listeners
        enlargeRemoteVideoButton.addEventListener('click', toggleFullscreenRemoteVideo);
        closeFullscreenVideoButton.addEventListener('click', () => {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            }
            fullscreenVideoModal.classList.add('hidden');
            fullscreenVideo.srcObject = null;
        });

        // --- Initial Load Logic ---
        window.onload = () => {
            initializeFirebase(); // Initialize Firebase when the window loads
            populateChannelList(); // Populate the public channel list

            // Adjust sidebar visibility based on screen width on load
            if (window.innerWidth >= 768) {
                sidebar.classList.add('w-64');
                sidebar.classList.remove('w-0');
                toggleIcon.classList.remove('rotate-0'); 
                toggleIcon.classList.add('rotate-180');
            } else {
                sidebar.classList.remove('w-64');
                sidebar.classList.add('w-0');
                toggleIcon.classList.remove('rotate-180'); 
                toggleIcon.classList.add('rotate-0');
            }
            // Adjust channel control area visibility based on screen width on load
            // Now it's inside the sidebar, so manage its internal toggle
            if (window.innerWidth >= 768) {
                 channelInputContent.classList.remove('max-h-0');
                 channelInputContent.classList.add('max-h-full');
                 channelToggleIcon.classList.add('rotate-0');
                 channelToggleIcon.classList.remove('rotate-180');
                 // Also ensure WebRTC controls are visible on larger screens by default
                 webrtcMainPanel.classList.remove('hidden'); 
                 webrtcToggleIcon.classList.add('rotate-0');
                 webrtcToggleIcon.classList.remove('rotate-180');
            } else {
                 channelInputContent.classList.add('max-h-0');
                 channelInputContent.classList.remove('max-h-full');
                 channelToggleIcon.classList.add('rotate-180');
                 channelToggleIcon.classList.remove('rotate-0');
                 // Make WebRTC controls collapsible on smaller screens
                 webrtcMainPanel.classList.add('hidden'); 
                 webrtcToggleIcon.classList.add('rotate-180'); 
                 webrtcToggleIcon.classList.remove('rotate-0');
            }
            // Adjust friends sidebar visibility based on screen width on load
            if (window.innerWidth >= 768) {
                friendsSidebar.classList.add('w-64');
                friendsSidebar.classList.remove('w-0');
                friendsToggleIcon.classList.add('rotate-0');
                friendsToggleIcon.classList.remove('rotate-180');
                // Ensure the new "Add Friend by Code" panel is expanded by default on larger screens
                addFriendByCodeContent.classList.remove('max-h-0');
                addFriendByCodeContent.classList.add('max-h-full');
                addFriendByCodeToggleIcon.classList.add('rotate-0');
                addFriendByCodeToggleIcon.classList.remove('rotate-180');
            } else {
                friendsSidebar.classList.remove('w-64');
                friendsSidebar.classList.add('w-0');
                friendsToggleIcon.classList.add('rotate-180');
                friendsToggleIcon.classList.remove('rotate-0');
                // Ensure the new "Add Friend by Code" panel is collapsed by default on smaller screens
                addFriendByCodeContent.classList.add('max-h-0');
                addFriendByCodeContent.classList.remove('max-h-full');
                addFriendByCodeToggleIcon.classList.add('rotate-180');
                addFriendByCodeToggleIcon.classList.remove('rotate-0');
            }

            // Ensure theme is applied correctly on load
            applyTheme(localStorage.getItem('wChatTheme') || 'dark');
        };
    </script>
</body>
</html>
