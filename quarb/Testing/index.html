<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metallic Fluid Quarb</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            text-align: center;
            padding: 10px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 8px;
            font-size: 0.9em;
            z-index: 100;
            color: #eee;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            color: #fff;
            z-index: 200;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
    </style>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <div id="info" class="text-sm md:text-base">
        loading… drag the screen to rotate… tap the Quarb to make it funky.
    </div>
    <div id="loading">(loading).</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        let scene, camera, renderer, mesh, controls, raycaster;
        let clock = new THREE.Clock();
        let originalPositions = null; // Stores original vertex positions
        
        // --- Configuration ---
        const SHAPE_SIZE = 2.5;
        const SUBDIVISIONS = 32;

        const hdriURL = 'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/phalzer_forest_01_2k.hdr';
        // Using a more suitable metallic texture URL for demonstration purposes
        const objectTextureURL = 'https://threejs.org/examples/textures/crate.gif'; // A common simple texture

        const ripples = []; // Array to store active ripple effects
        const MAX_RIPPLES = 5; // Max concurrent ripples
        const RIPPLE_DURATION = 2.5; // seconds
        const RIPPLE_SPEED = 3.0;
        const RIPPLE_AMPLITUDE = 0.3 * SHAPE_SIZE; // Max displacement of ripple

        function init() {
            const loadingDiv = document.getElementById('loading');
            const infoDiv = document.getElementById('info');

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, SHAPE_SIZE * 0.5, SHAPE_SIZE * 3);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();

            const rgbeLoader = new RGBELoader();
            const textureLoader = new THREE.TextureLoader();
            let hdriLoaded = false;
            let textureLoaded = false;

            rgbeLoader.load(hdriURL, (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.environment = texture; // Crucial for reflections on MeshStandardMaterial
                hdriLoaded = true;
                checkAssetsLoaded();
            }, undefined, (error) => {
                console.error('Error loading HDRI:', error);
                scene.background = new THREE.Color(0x111111); // Fallback background
                hdriLoaded = true;
                checkAssetsLoaded();
            });

            const diffuseTexture = textureLoader.load(objectTextureURL, () => {
                textureLoaded = true;
                checkAssetsLoaded();
            }, undefined, (error) => {
                console.error('Error loading object texture:', error);
                textureLoaded = true;
                checkAssetsLoaded();
            });
            diffuseTexture.wrapS = THREE.RepeatWrapping;
            diffuseTexture.wrapT = THREE.RepeatWrapping;
            diffuseTexture.repeat.set(3, 3); // Repeat texture for more detail


            function checkAssetsLoaded() {
                if (hdriLoaded && textureLoaded) {
                    if (loadingDiv) loadingDiv.style.display = 'none';
                    if (infoDiv) infoDiv.textContent = 'two fingers to zoom.. drag to rotate... tap the quarb and be So Amazed.';
                    createSceneObjects(diffuseTexture);
                    animate();
                }
            }

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = SHAPE_SIZE * 1.2;
            controls.maxDistance = SHAPE_SIZE * 10;
            controls.target.set(0, SHAPE_SIZE * 0.2, 0); // Aim camera slightly above center

            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
        }

        function createSceneObjects(loadedTexture) {
            // Your existing lights are good and will complement the HDR environment
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
            keyLight.position.set(5, 5, 5);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            keyLight.shadow.camera.near = 0.5;
            keyLight.shadow.camera.far = 50;
            const shadowCamSize = 10;
            keyLight.shadow.camera.left = -shadowCamSize;
            keyLight.shadow.camera.right = shadowCamSize;
            keyLight.shadow.camera.top = shadowCamSize;
            keyLight.shadow.camera.bottom = -shadowCamSize;
            keyLight.shadow.bias = -0.001;
            scene.add(keyLight);
            
            const fillLight = new THREE.DirectionalLight(0xaaaaff, 0.5);
            fillLight.position.set(-5, 2, 5);
            scene.add(fillLight);

            // Use IcosahedronGeometry for the fluid shape
            const geometry = new THREE.IcosahedronGeometry(SHAPE_SIZE / 2, SUBDIVISIONS); // Reduced size slightly
            geometry.computeVertexNormals();

            // Store original positions for morphing
            originalPositions = new Float32Array(geometry.attributes.position.array);

            const material = new THREE.MeshStandardMaterial({
                map: loadedTexture,
                color: 0xffffff, // White base color to let texture and environment define hue
                metalness: 0.95, // High metalness for metallic look
                roughness: 0.05, // Low roughness for high reflectivity
                envMap: scene.environment, // Automatically uses the loaded HDR texture
                envMapIntensity: 1.5, // Adjust intensity of environment reflections
            });

            mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x222222,
                metalness: 0.6,
                roughness: 0.5,
                envMap: scene.environment,
                envMapIntensity: 0.7
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -SHAPE_SIZE * 0.75; // Adjust ground position relative to new SHAPE_SIZE/2
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerDown(event) {
            event.preventDefault();

            const pointer = new THREE.Vector2();
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObject(mesh);

            if (intersects.length > 0) {
                const intersection = intersects[0];
                const point = intersection.point;
                // Get normal in world coordinates to ensure displacement is correct
                const normal = intersection.face.normal.clone().transformDirection(mesh.matrixWorld).normalize();

                if (ripples.length >= MAX_RIPPLES) {
                    ripples.shift();
                }
                ripples.push({
                    center: point,
                    startTime: clock.getElapsedTime(),
                    normal: normal
                });
            }
        }

        function applyMorphing() {
            if (!mesh || !originalPositions) return;

            const positionAttribute = mesh.geometry.attributes.position;
            const time = clock.getElapsedTime();

            // Always start from the base original shape
            positionAttribute.array.set(originalPositions); 

            const tempVec = new THREE.Vector3(); // For calculations

            let needsNormalUpdate = false; // Flag to only recompute normals if a ripple is active

            for (let r = 0; r < ripples.length; r++) {
                const ripple = ripples[r];
                const rippleAge = time - ripple.startTime;

                if (rippleAge > RIPPLE_DURATION) {
                    ripples.splice(r, 1);
                    r--;
                    continue;
                }

                needsNormalUpdate = true; // If any ripple is active, normals need update

                const progress = rippleAge / RIPPLE_DURATION;
                const currentRippleRadius = rippleAge * RIPPLE_SPEED;
                const currentAmplitude = RIPPLE_AMPLITUDE * Math.sin(progress * Math.PI); // Smooth in-out effect

                for (let i = 0; i < positionAttribute.count; i++) {
                    tempVec.fromArray(originalPositions, i * 3); // Get original vertex position
                    
                    // Transform original vertex position to world space for distance calculation
                    // This is important if the mesh itself is rotated or scaled.
                    const vertexWorldPos = tempVec.clone().applyMatrix4(mesh.matrixWorld); 
                    const distToCenter = vertexWorldPos.distanceTo(ripple.center);

                    const waveWidth = SHAPE_SIZE * 0.2; // How thick the ripple wave is (adjusted for smaller SHAPE_SIZE)
                    if (distToCenter > currentRippleRadius - waveWidth && distToCenter < currentRippleRadius + waveWidth) {
                        const waveProfile = Math.sin(((distToCenter - currentRippleRadius) / waveWidth) * Math.PI);
                        const displacement = currentAmplitude * waveProfile;

                        const dx = ripple.normal.x * displacement;
                        const dy = ripple.normal.y * displacement;
                        const dz = ripple.normal.z * displacement;

                        // Apply displacement to the current array values (which were just reset to original)
                        positionAttribute.array[i * 3] += dx;
                        positionAttribute.array[i * 3 + 1] += dy;
                        positionAttribute.array[i * 3 + 2] += dz;
                    }
                }
            }

            positionAttribute.needsUpdate = true;
            if (needsNormalUpdate) {
                mesh.geometry.computeVertexNormals(); // Only recompute if morphing occurred
            }
        }


        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Update OrbitControls for damping and auto-rotation
            applyMorphing(); // Apply ripple effects
            renderer.render(scene, camera);
        }

        // Use DOMContentLoaded to ensure the HTML structure is ready before initializing Three.js
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
