<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>turing</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
        }
        .font-fira {
            font-family: 'Fira Code', monospace;
        }
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937;
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }
        .ram-cell {
            transition: all 0.2s ease-in-out;
        }
        .ram-cell.highlight-read {
            animation: highlight-read 0.5s ease-out;
        }
        .ram-cell.highlight-write {
            animation: highlight-write 0.5s ease-out;
        }
        @keyframes highlight-read {
            50% { background-color: #2563eb; transform: scale(1.1); }
        }
        @keyframes highlight-write {
            50% { background-color: #db2777; transform: scale(1.1); }
        }
        .register {
            transition: all 0.2s ease-in-out;
        }
        .register.highlight-update {
             animation: highlight-update 0.5s ease-out;
        }
        @keyframes highlight-update {
            50% { background-color: #16a34a; }
        }
        /* Highlight for Dedicated Counter 1 */
        #dedicated-counter-display.highlight-update {
            animation: highlight-counter 0.5s ease-out;
        }
        @keyframes highlight-counter {
            50% { background-color: #92400e; } /* Orange-ish highlight */
        }
        /* Highlight for Dedicated Counter 2 */
        #dedicated-counter-display-2.highlight-update {
            animation: highlight-counter-2 0.5s ease-out;
        }
        @keyframes highlight-counter-2 {
            50% { background-color: #7c2d12; } /* Darker orange/brown highlight */
        }
        
        /* Code Editor Specific Styles for Highlighting */
        #code-editor-container {
            position: relative;
            /* Ensure it has a defined height, flex-grow from parent should handle it */
        }
        #line-numbers {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            padding: 1rem;
            background-color: #374151; /* bg-gray-700 */
            text-align: right;
            color: #9ca3af; /* text-gray-400 */
            user-select: none;
            overflow: hidden;
            z-index: 20; /* Above highlighted-code, below textarea content flow */
            line-height: 1.5rem; /* Match textarea line-height */
            font-size: 1rem; /* Match textarea font-size */
            box-sizing: border-box; /* Ensure padding is included in element's total width/height */
        }
        #code-input {
            position: absolute;
            inset: 0; /* Cover the entire container */
            padding-left: 4.5rem; /* Adjust based on line-numbers width */
            padding-top: 1rem;
            padding-bottom: 1rem;
            white-space: pre; /* Keep pre-formatted whitespace */
            overflow-wrap: normal;
            overflow-x: auto;
            height: 100%;
            width: 100%;
            background-color: transparent; /* Make background transparent */
            color: transparent; /* Make text transparent */
            caret-color: white; /* Show caret in white */
            resize: none;
            spellcheck: false;
            z-index: 10; /* Above highlighted-code */
            outline: none;
            line-height: 1.5rem; /* Explicitly match 1.5rem for Fira Code font */
            font-size: 1rem;
            font-family: 'Fira Code', monospace; /* Explicitly set font */
            box-sizing: border-box; /* Crucial for consistent sizing */
        }
        #highlighted-code {
            position: absolute;
            inset: 0;
            padding-left: 4.5rem; /* Match textarea padding */
            padding-top: 1rem;
            padding-bottom: 1rem;
            font-family: 'Fira Code', monospace;
            font-size: 1rem;
            line-height: 1.5rem; /* Match textarea line-height */
            z-index: 5; /* Below textarea, above container background */
            pointer-events: none; /* Crucial: allows clicks to pass through to textarea */
            white-space: pre; /* Match textarea whitespace behavior */
            overflow-wrap: normal;
            overflow-x: auto;
            color: white; /* Default color for highlighting, will be overridden by spans */
            box-sizing: border-box; /* Crucial for consistent sizing */
        }
        #highlighted-code span {
            display: inline-block; /* Treat each token as a block for line height consistency */
            line-height: 1.5rem; /* Ensure consistent line height for each token */
        }

        /* Syntax Highlighting Classes */
        .opcode-orange { color: #f97316; } /* Orange-600 */
        .opcode-pink { color: #ec4899; } /* Pink-500 */
        .arg-green { color: #22c55e; } /* Green-500 */
        .inc-green { color: #10b981; } /* Emerald-500 */
        .label-red { color: #ef4444; } /* Red-500 */
        .comment-white { color: #9ca3af; } /* Gray-400 for comments, slightly different from text-gray-200 */

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.open {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #1f2937; /* bg-gray-800 */
            padding: 2rem;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3);
            max-width: 80%;
            max-height: 90%;
            overflow-y: auto;
            color: #d1d5db; /* text-gray-200 */
            position: relative;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }
        .modal-overlay.open .modal-content {
            transform: translateY(0);
        }
        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #9ca3af;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .modal-close-btn:hover {
            color: #e5e7eb;
        }
    </style>
</head>
<body class="text-gray-200">

    <div class="min-h-screen flex flex-col p-4 sm:p-6 lg:p-8">
        <!-- Header -->
        <header class="text-center mb-6 relative">
            <h1 class="text-4xl font-bold text-white tracking-tight">Turing Machine Incrementer</h1>
            <p class="text-lg text-gray-400 mt-2">A simple Turing Machine simulated on the CPU, increments a binary number on the tape (RAM).</p>
            <button id="info-btn" class="absolute top-0 right-0 sm:right-6 lg:right-8 bg-blue-600 hover:bg-blue-700 text-white font-bold p-2 rounded-full text-lg w-10 h-10 flex items-center justify-center shadow-lg transition-colors">
                i
            </button>
        </header>

        <!-- Main Grid Layout -->
        <main class="flex-grow grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- Left Column: Code & Controls -->
            <div class="lg:col-span-1 flex flex-col gap-6">
                <!-- Code Editor -->
                <div class="bg-gray-800 rounded-xl shadow-lg flex flex-col h-full">
                    <div class="p-4 border-b border-gray-700 flex justify-between items-center">
                        <div>
                           <h2 class="text-xl font-semibold text-white">Program Code</h2>
                           <p class="text-sm text-gray-400">Write your assembly code below.</p>
                        </div>
                         <a href="#" id="load-example" class="text-sm text-blue-400 hover:underline">Load Example</a>
                    </div>
                    <div id="code-editor-container" class="font-fira text-base bg-gray-900 flex-grow rounded-b-xl overflow-hidden relative">
                        <div id="line-numbers">1</div>
                        <div id="highlighted-code"></div> <!-- This will display the highlighted code -->
                        <textarea id="code-input" class="w-full h-full p-4 bg-transparent text-white resize-none" spellcheck="false" rows="15"></textarea>
                    </div>
                </div>

                <!-- Controls -->
                <div class="bg-gray-800 p-4 rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-white">Controls</h2>
                    <div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
                        <button id="run-btn" class="control-button bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center gap-2 transition-colors">Run</button>
                        <button id="step-btn" class="control-button bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center gap-2 transition-colors">Step</button>
                        <button id="pause-btn" class="control-button bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center gap-2 transition-colors" disabled>Pause</button>
                        <button id="reset-btn" class="control-button bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center gap-2 transition-colors">Reset</button>
                    </div>
                    <div class="mt-4">
                        <label for="speed-slider" class="block mb-2 text-sm font-medium text-gray-300">Execution Speed</label>
                        <input id="speed-slider" type="range" min="0" max="1000" value="800" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>
            </div>

            <!-- Right Column: Machine State -->
            <div class="lg:col-span-2 flex flex-col gap-6">
                <!-- Status & CPU State -->
                <div class="bg-gray-800 p-4 rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-white">CPU State</h2>
                    <div class="grid grid-cols-2 sm:grid-cols-4 gap-4 text-center">
                        <div>
                            <h3 class="text-sm font-medium text-gray-400">Status</h3>
                            <p id="status-display" class="text-lg font-semibold text-blue-400">Idle</p>
                        </div>
                        <div>
                            <h3 class="text-sm font-medium text-gray-400">Program Counter</h3>
                            <p id="pc-display" class="text-lg font-semibold text-green-400 font-fira">0</p>
                        </div>
                        <div>
                            <h3 class="text-sm font-medium text-gray-400">Compare Flag</h3>
                            <p id="flag-display" class="text-lg font-semibold text-yellow-400 font-fira">0</p>
                        </div>
                        <div>
                            <h3 class="text-sm font-medium text-gray-400">Dedicated Counter 1</h3>
                            <p id="dedicated-counter-display" class="text-lg font-semibold text-orange-400 font-fira">0</p>
                        </div>
                        <div>
                            <h3 class="text-sm font-medium text-gray-400">Dedicated Counter 2</h3>
                            <p id="dedicated-counter-display-2" class="text-lg font-semibold text-amber-600 font-fira">0</p>
                        </div>
                        <div>
                            <h3 class="text-sm font-medium text-gray-400">Error</h3>
                            <p id="error-display" class="text-sm font-semibold text-red-400 h-6 truncate" title="">-</p>
                        </div>
                    </div>
                    <div class="mt-6">
                        <h3 class="text-lg font-semibold text-center mb-2 text-white">Registers</h3>
                        <div id="registers-container" class="grid grid-cols-2 md:grid-cols-4 gap-3">
                            <!-- Registers injected here -->
                        </div>
                    </div>
                </div>

                <!-- Memory -->
                <div class="bg-gray-800 rounded-xl shadow-lg p-4 flex-grow flex flex-col">
                    <h2 class="text-xl font-semibold mb-4 text-white">RAM</h2>
                    <div id="ram-container" class="w-full overflow-x-auto pb-4">
                        <div class="flex space-x-2">
                            <!-- Memory cells will be injected here -->
                        </div>
                    </div>
                </div>

                <!-- I/O Section -->
                <div class="bg-gray-800 p-4 rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-2 text-white">I/O</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                           <h3 class="text-lg mb-2 text-gray-300">Input</h3>
                           <textarea id="input-area" class="font-fira w-full h-24 p-2 bg-gray-900 rounded-md text-white resize-none" placeholder="Provide one number per line for the INP command..."></textarea>
                        </div>
                         <div>
                            <h3 class="text-lg mb-2 text-gray-300">Output</h3>
                            <pre id="output-area" class="font-fira w-full h-24 p-2 bg-gray-900 rounded-md text-white overflow-y-auto whitespace-pre-wrap break-word"></pre>
                        </div>
                    </div>
                </div>
            </div>

        </main>
    </div>

    <!-- Info Modal -->
    <div id="info-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn" id="close-modal-btn">&times;</button>
            <h2 class="text-3xl font-bold text-white mb-4">About This Simulation</h2>

            <section class="mb-6">
                <h3 class="text-2xl font-semibold text-blue-300 mb-2">What is a Turing-Complete Computer?</h3>
                <p class="mb-2">A **Turing-complete** system is one that can simulate any Turing machine. A Turing machine is a theoretical model of computation that consists of a tape (infinite memory), a head that can read and write symbols on the tape, and a set of rules (program) that dictate its behavior. If a system can simulate a Turing machine, it means it can perform any computation that any other computer can perform, given enough time and memory.</p>
                <p class="mb-2">However, real-world computers (like this simulation) have **finite memory**. This fundamental limitation means they are technically not truly Turing-complete. But, for practical purposes, if their instruction set and control flow capabilities are rich enough, they are considered "mostly" Turing-complete because they can simulate the *computational aspects* of a Turing machine, assuming the problem fits within their memory constraints.</p>
                <p>This CPU simulation, despite its finite RAM, possesses the necessary instructions (arithmetic, data movement, conditional jumps) to simulate other computational models like a Register Machine, which in turn are known to be Turing-equivalent. Therefore, in theory (ignoring memory limits), it can perform universal computation.</p>
            </section>

            <section class="mb-6">
                <h3 class="text-2xl font-semibold text-blue-300 mb-2">How This CPU Simulation Works</h3>
                <p class="mb-2">This interactive application simulates a very basic Central Processing Unit (CPU) with a small set of assembly-like instructions:</p>
                <ul class="list-disc list-inside ml-4 mb-2">
                    <li><strong>Registers (A, B, C, D):</strong> These are small, fast storage locations within the CPU used for computations.</li>
                    <li><strong>RAM (Random Access Memory):</strong> This is the main memory, a larger storage area where data and program instructions can be stored. This simulation has 64 RAM cells.</li>
                    <li><strong>Program Counter (PC):</strong> Points to the current instruction being executed in the program.</li>
                    <li><strong>Compare Flag:</strong> Set by the `CMP` instruction to indicate if the first value was less than (-1), equal to (0), or greater than (1) the second value.</li>
                    <li><strong>Dedicated Counter 1 ($):</strong> A special-purpose counter that can be incremented by the `INC` instruction.</li>
                    <li><strong>Dedicated Counter 2 ($2):</strong> Another special-purpose counter that can be incremented by the `INC2` instruction.</li>
                </ul>
                <p class="mb-2">Key Instructions:</p>
                <ul class="list-disc list-inside ml-4 mb-4">
                    <li>`MOV REG, VAL/REG/EXPR`: Move a value, register content, or the result of an arithmetic expression into a register.</li>
                    <li>`ADD REG, VAL/REG/EXPR`: Add a value, register content, or the result of an arithmetic expression to a register.</li>
                    <li>`SUB REG, VAL/REG/EXPR`: Subtract a value, register content, or the result of an arithmetic expression from a register.</li>
                    <li>`LOAD REG, ADDR/EXPR`: Load content from a RAM address (which can be specified by an expression) into a register.</li>
                    <li>`STOR REG, ADDR/EXPR`: Store content from a register into a RAM address (which can be specified by an expression). **Note:** After a `STOR` operation, only the source register (the one whose value was stored) is cleared to 0 in this specific simulation. Other registers retain their values.</li>
                    <li>`INP REG`: Read a number from the input area into a register.</li>
                    <li>`OUT REG/VAL/EXPR`: Output a register content, value, or the result of an arithmetic expression to the output area.</li>
                    <li>`CMP VAL/REG/EXPR, VAL/REG/EXPR`: Compare two values (which can be specified by expressions) and set the Compare Flag.</li>
                    <li>`INC`: Increments Dedicated Counter 1 ($) by 1.</li>
                    <li>`INC2`: Increments Dedicated Counter 2 ($2) by 1.</li>
                    <li>`JMP LABEL`: Unconditionally jump to a program label.</li>
                    <li>`JEZ LABEL`: Jump if the Compare Flag is Zero (equal).</li>
                    <li>`JNE LABEL`: Jump if the Compare Flag is Not Zero (not equal).</li>
                    <li>`JGT LABEL`: Jump if the Compare Flag is Greater Than Zero.</li>
                    <li>`JLT LABEL`: Jump if the Compare Flag is Less Than Zero.</li>
                    <li>`HLT`: Halt the program execution.</li>
                </ul>
                <p class="mb-2">Arithmetic expressions can now be used as arguments for `MOV`, `ADD`, `SUB`, `LOAD`, `STOR`, `OUT`, and `CMP` instructions. Supported operators are `+`, `-`, `*`, `/`. Expressions must be in the format `Operand Operator Operand` (e.g., `A + 1`, `B * C`). Division performs integer division (result is floored). Additionally, using `$` as an operand in an expression will reference the current value of Dedicated Counter 1, and `$2` will reference Dedicated Counter 2 (e.g., `STOR A, $`, `ADD B, $2 + 5`).</p>
            </section>

            <section class="mb-6">
                <h3 class="text-2xl font-semibold text-blue-300 mb-2">Detailed Assembly Programming Guide</h3>
                <p class="mb-2">This section provides a detailed guide on each instruction available in this CPU's assembly language, including their purpose, syntax, arguments, and practical examples.</p>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">1. `MOV` (Move)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Copies a value, the content of one register, or the result of an arithmetic expression into another register.</p>
                <p class="mb-1"><strong>Syntax:</strong> `MOV DEST_REG, SOURCE`</p>
                <ul class="list-disc list-inside ml-4 mb-2">
                    <li>`DEST_REG`: The destination register (A, B, C, or D) where the value will be stored.</li>
                    <li>`SOURCE`: Can be an integer literal (e.g., `10`, `-5`), another register name (e.g., `B`, `C`), or a simple arithmetic expression (e.g., `A + 1`, `B * D`, `5 + $`, `A - $2`).</li>
                </ul>
                <p class="mb-1"><strong>Behavior:</strong> The value of `SOURCE` is copied into `DEST_REG`. The `SOURCE` itself is unchanged.</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
MOV A, 10           ; Register A becomes 10
MOV B, A            ; Register B becomes 10 (value from A)
MOV C, -5           ; Register C becomes -5
MOV D, A + 5        ; Register D becomes 15 (if A was 10)
MOV A, B * C        ; Register A becomes -50 (if B was 10, C was -5)
MOV B, $ + 1        ; Register B becomes (dedicatedCounter + 1)
MOV D, $2 - 3       ; Register D becomes (dedicatedCounter2 - 3)
                </pre>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">2. `ADD` (Add)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Adds a value, the content of one register, or the result of an arithmetic expression to another register.</p>
                <p class="mb-1"><strong>Syntax:</strong> `ADD DEST_REG, SOURCE`</p>
                <ul class="list-disc list-inside ml-4 mb-2">
                    <li>`DEST_REG`: The destination register (A, B, C, or D) to which `SOURCE` will be added. The result is stored back in `DEST_REG`.</li>
                    <li>`SOURCE`: Can be an integer literal, another register name, or a simple arithmetic expression.</li>
                </ul>
                <p class="mb-1"><strong>Behavior:</strong> `DEST_REG = DEST_REG + SOURCE`. `SOURCE` is unchanged.</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
MOV A, 5    ; A = 5
MOV B, 3    ; B = 3
ADD A, B    ; A = A + B (A becomes 8)
ADD C, 10   ; C = C + 10 (assuming C was 0, C becomes 10)
ADD D, A / 2 ; D = D + (A / 2) (integer division)
ADD A, $    ; A = A + dedicatedCounter
ADD B, $2   ; B = B + dedicatedCounter2
                </pre>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">3. `SUB` (Subtract)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Subtracts a value, the content of one register, or the result of an arithmetic expression from another register.</p>
                <p class="mb-1"><strong>Syntax:</strong> `SUB DEST_REG, SOURCE`</p>
                <ul class="list-disc list-inside ml-4 mb-2">
                    <li>`DEST_REG`: The destination register (A, B, C, or D) from which `SOURCE` will be subtracted. The result is stored back in `DEST_REG`.</li>
                    <li>`SOURCE`: Can be an integer literal, another register name, or a simple arithmetic expression.</li>
                </ul>
                <p class="mb-1"><strong>Behavior:</strong> `DEST_REG = DEST_REG - SOURCE`. `SOURCE` is unchanged.</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
MOV A, 10   ; A = 10
MOV B, 3    ; B = 3
SUB A, B    ; A = A - B (A becomes 7)
SUB D, 1    ; D = D - 1 (decrement D)
SUB B, A - C ; B = B - (A - C)
SUB C, $    ; C = C - dedicatedCounter
SUB D, $2   ; D = D - dedicatedCounter2
                </pre>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">4. `LOAD` (Load from RAM)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Copies a value from a specified RAM address (which can be an expression) into a register.</p>
                <p class="mb-1"><strong>Syntax:</strong> `LOAD DEST_REG, ADDRESS`</p>
                <ul class="list-disc list-inside ml-4 mb-2">
                    <li>`DEST_REG`: The register (A, B, C, or D) where the loaded value will be stored.</li>
                    <li>`ADDRESS`: An integer literal representing a valid RAM address (0-63), or an arithmetic expression that evaluates to a valid address (e.g., `3 + B`, `10 + $`, `20 + $2`).</li>
                </ul>
                <p class="mb-1"><strong>Behavior:</strong> `DEST_REG = RAM[ADDRESS]`. The content of RAM at `ADDRESS` remains unchanged.</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
; Assume RAM[5] contains the value 100
LOAD A, 5           ; Register A becomes 100
MOV B, 2
LOAD C, 3 + B       ; Register C becomes RAM[5] (if B was 2)
LOAD D, 10 + $      ; Register D becomes RAM[10 + dedicatedCounter]
LOAD A, 30 + $2     ; Register A becomes RAM[30 + dedicatedCounter2]
                </pre>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">5. `STOR` (Store to RAM)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Copies a value from a register into a specified RAM address (which can be an expression).</p>
                <p class="mb-1"><strong>Syntax:</strong> `STOR SOURCE_REG, ADDRESS`</p>
                <ul class="list-disc list-inside ml-4 mb-2">
                    <li>`SOURCE_REG`: The register (A, B, C, or D) whose content will be stored.</li>
                    <li>`ADDRESS`: An integer literal representing a valid RAM address (0-63), or an arithmetic expression that evaluates to a valid address (e.g., `B + C`, `$ * 2`, `$2 + 10`).</li>
                </ul>
                <p class="mb-1"><strong>Behavior:</strong> `RAM[ADDRESS] = SOURCE_REG`. The content of `SOURCE_REG` is then cleared to 0. Other registers (not `SOURCE_REG`) will retain their values.</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
MOV A, 25   ; A = 25
MOV B, 10   ; B = 10
STOR A, 10  ; RAM[10] becomes 25. A becomes 0. B, C, D remain unchanged.
MOV C, 1
STOR B, B + C ; RAM[11] becomes B's value (10). B becomes 0.
STOR D, $   ; RAM[dedicatedCounter] becomes D's value. D becomes 0.
STOR A, $2  ; RAM[dedicatedCounter2] becomes A's value. A becomes 0.
                </pre>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">6. `INP` (Input)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Reads the next number from the Input area into a specified register.</p>
                <p class="mb-1"><strong>Syntax:</strong> `INP DEST_REG`</p>
                <ul class="list-disc list-inside ml-4 mb-2">
                    <li>`DEST_REG`: The register (A, B, C, or D) where the input value will be stored.</li>
                </ul>
                <p class="mb-1"><strong>Behavior:</strong> The first available number from the Input area is consumed and placed into `DEST_REG`. If no input is available, the CPU will pause execution until input is provided.</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
; Input area has:
; 42
; 100
INP A       ; A becomes 42. Input area now has: 100
INP B       ; B becomes 100. Input area is now empty.
                </pre>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">7. `OUT` (Output)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Displays a value, the content of a register, or the result of an arithmetic expression in the Output area.</p>
                <p class="mb-1"><strong>Syntax:</strong> `OUT SOURCE`</p>
                <ul class="list-disc list-inside ml-4 mb-2">
                    <li>`SOURCE`: Can be an integer literal, a register name (A, B, C, or D), or a simple arithmetic expression.</li>
                </ul>
                <p class="mb-1"><strong>Behavior:</strong> The value of `SOURCE` is appended as a new line to the Output area.</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
MOV A, 7
OUT A       ; Output: 7
OUT 99      ; Output: 99 (on a new line)
OUT A * 2   ; Output: 14 (if A was 7)
OUT $       ; Output: current value of Dedicated Counter 1
OUT $2      ; Output: current value of Dedicated Counter 2
                </pre>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">8. `CMP` (Compare)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Compares two values (which can be expressions) and sets the `Compare Flag` based on their relationship.</p>
                <p class="mb-1"><strong>Syntax:</strong> `CMP VALUE1, VALUE2`</p>
                <ul class="list-disc list-inside ml-4 mb-2">
                    <li>`VALUE1`: Can be an integer literal, a register name, or a simple arithmetic expression.</li>
                    <li>`VALUE2`: Can be an integer literal, a register name, or a simple arithmetic expression.</li>
                </ul>
                <p class="mb-1"><strong>Behavior:</strong> Sets the `Compare Flag` register:</p>
                <ul class="list-disc list-inside ml-8">
                    <li>`-1` if `VALUE1 < VALUE2`</li>
                    <li>`0` if `VALUE1 == VALUE2`</li>
                    <li>`1` if `VALUE1 > VALUE2`</li>
                </ul>
                <p class="mb-1">This flag is then used by conditional jump instructions (`JEZ`, `JNE`, `JGT`, `JLT`).</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
MOV A, 5
MOV B, 10
CMP A, B        ; Compare Flag = -1 (5 < 10)
CMP B, 5        ; Compare Flag = 1 (10 > 5)
CMP A, 5        ; Compare Flag = 0 (5 == 5)
CMP A + 1, B    ; Compare Flag = -1 (6 < 10)
CMP $, 10       ; Compare Flag based on Dedicated Counter 1 vs 10
CMP $2, B       ; Compare Flag based on Dedicated Counter 2 vs B
                </pre>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">9. `INC` (Increment Dedicated Counter 1)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Increments Dedicated Counter 1 ($) by 1.</p>
                <p class="mb-1"><strong>Syntax:</strong> `INC` (takes no arguments)</p>
                <p class="mb-1"><strong>Behavior:</strong> The `Dedicated Counter 1` variable is incremented by 1. This instruction is useful for tracking loop iterations or other custom counts.</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
MOV A, 3
LOOP_COUNT:
    INC         ; Dedicated Counter 1 increments
    SUB A, 1
    CMP A, 0
    JNE LOOP_COUNT
OUT $           ; Output: final value of Dedicated Counter 1
                </pre>
                
                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">10. `INC2` (Increment Dedicated Counter 2)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Increments Dedicated Counter 2 ($2) by 1.</p>
                <p class="mb-1"><strong>Syntax:</strong> `INC2` (takes no arguments)</p>
                <p class="mb-1"><strong>Behavior:</strong> The `Dedicated Counter 2` variable is incremented by 1.</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
MOV A, 5
LOOP_INNER:
    INC2        ; Dedicated Counter 2 increments
    SUB A, 1
    CMP A, 0
    JNE LOOP_INNER
OUT $2          ; Output: final value of Dedicated Counter 2
                </pre>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">11. `JMP` (Jump)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Unconditionally changes the `Program Counter` (PC) to the address of a specified label, causing execution to continue from that point.</p>
                <p class="mb-1"><strong>Syntax:</strong> `JMP LABEL_NAME`</p>
                <ul class="list-disc list-inside ml-4 mb-2">
                    <li>`LABEL_NAME`: A label defined in your program (e.g., `MY_LOOP:`, `START:`).</li>
                </ul>
                <p class="mb-1"><strong>Behavior:</strong> The PC is set to the line number associated with `LABEL_NAME`. This creates loops or jumps to subroutines.</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
START:
    MOV A, 1
    JMP END_PROGRAM
    ; This line will be skipped
    MOV A, 0
END_PROGRAM:
    HLT
                </pre>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">12. `JEZ` (Jump if Equal to Zero)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Jumps to a label if the `Compare Flag` is 0 (meaning the last `CMP` operation resulted in equality).</p>
                <p class="mb-1"><strong>Syntax:</strong> `JEZ LABEL_NAME`</p>
                <p class="mb-1"><strong>Behavior:</strong> If `Compare Flag == 0`, PC is set to `LABEL_NAME`. Otherwise, execution continues to the next instruction.</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
MOV A, 5
CMP A, 5    ; Compare Flag = 0
JEZ IS_FIVE ; Jumps to IS_FIVE
OUT 0       ; This line is skipped
IS_FIVE:
OUT 1       ; Output: 1
HLT
                </pre>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">13. `JNE` (Jump if Not Equal)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Jumps to a label if the `Compare Flag` is not 0 (meaning the last `CMP` operation resulted in inequality).</p>
                <p class="mb-1"><strong>Syntax:</strong> `JNE LABEL_NAME`</p>
                <p class="mb-1"><strong>Behavior:</strong> If `Compare Flag != 0`, PC is set to `LABEL_NAME`. Otherwise, execution continues to the next instruction.</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
MOV A, 5
CMP A, 6    ; Compare Flag = -1
JNE NOT_SIX ; Jumps to NOT_SIX
OUT 0       ; This line is skipped
NOT_SIX:
OUT 1       ; Output: 1
HLT
                </pre>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">14. `JGT` (Jump if Greater Than)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Jumps to a label if the `Compare Flag` is 1 (meaning the first value in `CMP` was greater than the second).</p>
                <p class="mb-1"><strong>Syntax:</strong> `JGT LABEL_NAME`</p>
                <p class="mb-1"><strong>Behavior:</strong> If `Compare Flag == 1`, PC is set to `LABEL_NAME`. Otherwise, execution continues to the next instruction.</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
MOV A, 10
MOV B, 5
CMP A, B    ; Compare Flag = 1
JGT A_IS_GREATER ; Jumps to A_IS_GREATER
OUT 0
A_IS_GREATER:
OUT 1       ; Output: 1
HLT
                </pre>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">15. `JLT` (Jump if Less Than)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Jumps to a label if the `Compare Flag` is -1 (meaning the first value in `CMP` was less than the second).</p>
                <p class="mb-1"><strong>Syntax:</strong> `JLT LABEL_NAME`</p>
                <p class="mb-1"><strong>Behavior:</strong> If `Compare Flag == -1`, PC is set to `LABEL_NAME`. Otherwise, execution continues to the next instruction.</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
MOV A, 5
MOV B, 10
CMP A, B    ; Compare Flag = -1
JLT A_IS_LESS ; Jumps to A_IS_LESS
OUT 0
A_IS_LESS:
OUT 1       ; Output: 1
HLT
                </pre>

                <h4 class="text-xl font-semibold text-gray-300 mt-4 mb-1">16. `HLT` (Halt)</h4>
                <p class="mb-1"><strong>Purpose:</strong> Stops the CPU execution.</p>
                <p class="mb-1"><strong>Syntax:</strong> `HLT` (takes no arguments)</p>
                <p class="mb-1"><strong>Behavior:</strong> The program halts, and the CPU status changes to "Halted".</p>
                <p class="mb-1"><strong>Example:</strong></p>
                <pre class="bg-gray-900 p-3 rounded-md text-sm font-fira overflow-x-auto mb-2">
MOV A, 1
OUT A
HLT         ; Program stops here
MOV B, 2    ; This line will never be reached
                </pre>
            </section>


            <section>
                <h3 class="text-2xl font-semibold text-blue-300 mb-2">The Turing Machine Incrementer Example Program</h3>
                <p class="mb-2">The example program loaded by default demonstrates how to simulate a simple Turing Machine. This TM's purpose is to **increment a binary number** stored on a "tape" within the CPU's RAM.</p>
                <h4 class="text-xl font-semibold text-gray-300 mb-1">Tape Representation:</h4>
                <p class="mb-2">The "tape" is a segment of RAM starting at address `RAM[10]`. Each cell contains a `0` or `1` for binary digits, and `2` represents a blank symbol. For example, the initial tape `0, 1, 1, 2, 2` represents the binary number "011".</p>
                <h4 class="text-xl font-semibold text-gray-300 mb-1">Turing Machine Logic (Incrementing):</h4>
                <p class="mb-2">The TM works by starting its "tape head" (Register A) at the rightmost digit of the binary number. It then processes the digits from right to left, performing additions with carry, similar to how you would manually increment a binary number:</p>
                <ul class="list-disc list-inside ml-4 mb-2">
                    <li>**If the current symbol is '1':** It changes the '1' to a '0' and moves the tape head one position to the left. This simulates a "carry-over" in binary addition.</li>
                    <li>**If the current symbol is '0':** It changes the '0' to a '1' and then halts. This signifies the end of the increment operation (no more carry).</li>
                    <li>**If the current symbol is 'BLANK' (2):** This means the entire number was '11...1' (e.g., '11'). It changes the blank to a '1' (creating a new most significant bit) and then halts. This handles overflows (e.g., '11' becomes '100').</li>
                </ul>
                <h4 class="text-xl font-semibold text-gray-300 mb-1">Register Management for `STOR` Side Effect:</h4>
                <p class="mb-2">Given the updated `STOR` instruction (which only clears the source register), the Turing machine program will still function correctly as it explicitly manages the tape head position by saving it to and loading it from `RAM[0]`. While the original program had to account for *all* registers being cleared, this updated behavior of `STOR` simplifies register management for other variables, as they will now persist across `STOR` operations unless they are the source register.</p>
                <ul class="list-disc list-inside ml-4">
                    <li>The tape head position (originally in Register A) is always saved to a dedicated RAM location (`RAM[0]`) just before a `STOR` instruction is executed.</li>
                    <li>Immediately after a `STOR` instruction, the tape head position is re-loaded from `RAM[0]` back into Register A.</li>
                    <li>This ensures that the tape head's position is correctly maintained throughout the TM's execution.</li>
                </ul>
                <p class="mt-2">After the increment operation completes, the program iterates through the modified tape (RAM[10] to RAM[14]) and outputs each symbol to the I/O output area, showing the result of the Turing machine's work.</p>
            </section>
        </div>
    </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const runBtn = document.getElementById('run-btn');
        const stepBtn = document.getElementById('step-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const speedSlider = document.getElementById('speed-slider');
        const codeInput = document.getElementById('code-input');
        const highlightedCodeDiv = document.getElementById('highlighted-code'); // New element for highlighting
        const lineNumbersDiv = document.getElementById('line-numbers');
        const inputArea = document.getElementById('input-area');
        const outputArea = document.getElementById('output-area');
        const ramContainer = document.querySelector('#ram-container > div');
        const registersContainer = document.getElementById('registers-container');
        const statusDisplay = document.getElementById('status-display');
        const pcDisplay = document.getElementById('pc-display');
        const flagDisplay = document.getElementById('flag-display');
        const errorDisplay = document.getElementById('error-display');
        const dedicatedCounterDisplay = document.getElementById('dedicated-counter-display'); 
        const dedicatedCounterDisplay2 = document.getElementById('dedicated-counter-display-2');
        const loadExampleBtn = document.getElementById('load-example');
        // Modal elements
        const infoBtn = document.getElementById('info-btn');
        const infoModal = document.getElementById('info-modal');
        const closeModalBtn = document.getElementById('close-modal-btn');


        // --- Machine State ---
        let ram = new Int32Array(64);
        let registers = { 'A': 0, 'B': 0, 'C': 0, 'D': 0 };
        const registerNames = Object.keys(registers);
        let pc = 0; // Program Counter
        let compareFlag = 0; // -1 (less), 0 (equal), 1 (greater)
        let dedicatedCounter = 0; // Dedicated counter 1
        let dedicatedCounter2 = 0; // Dedicated counter 2

        let program = [];
        let labelMap = {};
        let inputBuffer = [];

        let isRunning = false;
        let isPaused = false;
        let timeoutId = null;
        let executionSpeed = 1000 - parseInt(speedSlider.value, 10);

        // --- Turing Machine Example Program ---
        const EXAMPLE_PROGRAM = `; --- Turing Machine Simulation: Increment Binary Number ---
; This program simulates a simple Turing Machine that increments a binary number
; stored on a "tape" within the CPU's RAM.
;
; Tape Layout:
;   Tape starts at RAM address 10 (TAPE_START_ADDR)
;   Each cell holds a 0 or 1. A '2' represents a blank symbol.
;
; Initial Tape Example (binary "011" followed by blanks):
;   RAM[10] = 0
;   RAM[11] = 1
;   RAM[12] = 1 (Rightmost digit)
;   RAM[13] = 2 (Blank)
;   RAM[14] = 2 (Blank)
;
; Initial Tape Head Position: RAM[12] (rightmost digit)
; Expected Output: The tape contents after incrementing ("100", then blanks)

; Registers used:
;   A: Tape Head Position (RAM address)
;   B: Current Symbol read from tape
;   C: Temporary register for writing values (0, 1, or 2)
;   D: General purpose temporary register (currently unused in core logic)
;
; Dedicated RAM for saving Tape Head Position:
;   RAM[0]: Stores the Tape Head Position (Register A) across STOR calls
;           (This is still used even with the updated STOR behavior, as A is the source register for tape head moves)

; --- Program Start ---

START:
    ; Initialize Tape in RAM (Hardcoded for this example: 011__)
    ; Make sure these addresses are within RAM bounds (0-63)
    MOV D, 0    ; Set D to 0 (for initializing RAM cells)
    STOR D, 10  ; RAM[10] = 0 (D is cleared after STOR)
    MOV D, 1    ; Set D to 1
    STOR D, 11  ; RAM[11] = 1 (D is cleared after STOR)
    MOV D, 1    ; Set D to 1
    STOR D, 12  ; RAM[12] = 1 (D is cleared after STOR)
    MOV D, 2    ; Set D to BLANK_SYMBOL (2)
    STOR D, 13  ; RAM[13] = 2 (D is cleared after STOR)
    MOV D, 2    ; Set D to BLANK_SYMBOL (2)
    STOR D, 14  ; RAM[14] = 2 (D is cleared after STOR)

    ; Set initial Tape Head Position to the rightmost digit (RAM[12])
    MOV A, 12   ; Register A holds the tape head address
    STOR A, 0   ; Save initial tape head position to RAM[0] (A is cleared by this STOR)

LOOP:
    INC         ; Increment the dedicated counter for each loop iteration
    INC2        ; Increment the second dedicated counter
    LOAD A, 0   ; Restore A from RAM[0] at the start of each loop iteration (important because STOR clears A when it's the source)
    LOAD B, A   ; B = RAM[A]

    ; --- Turing Machine Transition Logic ---

    ; If Current Symbol (B) is 1
    CMP B, 1
    JEZ HANDLE_ONE

    ; If Current Symbol (B) is 0
    CMP B, 0
    JEZ HANDLE_ZERO

    ; If Current Symbol (B) is BLANK (2)
    CMP B, 2
    JEZ HANDLE_BLANK

    ; Error: Unexpected symbol on tape (should not happen in this TM)
    OUT B       ; Output the unexpected symbol for debugging
    HLT         ; Halt on error

HANDLE_ONE:
    ; Action for '1': Write 0, Move Left
    MOV C, 0    ; Set C to 0
    STOR C, A   ; Write 0 to RAM[A]. C is cleared. A (tape head position) remains intact because it's not the source.
                ; However, for the next step, A needs to be updated.
    LOAD A, 0   ; Restore A from RAM[0] (this is technically redundant given new STOR but keeps logic consistent)
    SUB A, 1    ; Move tape head left (A = A - 1)
    STOR A, 0   ; Save new A (tape head position) to RAM[0]. A is cleared by this STOR.
    JMP LOOP    ; Go back to LOOP to process next symbol

HANDLE_ZERO:
    ; Action for '0': Write 1, Halt
    MOV C, 1    ; Set C to 1
    STOR C, A   ; Write 1 to RAM[A]. C is cleared.
    LOAD A, 0   ; Restore A from RAM[0] (not strictly needed for final halt, but clean for consistent loop exit)
    JMP HALT_SUCCESS ; Program finished successfully

HANDLE_BLANK:
    ; Action for 'BLANK': Write 1, Move Left, Halt (Handles overflow, e.g., 11 -> 100)
    MOV C, 1    ; Set C to 1
    STOR C, A   ; Write 1 to RAM[A]. C is cleared.
    LOAD A, 0   ; Restore A from RAM[0] (redundant, but for consistency)
    SUB A, 1    ; Move tape head left (A = A - 1)
    STOR A, 0   ; Save new A (tape head position) to RAM[0]. A is cleared by this STOR.
    JMP HALT_SUCCESS ; Program finished successfully

HALT_SUCCESS:
    ; Output the final state of the tape (RAM[10] to RAM[14])
    ; This shows the result of the Turing Machine's operation
    MOV C, 10   ; Initialize C with the starting address of the tape
PRINT_TAPE_LOOP:
    LOAD D, C   ; Load content of RAM[C] into Register D
    OUT D       ; Output the symbol
    ADD C, 1    ; Move to the next tape cell address (C = C + 1)
    CMP C, 15   ; Compare C with the address after the last tape cell (RAM[14] + 1)
    JLT PRINT_TAPE_LOOP ; If C is less than 15, continue printing

    ; Output the total loop iterations from the dedicated counters
    OUT "Loop iterations (Counter 1):"
    OUT $
    OUT "Loop iterations (Counter 2):"
    OUT $2
    HLT         ; End of program
`;

        // --- Core Functions ---
        function resetMachine() {
            if (timeoutId) clearTimeout(timeoutId);
            ram.fill(0);
            for (const reg of registerNames) registers[reg] = 0;
            pc = 0;
            compareFlag = 0;
            dedicatedCounter = 0; // Reset dedicated counter 1
            dedicatedCounter2 = 0; // Reset dedicated counter 2

            inputBuffer = inputArea.value.trim().split('\n').map(n => parseInt(n, 10)).filter(n => !isNaN(n));
            outputArea.textContent = ''; // Clear output area on reset
            
            isRunning = false;
            isPaused = false;
            
            parseAndLoadProgram();
            updateUI();
            updateControls();
            setStatus('Idle', 'text-blue-400');
            setError('-');
        }
        
        function parseAndLoadProgram() {
            const code = codeInput.value;
            program = code.split('\n').map((line, index) => {
                const cleanLine = line.split(';')[0].trim(); // Remove comments and trim
                // Normalize commas: replace all commas with spaces to ensure arguments are correctly separated
                const normalizedLine = cleanLine.replace(/,/g, ' '); 

                if (!normalizedLine) return null;

                // Use normalizedLine for matching parts
                const parts = normalizedLine.match(/(".*?"|'.*?'|\S+)/g) || [];
                const [opcode, ...args] = parts;

                return {
                    line: index,
                    opcode: opcode.toUpperCase(),
                    args: args
                };
            }).filter(Boolean); // Remove empty lines

            // Pre-scan for labels
            labelMap = {};
            program.forEach((instr, index) => {
                if (instr.opcode.endsWith(':')) {
                    const label = instr.opcode.slice(0, -1);
                    labelMap[label.toUpperCase()] = index;
                    instr.isLabel = true; // Mark as label to be skipped during execution
                }
            });
            setError('-'); // Clear previous errors
        }

        /**
         * Applies syntax highlighting to the code input by mirroring it to a hidden div.
         */
        function highlightCode() {
            const text = codeInput.value;
            let highlightedHtml = '';

            const lines = text.split('\n');
            const opcodeMap = {
                'MOV': 'opcode-pink', 'ADD': 'opcode-pink', 'SUB': 'opcode-pink',
                'LOAD': 'opcode-orange', 'STOR': 'opcode-orange',
                'INP': 'opcode-pink', 'OUT': 'opcode-pink', 'CMP': 'opcode-pink',
                'JMP': 'opcode-pink', 'JEZ': 'opcode-pink', 'JNE': 'opcode-pink',
                'JGT': 'opcode-pink', 'JLT': 'opcode-pink',
                'INC': 'inc-green', 'INC2': 'inc-green'
            };
            const registerPattern = /^[ABCD]$/i;
            const counterPattern = /^\$[2]?$/; // Matches $ or $2

            lines.forEach(line => {
                let currentLineHtml = '';
                const commentIndex = line.indexOf(';');
                let codePart = line;
                let commentPart = '';

                if (commentIndex !== -1) {
                    codePart = line.substring(0, commentIndex).trim();
                    commentPart = line.substring(commentIndex);
                }

                if (codePart.endsWith(':')) { // It's a label
                    currentLineHtml += `<span class="label-red">${escapeHtml(codePart)}</span>`;
                } else {
                    const parts = codePart.match(/(".*?"|'.*?'|\S+)/g) || [];
                    if (parts.length > 0) {
                        const opcode = parts[0].toUpperCase();
                        const opcodeClass = opcodeMap[opcode] || '';
                        currentLineHtml += `<span class="${opcodeClass}">${escapeHtml(opcode)}</span>`;

                        // Handle arguments
                        for (let i = 1; i < parts.length; i++) {
                            let arg = parts[i];
                            let argHtml = escapeHtml(arg); // Escape HTML for safety

                            // Remove comma for internal processing if present (after initial split)
                            const cleanedArg = arg.replace(/,$/, ''); 

                            // Check if it's a register, counter, or an expression
                            // Regex for expression: e.g., A + 1, B * C, $ - 5
                            if (registerPattern.test(cleanedArg) || counterPattern.test(cleanedArg) || cleanedArg.match(/([ABCD$]+\d*|-?\d+)\s*([+\-*/])\s*([ABCD$]+\d*|-?\d+)/i)) {
                                argHtml = `<span class="arg-green">${argHtml}</span>`;
                            } else if (!isNaN(parseInt(cleanedArg, 10)) && String(parseInt(cleanedArg, 10)) === cleanedArg) {
                                // Simple integer literal (handle negative numbers)
                                argHtml = `<span class="arg-green">${argHtml}</span>`;
                            }
                            
                            // Add a space before the argument if not directly concatenated by a comma in source
                            // This part ensures spaces are added between highlighted tokens correctly.
                            if (i > 0 && !arg.startsWith(',')) {
                                currentLineHtml += ' ';
                            }
                            currentLineHtml += argHtml;
                        }
                    }
                }

                if (commentPart) {
                    currentLineHtml += `<span class="comment-white">${escapeHtml(commentPart)}</span>`;
                }
                highlightedHtml += currentLineHtml + '\n';
            });

            highlightedCodeDiv.innerHTML = highlightedHtml;
            updateLineNumbers(); // Re-update line numbers after highlight
        }

        // Helper function to escape HTML entities for display
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, function(m) { return map[m]; });
        }


        // Helper function to evaluate arithmetic expressions including '$' and '$2'
        function evaluateExpression(expression) {
            expression = String(expression).trim();

            // Check for dedicated counter references
            if (expression === '$') {
                return dedicatedCounter;
            }
            if (expression === '$2') {
                return dedicatedCounter2;
            }

            // Check for pure register name
            if (registerNames.includes(expression.toUpperCase())) {
                return registers[expression.toUpperCase()];
            }

            // Check for simple integer literal (handle negative numbers)
            const num = parseInt(expression, 10);
            if (!isNaN(num) && String(num) === expression) { // Ensure the string is exactly the number
                return num;
            }

            // Handle binary operations: "Operand Operator Operand"
            // Operand: A register name (A, B, C, D), an integer literal (possibly negative), '$', or '$2'
            // Operator: +, -, *, /
            // The regex needs to handle '$' and '$2' as operands.
            const regex = /^\s*([ABCD$]+\d*|-?\d+)\s*([+\-*/])\s*([ABCD$]+\d*|-?\d+)\s*$/i;
            const match = expression.match(regex);

            if (match) {
                const operand1Str = match[1];
                const operator = match[2];
                const operand2Str = match[3];

                let val1;
                if (operand1Str.toUpperCase() === '$') {
                    val1 = dedicatedCounter;
                } else if (operand1Str.toUpperCase() === '$2') { // Handle $2
                    val1 = dedicatedCounter2;
                } else if (registerNames.includes(operand1Str.toUpperCase())) {
                    val1 = registers[operand1Str.toUpperCase()];
                } else {
                    val1 = parseInt(operand1Str, 10);
                }

                let val2;
                if (operand2Str.toUpperCase() === '$') {
                    val2 = dedicatedCounter;
                } else if (operand2Str.toUpperCase() === '$2') { // Handle $2
                    val2 = dedicatedCounter2;
                } else if (registerNames.includes(operand2Str.toUpperCase())) {
                    val2 = registers[operand2Str.toUpperCase()];
                } else {
                    val2 = parseInt(operand2Str, 10);
                }

                if (isNaN(val1) || isNaN(val2)) {
                    setError(`Invalid operand in expression '${expression}': One or both operands are not valid numbers, registers, '$', or '$2'.`);
                    return null;
                }

                switch (operator) {
                    case '+': return val1 + val2;
                    case '-': return val1 - val2;
                    case '*': return val1 * val2;
                    case '/': 
                        if (val2 === 0) throw new Error("Division by zero");
                        return Math.floor(val1 / val2); // Integer division
                    default:
                        // This case should ideally not be reached due to regex, but for safety
                        throw new Error(`Unsupported operator in expression: '${operator}'`);
                }
            }
            
            setError(`Invalid expression format: '${expression}'. Expected 'Operand Operator Operand', a direct value/register, '$', or '$2'.`);
            return null;
        }

        function highlightElement(element, className) {
            if (!element) return;
            element.classList.add(className);
            setTimeout(() => element.classList.remove(className), 500);
        }

        function updateUI() {
            // Update displays
            pcDisplay.textContent = pc;
            flagDisplay.textContent = compareFlag;
            dedicatedCounterDisplay.textContent = dedicatedCounter; // Update dedicated counter 1 display
            dedicatedCounterDisplay2.textContent = dedicatedCounter2; // Update dedicated counter 2 display

            // Update Registers
            registersContainer.innerHTML = '';
            registerNames.forEach(name => {
                const regDiv = document.createElement('div');
                regDiv.className = 'register bg-gray-700 p-2 rounded-lg';
                regDiv.id = `reg-${name}`;
                regDiv.innerHTML = `
                    <div class="text-sm text-gray-400">${name}</div>
                    <div class="text-xl font-bold font-fira">${registers[name]}</div>
                `;
                registersContainer.appendChild(regDiv);
            });
            
            // Update RAM
            ramContainer.innerHTML = '';
            for (let i = 0; i < ram.length; i++) {
                const cell = document.createElement('div');
                cell.className = 'ram-cell w-16 h-16 flex-shrink-0 bg-gray-700 rounded-lg flex flex-col items-center justify-center';
                cell.id = `ram-${i}`;
                cell.innerHTML = `
                    <div class="text-xs text-gray-400">${i}</div>
                    <div class="text-2xl font-bold">${ram[i]}</div>
                `;
                ramContainer.appendChild(cell);
            }
            
            // Update code highlighting (for execution pointer)
            // Remove previous active line highlight
            document.querySelectorAll('#highlighted-code > span.active-instruction').forEach(span => span.classList.remove('active-instruction'));
            const activeLineSpan = highlightedCodeDiv.querySelector(`span:nth-child(${pc + 1})`); // Get the span for the current PC line
            if (activeLineSpan) {
                // To highlight the entire line in the highlighted-code div
                activeLineSpan.classList.add('active-instruction');
            }

            updateLineNumbers();
        }
        
        function setStatus(text, colorClass) {
            statusDisplay.textContent = text;
            statusDisplay.className = `text-lg font-semibold ${colorClass}`;
        }
        
        function setError(text) {
             errorDisplay.textContent = text;
             errorDisplay.title = text;
             if (text !== '-') {
                 setStatus('Error', 'text-red-400');
                 if (timeoutId) clearTimeout(timeoutId);
                 isRunning = false;
                 updateControls();
             }
        }

        function updateControls() {
            runBtn.disabled = isRunning;
            stepBtn.disabled = isRunning;
            pauseBtn.disabled = !isRunning || isPaused;
            codeInput.disabled = isRunning || isPaused; // Re-enable disabling textarea
            
            if (isPaused) {
                pauseBtn.textContent = 'Resume';
                setStatus('Paused', 'text-yellow-400');
            } else {
                pauseBtn.textContent = 'Pause';
            }
        }
        
        function step() {
            if (pc >= program.length) {
                setStatus('Halted', 'text-purple-400');
                isRunning = false;
                updateControls();
                return false;
            }

            const instr = program[pc];
            if (!instr || instr.isLabel) {
                pc++;
                updateUI(); // Update UI to reflect PC increment even for labels
                return true; // Skip labels/empty lines
            }
            
            let pcShouldIncrement = true;
            const [op, args] = [instr.opcode, instr.args];

            try {
                switch (op) {
                    case 'MOV': {
                        if (args.length !== 2) throw new Error("MOV needs 2 args");
                        const destReg = args[0].toUpperCase();
                        if (!registerNames.includes(destReg)) throw new Error(`Invalid register: ${args[0]}`);
                        const val = evaluateExpression(args[1]);
                        if(val === null) return false;
                        registers[destReg] = val;
                        highlightElement(document.getElementById(`reg-${destReg}`), 'highlight-update');
                        break;
                    }
                    case 'ADD':
                    case 'SUB': {
                        if (args.length !== 2) throw new Error(`${op} needs 2 args`);
                        const destReg = args[0].toUpperCase();
                        if (!registerNames.includes(destReg)) throw new Error(`Invalid register: ${args[0]}`);
                        const val = evaluateExpression(args[1]);
                        if(val === null) return false;
                        registers[destReg] += (op === 'ADD' ? val : -val);
                        highlightElement(document.getElementById(`reg-${destReg}`), 'highlight-update');
                        break;
                    }
                    case 'LOAD': {
                        if (args.length !== 2) throw new Error("LOAD needs 2 args");
                        const destReg = args[0].toUpperCase();
                        if (!registerNames.includes(destReg)) throw new Error(`Invalid register: ${args[0]}`);
                        const addr = evaluateExpression(args[1]);
                        if(addr === null || addr < 0 || addr >= ram.length) throw new Error(`Invalid address: ${addr}`);
                        registers[destReg] = ram[addr];
                        highlightElement(document.getElementById(`reg-${destReg}`), 'highlight-update');
                        highlightElement(document.getElementById(`ram-${addr}`), 'highlight-read');
                        break;
                    }
                     case 'STOR': {
                        if (args.length !== 2) throw new Error("STOR needs 2 args");
                        const srcReg = args[0].toUpperCase();
                        if (!registerNames.includes(srcReg)) throw new Error(`Invalid register: ${args[0]}`);
                        const addr = evaluateExpression(args[1]);
                        if(addr === null || addr < 0 || addr >= ram.length) throw new Error(`Invalid address: ${addr}`);
                        ram[addr] = registers[srcReg];
                        highlightElement(document.getElementById(`ram-${addr}`), 'highlight-write');
                        
                        registers[srcReg] = 0;
                        highlightElement(document.getElementById(`reg-${srcReg}`), 'highlight-update');
                        break;
                    }
                    case 'INP': {
                        if (args.length !== 1) throw new Error("INP needs 1 arg");
                        const destReg = args[0].toUpperCase();
                        if (!registerNames.includes(destReg)) throw new Error(`Invalid register: ${args[0]}`);
                        if (inputBuffer.length === 0) {
                            setStatus('Awaiting Input', 'text-cyan-400');
                            isRunning = false;
                            return false;
                        }
                        registers[destReg] = inputBuffer.shift();
                        inputArea.value = inputBuffer.join('\n');
                        highlightElement(document.getElementById(`reg-${destReg}`), 'highlight-update');
                        break;
                    }
                    case 'OUT': {
                        if (args.length !== 1) throw new Error("OUT needs 1 arg");
                        const val = evaluateExpression(args[0]);
                        if(val === null) return false;
                        outputArea.textContent += val + '\n';
                        outputArea.scrollTop = outputArea.scrollHeight;
                        break;
                    }
                    case 'CMP': {
                        if (args.length !== 2) throw new Error("CMP needs 2 args");
                        const val1 = evaluateExpression(args[0]);
                        const val2 = evaluateExpression(args[1]);
                        if(val1 === null || val2 === null) return false;
                        const diff = val1 - val2;
                        compareFlag = Math.sign(diff);
                        break;
                    }
                    case 'INC': {
                        if (args.length !== 0) throw new Error("INC takes no args");
                        dedicatedCounter++;
                        highlightElement(dedicatedCounterDisplay, 'highlight-update');
                        break;
                    }
                    case 'INC2': {
                        if (args.length !== 0) throw new Error("INC2 takes no args");
                        dedicatedCounter2++;
                        highlightElement(dedicatedCounterDisplay2, 'highlight-update');
                        break;
                    }
                    case 'JMP':
                    case 'JEZ':
                    case 'JNE':
                    case 'JGT':
                    case 'JLT':
                    {
                        if (args.length !== 1) throw new Error(`${op} needs 1 arg`);
                        const label = args[0].toUpperCase();
                        if (labelMap[label] === undefined) throw new Error(`Label not found: ${args[0]}`);
                        
                        let shouldJump = false;
                        if(op === 'JMP') shouldJump = true;
                        if(op === 'JEZ' && compareFlag === 0) shouldJump = true;
                        if(op === 'JNE' && compareFlag !== 0) shouldJump = true;
                        if(op === 'JGT' && compareFlag > 0) shouldJump = true;
                        if(op === 'JLT' && compareFlag < 0) shouldJump = true;

                        if (shouldJump) {
                            pc = labelMap[label];
                            pcShouldIncrement = false;
                        }
                        break;
                    }
                    case 'HLT':
                        setStatus('Halted', 'text-purple-400');
                        isRunning = false;
                        if (timeoutId) clearTimeout(timeoutId);
                        updateControls();
                        return false;
                    default:
                        throw new Error(`Unknown instruction: ${op}`);
                }
            } catch (e) {
                setError(`Line ${instr.line + 1}: ${e.message}`);
                return false;
            }
            
            if (pcShouldIncrement) pc++;
            updateUI();
            return true;
        }

        function runLoop() {
            if (!isRunning || isPaused) return;
            if (step()) {
                if (executionSpeed > 0) {
                    timeoutId = setTimeout(runLoop, executionSpeed);
                } else {
                    let batchSize = 0;
                    while (isRunning && !isPaused && batchSize < 1000 && step()) {
                        batchSize++;
                    }
                     if(isRunning && !isPaused) {
                         timeoutId = setTimeout(runLoop, 0);
                     }
                }
            } else {
                updateControls();
            }
        }

        function startExecution() {
            resetMachine();
            if(program.length === 0) return;
            isRunning = true;
            isPaused = false;
            setStatus('Running', 'text-green-400');
            updateControls();
            runLoop();
        }

        function updateLineNumbers() {
            const lineCount = codeInput.value.split('\n').length;
            let lineNumHtml = '';
            for(let i = 1; i <= lineCount; i++) {
                lineNumHtml += `<span>${i}</span><br>`;
            }
            lineNumbersDiv.innerHTML = lineNumHtml;
            lineNumbersDiv.scrollTop = codeInput.scrollTop;
            highlightedCodeDiv.scrollTop = codeInput.scrollTop; // Sync scroll for highlighted div
        }
        
        // --- Event Listeners ---
        runBtn.addEventListener('click', startExecution);
        stepBtn.addEventListener('click', () => {
            if (!isRunning) {
                resetMachine();
                isRunning = true;
                isPaused = true;
                setStatus('Stepping', 'text-yellow-400');
            }
            step();
            updateControls();
        });
        pauseBtn.addEventListener('click', () => {
             if (isPaused) {
                 isPaused = false;
                 setStatus('Running', 'text-green-400');
                 runLoop();
             } else {
                 isPaused = true;
                 if(timeoutId) clearTimeout(timeoutId);
             }
             updateControls();
        });
        resetBtn.addEventListener('click', () => {
            resetMachine();
            outputArea.textContent = '';
        });
        speedSlider.addEventListener('input', (e) => {
            executionSpeed = 1000 - parseInt(e.target.value, 10);
        });
        // Listen for input on the textarea to trigger highlighting and line number updates
        codeInput.addEventListener('input', highlightCode);
        // Sync scrolling of all three elements
        codeInput.addEventListener('scroll', () => {
            lineNumbersDiv.scrollTop = codeInput.scrollTop;
            highlightedCodeDiv.scrollTop = codeInput.scrollTop;
        });
        loadExampleBtn.addEventListener('click', (e) => {
            e.preventDefault();
            codeInput.value = EXAMPLE_PROGRAM;
            highlightCode(); // Apply highlighting immediately after loading example
            resetMachine();
        });

        // --- Info Modal Event Listeners ---
        infoBtn.addEventListener('click', () => {
            infoModal.classList.add('open');
        });

        closeModalBtn.addEventListener('click', () => {
            infoModal.classList.remove('open');
        });

        infoModal.addEventListener('click', (e) => {
            if (e.target === infoModal) { // Close if clicked outside modal content
                infoModal.classList.remove('open');
            }
        });

        // --- Initial Setup ---
        codeInput.value = EXAMPLE_PROGRAM; // Set initial content
        highlightCode(); // Apply initial highlighting
        resetMachine();
    });
    </script>
</body>
</html>
