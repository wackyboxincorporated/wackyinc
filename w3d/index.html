<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>w3D 0.6a - Stacking & Skies (Optimized & Fixed)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        :root {
            --primary-color: #0f0;
            --bg-color: #000;
            --sidebar-bg: rgba(0, 20, 0, 0.85);
            --border-color: #0f0;
            --highlight-color: #ff0;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--primary-color);
            font-family: 'VT323', monospace;
            cursor: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: var(--primary-color);
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
            pointer-events: none;
            z-index: 100;
        }
        #sidebar {
            position: absolute;
            top: 0;
            left: 0;
            width: 250px;
            height: 100%;
            background: var(--sidebar-bg);
            border-right: 2px solid var(--border-color);
            box-shadow: 5px 0 15px rgba(0, 255, 0, 0.2);
            transition: transform 0.3s ease-in-out;
            transform: translateX(0);
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            cursor: auto;
        }
        #sidebar.collapsed {
            transform: translateX(-100%);
        }
        #sidebar-toggle {
            position: absolute;
            top: 15px;
            left: 265px;
            width: 30px;
            height: 40px;
            background: var(--sidebar-bg);
            border: 2px solid var(--border-color);
            border-left: none;
            border-top-right-radius: 5px;
            border-bottom-right-radius: 5px;
            color: var(--primary-color);
            font-size: 24px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: left 0.3s ease-in-out;
        }
        #sidebar.collapsed + #sidebar-toggle {
            left: 0;
        }
        .sidebar-section {
            border: 1px solid var(--border-color);
            padding: 10px;
        }
        .sidebar-section h3 {
            margin: 0 0 10px 0;
            text-shadow: 0 0 5px var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        .btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--primary-color);
            padding: 8px;
            font-family: 'VT323', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }
        .btn:hover, .btn.active {
            background: var(--primary-color);
            color: var(--bg-color);
            text-shadow: 0 0 5px var(--bg-color);
        }
        .control-container {
            display: flex;
            flex-direction: column;
            margin-top: 10px;
        }
         .control-container.row {
            flex-direction: row;
            align-items: center;
        }
        .control-container label {
            white-space: nowrap;
            margin-right: 10px;
            align-self: flex-start;
            margin-bottom: 5px;
        }
         .control-container.row label {
             margin-bottom: 0;
         }
        .control-container input[type="checkbox"] {
            margin-right: 10px;
            appearance: none;
            width: 16px;
            height: 16px;
            border: 1px solid var(--border-color);
            position: relative;
            cursor: pointer;
        }
        .control-container input[type="checkbox"]:checked::before {
            content: 'X';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--primary-color);
            font-size: 14px;
        }
        select, input[type="color"], input[type="file"], input[type="number"] {
            width: 100%;
            background: transparent;
            color: var(--primary-color);
            border: 1px solid var(--border-color);
            font-family: 'VT323', monospace;
            font-size: 16px;
            box-sizing: border-box;
            padding: 4px;
        }
        /* Hide number input spinners */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
        input[type=number] {
            -moz-appearance: textfield;
        }
        input[type="file"] {
            padding: 0;
        }
        input::file-selector-button {
            background: transparent;
            border: none;
            border-right: 1px solid var(--border-color);
            color: var(--primary-color);
            padding: 4px 8px;
            font-family: 'VT323', monospace;
            font-size: 16px;
            cursor: pointer;
        }
        select option {
            background: var(--bg-color);
        }
        input[type="color"] {
             height: 30px;
             padding: 2px;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
        }

        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
        }
        input[type=range]::-webkit-slider-runnable-track {
            background: #050;
            height: 4px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            margin-top: -6px;
            background-color: var(--primary-color);
            height: 16px;
            width: 8px;
            border: 1px solid var(--border-color);
        }
        .btn-full {
            width: 100%;
            margin-top: 10px;
            background: #500;
            border-color: #f00;
            color: #f00;
        }
        .btn-full:hover {
            background: #f00;
            color: #000;
        }
    </style>
</head>
<body>

    <div id="sidebar">
        <div class="sidebar-section">
            <h3>Shapes</h3>
            <div class="btn-grid">
                <button class="btn" id="btn-sphere">Sphere</button>
                <button class="btn" id="btn-cube">Cube</button>
                <button class="btn" id="btn-cylinder">Cylinder</button>
                <button class="btn" id="btn-pyramid">Pyramid</button>
            </div>
            <div class="control-container">
                <label for="size-slider">Size</label>
                <input type="range" id="size-slider" min="0.2" max="5" step="0.1" value="1.0">
            </div>
             <div class="control-container">
                <label for="material-select">Material</label>
                <select id="material-select">
                    <option value="0">Solid Color</option>
                    <option value="1">Glass</option>
                    <option value="2">Metal</option>
                    <option value="3">Pure Mirror</option>
                </select>
            </div>
            <div class="control-container" id="shape-color-container">
                <label for="shape-color-picker">Color</label>
                <input type="color" id="shape-color-picker" value="#00ff00">
            </div>
            <div class="control-container row">
                <input type="checkbox" id="check-physics" checked>
                <label for="check-physics">Physics</label>
            </div>
            <div class="control-container row">
                <input type="checkbox" id="check-gravity" checked>
                <label for="check-gravity">Gravity</label>
            </div>
             <div class="control-container row">
                <input type="checkbox" id="check-emissive">
                <label for="check-emissive">Emission</label>
            </div>
        </div>
        
        <div class="sidebar-section">
            <h3>Animation</h3>
            <div class="control-container">
                 <label for="anim-select">Type</label>
                <select id="anim-select">
                    <option value="0">None</option>
                    <option value="1">Spin (H)</option>
                    <option value="2">Orbit (H)</option>
                    <option value="3">Spin (V)</option>
                    <option value="4">Orbit (V)</option>
                    <option value="5">Spin (3D)</option>
                    <option value="6">Orbit (3D)</option>
                </select>
            </div>
        </div>

        <div class="sidebar-section">
            <h3>Lights</h3>
            <div class="btn-grid">
                 <button class="btn" id="btn-pointlight">Point Light</button>
            </div>
             <div class="control-container">
                <label for="light-color-picker">Light Color</label>
                <input type="color" id="light-color-picker" value="#ffffff">
            </div>
            <div class="control-container row">
                <input type="checkbox" id="check-playerlight" checked>
                <label for="check-playerlight">Headlamp (F)</label>
            </div>
        </div>

        <div class="sidebar-section">
            <h3>Sky</h3>
            <div class="control-container">
                <label for="sky-type-select">Sky Type</label>
                <select id="sky-type-select">
                    <option value="0">Solid Color</option>
                    <option value="1">Skybox Image</option>
                </select>
            </div>
            <div class="control-container" id="sky-color-container">
                <label for="sky-color-picker">Sky Color</label>
                <input type="color" id="sky-color-picker" value="#000000">
            </div>
            <div class="control-container" id="sky-image-container" style="display: none;">
                <label for="sky-image-upload">Skybox Image</label>
                <input type="file" id="sky-image-upload" accept="image/*">
            </div>
        </div>

        <div class="sidebar-section">
            <h3>Scene</h3>
             <div class="control-container">
                <label for="res-slider">Resolution Scale</label>
                <input type="range" id="res-slider" min="0.025" max="1.5" step="0.025" value="1.0">
            </div>
            <div class="control-container">
                <label for="dist-slider">Render Distance</label>
                <input type="range" id="dist-slider" min="20" max="500" step="1" value="200">
            </div>
             <div class="control-container">
                <label for="steps-slider">Raymarching Steps</label>
                <input type="range" id="steps-slider" min="32" max="255" step="1" value="128">
            </div>
             <div class="control-container">
                <label for="shadow-slider">Shadow Quality</label>
                <input type="range" id="shadow-slider" min="8" max="64" step="1" value="48">
            </div>
             <div class="control-container">
                <label for="shadow-soft-slider">Shadow Softness</label>
                <input type="range" id="shadow-soft-slider" min="1.0" max="32.0" step="0.5" value="8.0">
            </div>
            <div class="control-container row">
                <input type="checkbox" id="check-perf" checked>
                <label for="check-perf">Perf. Optimizations</label>
            </div>
            <div class="control-container row">
                <input type="checkbox" id="check-autofps">
                <label for="check-autofps">Auto FPS Target</label>
            </div>
             <div class="control-container">
                <label for="input-targetfps">Target FPS</label>
                <input type="number" id="input-targetfps" value="60" min="15" max="240">
            </div>
            <button class="btn btn-full" id="btn-delete-all">Delete All Shapes</button>
        </div>
    </div>
    <div id="sidebar-toggle">&lt;</div>

    <div id="crosshair">+</div>
    <canvas id="glCanvas"></canvas>

    <script id="vertex-shader" type="notjs">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="fragment-shader" type="notjs">
        precision highp float;

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec3 u_cameraPos;
        uniform vec3 u_cameraFront;
        uniform vec3 u_cameraUp;
        
        // --- Quality & Performance Uniforms ---
        uniform float u_renderDistance;
        uniform int u_raySteps;
        uniform int u_shadowSteps;
        uniform float u_shadowSoftness;
        uniform bool u_perfMode;

        // --- Sky Uniforms ---
        uniform int u_skyType;
        uniform vec3 u_skyColor;
        uniform sampler2D u_skybox;

        const int MAX_SHAPES = 64;
        const int MAX_LIGHTS = 8;
        const float HIT_DIST = 0.001;
        const float PI = 3.14159265359;

        // --- Type Constants (must match JS) ---
        const int SHAPE_SPHERE = 1; const int SHAPE_BOX = 2; const int SHAPE_CYLINDER = 3; const int SHAPE_PYRAMID = 4;
        const int ANIM_SPIN_H = 1; const int ANIM_ORBIT_H = 2; const int ANIM_SPIN_V = 3; const int ANIM_ORBIT_V = 4; const int ANIM_SPIN_3D = 5; const int ANIM_ORBIT_3D = 6;
        const int MATERIAL_SOLID = 0; const int MATERIAL_GLASS = 1; const int MATERIAL_METAL = 2; const int MATERIAL_MIRROR = 3;
        const int SKY_SOLID = 0; const int SKY_IMAGE = 1;

        // --- Scene Data ---
        uniform int u_shapeCount;
        uniform int u_shapes_type[MAX_SHAPES];
        uniform vec3 u_shapes_pos[MAX_SHAPES];
        uniform vec4 u_shapes_param[MAX_SHAPES];
        uniform vec4 u_shapes_color[MAX_SHAPES];
        uniform int u_shapes_anim[MAX_SHAPES];
        uniform int u_shapes_material[MAX_SHAPES];
        uniform int u_lightCount;
        uniform vec3 u_lights_pos[MAX_LIGHTS];
        uniform vec3 u_lights_color[MAX_LIGHTS];
        uniform bool u_playerLightActive;
        uniform vec3 u_playerLightPos;

        // --- Preview Data ---
        uniform bool u_preview_active;
        uniform int u_preview_type;
        uniform vec3 u_preview_pos;
        uniform vec4 u_preview_param;

        struct HitInfo {
            float dist;
            vec3 color;
            float emissive;
            int material;
            bool hit;
        };
        
        mat2 rot(float a) { float s=sin(a),c=cos(a); return mat2(c,-s,s,c); }
        float sdSphere(vec3 p,float s){return length(p)-s;}
        float sdBox(vec3 p,vec3 b){vec3 q=abs(p)-b;return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);}
        float sdCylinder(vec3 p,float h,float r){vec2 d=abs(vec2(length(p.xz),p.y))-vec2(r,h);return min(max(d.x,d.y),0.)+length(max(d,0.));}
        float sdPyramid(vec3 p,float h,float w){p.y=-p.y+h*0.5;p.xz=abs(p.xz);float m=h/(w*0.5);return max((length(p.xz)-w*0.5),p.y+m*max(p.x,p.z)-h);}

        float getShapeDist(int type, vec3 p, vec4 param) {
            if (type == SHAPE_SPHERE) return sdSphere(p, param.x);
            if (type == SHAPE_BOX) return sdBox(p, param.xyz);
            if (type == SHAPE_CYLINDER) return sdCylinder(p, param.y, param.x);
            if (type == SHAPE_PYRAMID) return sdPyramid(p, param.x, param.x);
            return u_renderDistance;
        }
        
       HitInfo map_the_world(vec3 p) {
            HitInfo res;
            res.dist = p.y;
            vec2 check_uv = mod(floor(p.xz * 0.5), 2.0);
            res.color = (check_uv.x == check_uv.y) ? vec3(0.8, 0.1, 0.1) : vec3(0.9);
            res.emissive = 0.0;
            res.material = MATERIAL_SOLID;
            res.hit = false;

            for (int i = 0; i < MAX_SHAPES; i++) {
                if (i >= u_shapeCount) break;
                vec3 visual_pos = u_shapes_pos[i];
                vec3 p_local = p;
                int anim = u_shapes_anim[i];
                float t = u_time * 2.0;
                if (anim == ANIM_ORBIT_H) { visual_pos.xz += vec2(cos(t*0.5), sin(t*0.5)) * 3.0; }
                if (anim == ANIM_ORBIT_V) { visual_pos.xy += vec2(cos(t*0.5), sin(t*0.5)) * 3.0; }
                if (anim == ANIM_ORBIT_3D) { visual_pos.xz += vec2(cos(t*0.5), sin(t*0.5)) * 3.0; visual_pos.xy += vec2(cos(t*0.35), sin(t*0.35)) * 3.0; }
                p_local -= visual_pos;
                if (anim == ANIM_SPIN_H) { p_local.xz *= rot(t); }
                if (anim == ANIM_SPIN_V) { p_local.xy *= rot(t); }
                if (anim == ANIM_SPIN_3D) { p_local.xz *= rot(t); p_local.xy *= rot(t * 0.7); }
                float d = getShapeDist(u_shapes_type[i], p_local, u_shapes_param[i]);
                if (d < res.dist) {
                    res.dist = d; res.color = u_shapes_color[i].rgb; res.emissive = u_shapes_color[i].a; res.material = u_shapes_material[i];
                }
            }
            return res;
        }

        vec3 get_normal(vec3 p) {
            vec2 e=vec2(HIT_DIST,0.);return normalize(vec3(map_the_world(p+e.xyy).dist-map_the_world(p-e.xyy).dist,map_the_world(p+e.yxy).dist-map_the_world(p-e.yxy).dist,map_the_world(p+e.yyx).dist-map_the_world(p-e.yyx).dist));
        }

        float get_shadow(vec3 p, vec3 lightDir, float maxDist, float dist_from_cam) {
            int current_shadow_steps = u_shadowSteps;
            if (u_perfMode) {
                // Reduce shadow quality exponentially with distance
                float shadow_lod = smoothstep(25.0, 150.0, dist_from_cam);
                current_shadow_steps = int(mix(float(u_shadowSteps), 8.0, shadow_lod));
            }

            float shadowDist=HIT_DIST*4.,shadowIntensity=1.;
            for(int i=0;i<64;i++){
                if(i>=current_shadow_steps)break;
                vec3 sp=p+lightDir*shadowDist;
                float d=map_the_world(sp).dist;
                if(d<HIT_DIST)return .1;
                shadowIntensity=min(shadowIntensity,u_shadowSoftness*d/shadowDist);
                shadowDist+=d;
                if(shadowDist>maxDist)break;
            }
            return clamp(shadowIntensity,.1,1.);
        }

        vec3 get_lighting(vec3 p, vec3 normal) {
            float dist_from_cam = length(p - u_cameraPos);
            vec3 lighting=vec3(.15);
            for(int i=0;i<MAX_LIGHTS;i++){
                if(i>=u_lightCount)break;
                vec3 lightPos=u_lights_pos[i];
                vec3 lightDir=normalize(lightPos-p);
                float distToLight=length(lightPos-p);
                float diffuse=max(dot(normal,lightDir),0.);
                float shadow=get_shadow(p+normal*HIT_DIST*2.,lightDir,distToLight, dist_from_cam);
                lighting+=u_lights_color[i]*diffuse*shadow;
            }
            if(u_playerLightActive){
                vec3 lightDir=normalize(u_playerLightPos-p);
                float distToLight=length(u_playerLightPos-p);
                float attenuation=1./(1.+.1*distToLight+.02*distToLight*distToLight);
                float diffuse=max(dot(normal,lightDir),0.);
                float shadow=get_shadow(p+normal*HIT_DIST*2.,lightDir,distToLight, dist_from_cam);
                lighting+=vec3(.8,.8,1.)*diffuse*shadow*attenuation*2.;
            }
            return lighting;
        }
        
        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;
            vec3 cameraDir=normalize(u_cameraFront),cameraRight=normalize(cross(cameraDir,u_cameraUp)),newCameraUp=cross(cameraRight,cameraDir),initialRayDir=normalize(cameraDir+cameraRight*uv.x+newCameraUp*uv.y);
            vec3 final_color=vec3(0.),color_mask=vec3(1.),current_ray_pos=u_cameraPos,current_ray_dir=initialRayDir;

            float foveation_factor = 0.0;
            if (u_perfMode) {
                foveation_factor = smoothstep(0.8, 1.5, length(uv));
            }

            for(int i=0;i<4;i++){
                int current_steps = u_raySteps;
                if (u_perfMode) {
                    if (i > 0) current_steps = int(max(32.0, float(u_raySteps) / 2.0)); // <<< FIX WAS HERE
                    current_steps = int(mix(float(current_steps), float(current_steps) * 0.4, foveation_factor));
                }

                float total_dist=0.;HitInfo hit_info;hit_info.hit=false;
                for(int j=0;j<255;j++){
                    if(j>=current_steps)break;
                    vec3 p=current_ray_pos+current_ray_dir*total_dist;
                    hit_info=map_the_world(p);
                    if(hit_info.dist<HIT_DIST){
                        hit_info.hit=true;
                        break;
                    }
                    total_dist+=hit_info.dist;
                    if(total_dist>u_renderDistance)break;
                }

                if(hit_info.hit){
                    vec3 hit_point=current_ray_pos+current_ray_dir*total_dist,normal=get_normal(hit_point),bias=normal*HIT_DIST*2.;
                    if(hit_info.emissive>.5){final_color+=hit_info.color*color_mask;break;}
                    if(hit_info.material==MATERIAL_SOLID){final_color+=hit_info.color*get_lighting(hit_point,normal)*color_mask;break;}
                    if(hit_info.material==MATERIAL_METAL){current_ray_dir=reflect(current_ray_dir,normal);current_ray_pos=hit_point+bias;color_mask*=hit_info.color;continue;}
                    if(hit_info.material==MATERIAL_MIRROR){float edge=1.-abs(dot(normal,current_ray_dir));edge=smoothstep(0.,.3,edge);final_color+=vec3(.2,1.,.4)*edge*color_mask;current_ray_dir=reflect(current_ray_dir,normal);current_ray_pos=hit_point+bias;color_mask*=.95;continue;}
                    if(hit_info.material==MATERIAL_GLASS){bool outside=dot(current_ray_dir,normal)<0.;vec3 out_normal=outside?normal:-normal;float eta=outside?(1./1.5):1.5;vec3 refracted_dir=refract(current_ray_dir,out_normal,eta);if(dot(refracted_dir,refracted_dir)==0.){current_ray_dir=reflect(current_ray_dir,out_normal);current_ray_pos=hit_point+(out_normal*HIT_DIST*2.);}else{current_ray_dir=refracted_dir;current_ray_pos=hit_point-(out_normal*HIT_DIST*2.);}color_mask*=hit_info.color*.8+vec3(.2);continue;}
                }else{
                    vec3 sky_color;
                    if (u_skyType == SKY_SOLID) {
                        sky_color = u_skyColor;
                    } else if (u_skyType == SKY_IMAGE) {
                        vec3 rd = normalize(current_ray_dir);
                        vec2 sky_uv = vec2(atan(rd.x, rd.z) / (2.0 * PI) + 0.5, acos(rd.y) / PI);
                        sky_color = texture2D(u_skybox, sky_uv).rgb;
                    }
                    final_color += sky_color * color_mask;
                    break;
                }
            }
            if(u_preview_active){float preview_dist_to_cam=length(u_preview_pos-u_cameraPos);float preview_sdf=getShapeDist(u_preview_type,(u_cameraPos+initialRayDir*preview_dist_to_cam)-u_preview_pos,u_preview_param);if(preview_sdf<.01){final_color=mix(final_color,vec3(.5,1.,.5),.5);}}
            final_color=pow(final_color,vec3(.4545));final_color=floor(final_color*16.)/16.;gl_FragColor=vec4(final_color,1.);
        }
    </script>


    <script>
        // --- Main Setup ---
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) alert('WebGL not supported!');
        const program = createProgram(gl, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertex-shader').textContent), createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fragment-shader').textContent));
        gl.useProgram(program);

        // --- GL Locations ---
        const locs = {
            pos: gl.getAttribLocation(program, "a_position"), res: gl.getUniformLocation(program, "u_resolution"), time: gl.getUniformLocation(program, "u_time"), camPos: gl.getUniformLocation(program, "u_cameraPos"), camFront: gl.getUniformLocation(program, "u_cameraFront"), camUp: gl.getUniformLocation(program, "u_cameraUp"),
            shapeCount: gl.getUniformLocation(program, "u_shapeCount"), shapes_type: gl.getUniformLocation(program, "u_shapes_type"), shapes_pos: gl.getUniformLocation(program, "u_shapes_pos"), shapes_param: gl.getUniformLocation(program, "u_shapes_param"), shapes_color: gl.getUniformLocation(program, "u_shapes_color"), shapes_anim: gl.getUniformLocation(program, "u_shapes_anim"), shapes_material: gl.getUniformLocation(program, "u_shapes_material"),
            lightCount: gl.getUniformLocation(program, "u_lightCount"), lights_pos: gl.getUniformLocation(program, "u_lights_pos"), lights_color: gl.getUniformLocation(program, "u_lights_color"),
            playerLightActive: gl.getUniformLocation(program, "u_playerLightActive"), playerLightPos: gl.getUniformLocation(program, "u_playerLightPos"),
            preview_active: gl.getUniformLocation(program, "u_preview_active"), preview_type: gl.getUniformLocation(program, "u_preview_type"), preview_pos: gl.getUniformLocation(program, "u_preview_pos"), preview_param: gl.getUniformLocation(program, "u_preview_param"),
            renderDistance: gl.getUniformLocation(program, "u_renderDistance"), raySteps: gl.getUniformLocation(program, "u_raySteps"), shadowSteps: gl.getUniformLocation(program, "u_shadowSteps"), shadowSoftness: gl.getUniformLocation(program, "u_shadowSoftness"),
            perfMode: gl.getUniformLocation(program, "u_perfMode"),
            skyType: gl.getUniformLocation(program, "u_skyType"), skyColor: gl.getUniformLocation(program, "u_skyColor"), skybox: gl.getUniformLocation(program, "u_skybox"),
        };

        // --- Scene & State ---
        const MAX_SHAPES = 64; const MAX_LIGHTS = 32;
        let scene = { shapes: [], lights: [] };
        let placementMode = { active: false, type: null, object: null };
        let previewShape = { active: false, type: 0, pos: [0,0,0], param: [0,0,0,0] };
        let playerLightOn = true;
        let skyState = { type: 0, color: [0.0, 0.0, 0.0], texture: null };
        
        const SHAPE_TYPE = { SPHERE: 1, BOX: 2, CYLINDER: 3, PYRAMID: 4 };
        const ANIM_TYPE = { NONE: 0, SPIN_H: 1, ORBIT_H: 2, SPIN_V: 3, ORBIT_V: 4, SPIN_3D: 5, ORBIT_3D: 6 };
        const MATERIAL_TYPE = { SOLID: 0, GLASS: 1, METAL: 2, MIRROR: 3 };
        const SKY_TYPE = { SOLID: 0, IMAGE: 1 };

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

        // --- Camera and Input ---
        let cameraPos = [0, 2, -10], cameraFront = [0, 0, 1], cameraUp = [0, 1, 0];
        let yaw = 90, pitch = 0;
        const keysPressed = {}; let pointerLocked = false;

        // --- Physics ---
        const GRAVITY = -9.8; const groundLevel = 0.0; const SOLVER_ITERATIONS = 8;

        // --- FPS Management ---
        const frameTimes = [];
        let lastFpsUpdateTime = 0;
        const FPS_UPDATE_INTERVAL = 0.25; // in seconds
        
        // --- Vector Math ---
        const vec3 = { add: (a, b) => [a[0] + b[0], a[1] + b[1], a[2] + b[2]], subtract: (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2]], scale: (a, s) => [a[0] * s, a[1] * s, a[2] * s], length: (a) => Math.sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2]), normalize: (a) => { const l = vec3.length(a); return l > 0 ? vec3.scale(a, 1 / l) : [0,0,0]; }, cross: (a, b) => [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]], dot: (a, b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2] };
        const degToRad = (d) => d * Math.PI / 180;

        // --- UI Elements ---
        const ui = {
            sidebar: document.getElementById('sidebar'), toggle: document.getElementById('sidebar-toggle'),
            buttons: { sphere: document.getElementById('btn-sphere'), cube: document.getElementById('btn-cube'), cylinder: document.getElementById('btn-cylinder'), pyramid: document.getElementById('btn-pyramid'), pointlight: document.getElementById('btn-pointlight'), deleteAll: document.getElementById('btn-delete-all') },
            checkboxes: { physics: document.getElementById('check-physics'), gravity: document.getElementById('check-gravity'), emissive: document.getElementById('check-emissive'), playerLight: document.getElementById('check-playerlight'), perf: document.getElementById('check-perf'), autoFps: document.getElementById('check-autofps') },
            sliders: { size: document.getElementById('size-slider'), resolution: document.getElementById('res-slider'), distance: document.getElementById('dist-slider'), steps: document.getElementById('steps-slider'), shadow: document.getElementById('shadow-slider'), shadowSoft: document.getElementById('shadow-soft-slider') },
            selects: { anim: document.getElementById('anim-select'), material: document.getElementById('material-select'), skyType: document.getElementById('sky-type-select') },
            pickers: { shape: document.getElementById('shape-color-picker'), light: document.getElementById('light-color-picker'), sky: document.getElementById('sky-color-picker') },
            inputs: { skyImage: document.getElementById('sky-image-upload'), targetFps: document.getElementById('input-targetfps') },
            containers: { shapeColor: document.getElementById('shape-color-container'), skyColor: document.getElementById('sky-color-container'), skyImage: document.getElementById('sky-image-container') }
        };

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [ parseInt(result[1], 16) / 255.0, parseInt(result[2], 16) / 255.0, parseInt(result[3], 16) / 255.0 ] : [1, 0, 1];
        }

        function setupUI() {
            ui.toggle.addEventListener('click', () => ui.sidebar.classList.toggle('collapsed'));
            const placementButtons = [ { el: ui.buttons.sphere, type: 'shape', object: 'sphere' }, { el: ui.buttons.cube, type: 'shape', object: 'cube' }, { el: ui.buttons.cylinder, type: 'shape', object: 'cylinder' }, { el: ui.buttons.pyramid, type: 'shape', object: 'pyramid' }, { el: ui.buttons.pointlight, type: 'light', object: 'pointlight' } ];
            placementButtons.forEach(b => {
                b.el.addEventListener('click', () => {
                    const wasActive = b.el.classList.contains('active');
                    document.querySelectorAll('.btn.active').forEach(btn => btn.classList.remove('active'));
                    if (wasActive) { placementMode.active = false; previewShape.active = false; canvas.requestPointerLock(); } 
                    else { b.el.classList.add('active'); placementMode.active = true; placementMode.type = b.type; placementMode.object = b.object; previewShape.active = true; if (pointerLocked) document.exitPointerLock(); }
                });
            });
            ui.buttons.deleteAll.addEventListener('click', () => { scene.shapes = []; scene.lights = []; });
            ui.checkboxes.playerLight.addEventListener('change', () => { playerLightOn = ui.checkboxes.playerLight.checked; });
            ui.selects.material.addEventListener('change', () => { ui.containers.shapeColor.style.display = ui.selects.material.value == MATERIAL_TYPE.MIRROR ? 'none' : 'flex'; });
            // Sky UI
            ui.selects.skyType.addEventListener('change', (e) => {
                skyState.type = parseInt(e.target.value);
                ui.containers.skyColor.style.display = (skyState.type === SKY_TYPE.SOLID) ? 'flex' : 'none';
                ui.containers.skyImage.style.display = (skyState.type === SKY_TYPE.IMAGE) ? 'flex' : 'none';
            });
            ui.pickers.sky.addEventListener('input', (e) => { skyState.color = hexToRgb(e.target.value); });
            ui.inputs.skyImage.addEventListener('change', (e) => {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            skyState.texture = createTextureFromImage(img);
                            skyState.type = SKY_TYPE.IMAGE;
                            ui.selects.skyType.value = SKY_TYPE.IMAGE;
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            });
        }

        // --- Main Loop ---
        let then = 0;
        function render(now) {
            now *= 0.001; const deltaTime = now - then; then = now;

            // --- FPS Management & Auto-Resolution ---
            while (frameTimes.length > 0 && frameTimes[0] <= now - 1.0) {
                frameTimes.shift(); // Remove frames older than 1 second
            }
            frameTimes.push(now);
            const currentFPS = frameTimes.length;

            if (now - lastFpsUpdateTime > FPS_UPDATE_INTERVAL) {
                if (ui.checkboxes.autoFps.checked) {
                    const targetFps = parseInt(ui.inputs.targetFps.value, 10) || 60;
                    const error = targetFps - currentFPS;
                    
                    // Proportional gain, adjust for more/less aggressive scaling
                    // A larger value reacts faster.
                    const kP = 0.002; 
                    
                    let currentRes = parseFloat(ui.sliders.resolution.value);
                    // CORRECTED LOGIC: We SUBTRACT the error.
                    // If FPS is low (e.g. 30) and target is 60, error is 30. We subtract, lowering resolution.
                    // If FPS is high (e.g. 90) and target is 60, error is -30. We subtract -30 (add 30), raising resolution.
                    let newRes = currentRes - (error * kP);
                    
                    const minRes = parseFloat(ui.sliders.resolution.min);
                    const maxRes = parseFloat(ui.sliders.resolution.max);
                    // Clamp the new resolution value to the slider's bounds
                    newRes = Math.max(minRes, Math.min(maxRes, newRes));
                    
                    ui.sliders.resolution.value = newRes.toFixed(3);
                }
                lastFpsUpdateTime = now;
            }
            
            handleCameraInput(deltaTime); updatePhysics(deltaTime);
            const resolutionScale = parseFloat(ui.sliders.resolution.value);
            resizeCanvasToDisplaySize(gl.canvas, resolutionScale);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clearColor(0, 0, 0, 0); gl.clear(gl.COLOR_BUFFER_BIT);

            gl.uniform2f(locs.res, gl.canvas.width, gl.canvas.height); gl.uniform1f(locs.time, now);
            gl.uniform3fv(locs.camPos, cameraPos); gl.uniform3fv(locs.camFront, cameraFront); gl.uniform3fv(locs.camUp, cameraUp);
            gl.uniform1f(locs.renderDistance, parseFloat(ui.sliders.distance.value)); gl.uniform1i(locs.raySteps, parseInt(ui.sliders.steps.value)); gl.uniform1i(locs.shadowSteps, parseInt(ui.sliders.shadow.value)); gl.uniform1f(locs.shadowSoftness, parseFloat(ui.sliders.shadowSoft.value));
            gl.uniform1i(locs.perfMode, ui.checkboxes.perf.checked);
            gl.uniform1i(locs.playerLightActive, playerLightOn); gl.uniform3fv(locs.playerLightPos, cameraPos);
            gl.uniform1i(locs.preview_active, previewShape.active);
            if (previewShape.active) { gl.uniform1i(locs.preview_type, previewShape.type); gl.uniform3fv(locs.preview_pos, previewShape.pos); gl.uniform4fv(locs.preview_param, previewShape.param); }
            
            // Sky Uniforms
            gl.uniform1i(locs.skyType, skyState.type);
            gl.uniform3fv(locs.skyColor, skyState.color);
            if (skyState.type === SKY_TYPE.IMAGE && skyState.texture) {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, skyState.texture);
                gl.uniform1i(locs.skybox, 0);
            }

            updateSceneUniforms();
            gl.enableVertexAttribArray(locs.pos); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.vertexAttribPointer(locs.pos, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }

        function updateSceneUniforms() {
            gl.uniform1i(locs.shapeCount, scene.shapes.length);
            if (scene.shapes.length > 0) {
                gl.uniform1iv(locs.shapes_type, scene.shapes.map(s => s.shaderType)); gl.uniform3fv(locs.shapes_pos, scene.shapes.flatMap(s => s.position)); gl.uniform4fv(locs.shapes_param, scene.shapes.flatMap(s => s.param)); gl.uniform4fv(locs.shapes_color, scene.shapes.flatMap(s => s.color)); gl.uniform1iv(locs.shapes_anim, scene.shapes.map(s => s.animType)); gl.uniform1iv(locs.shapes_material, scene.shapes.map(s => s.materialType));
            }
            gl.uniform1i(locs.lightCount, scene.lights.length);
            if (scene.lights.length > 0) {
                gl.uniform3fv(locs.lights_pos, scene.lights.flatMap(l => l.position)); gl.uniform3fv(locs.lights_color, scene.lights.flatMap(l => l.color));
            }
        }
        
        // --- Physics Engine ---
        function getShapeAABB(shape) {
            const pos = shape.position;
            let extents;
            switch (shape.shaderType) {
                case SHAPE_TYPE.SPHERE: extents = [shape.param[0], shape.param[0], shape.param[0]]; break;
                case SHAPE_TYPE.BOX: extents = [shape.param[0], shape.param[1], shape.param[2]]; break;
                case SHAPE_TYPE.CYLINDER: extents = [shape.param[0], shape.param[1], shape.param[0]]; break;
                case SHAPE_TYPE.PYRAMID: extents = [shape.param[0] * 0.5, shape.param[0] * 0.5, shape.param[0] * 0.5]; break; // Simplified AABB
                default: extents = [0, 0, 0];
            }
            return {
                min: [pos[0] - extents[0], pos[1] - extents[1], pos[2] - extents[2]],
                max: [pos[0] + extents[0], pos[1] + extents[1], pos[2] + extents[2]]
            };
        }

        function checkAndResolveAABBCollision(s1, s2) {
            const aabb1 = getShapeAABB(s1);
            const aabb2 = getShapeAABB(s2);

            const isColliding = (aabb1.min[0] < aabb2.max[0] && aabb1.max[0] > aabb2.min[0]) &&
                                (aabb1.min[1] < aabb2.max[1] && aabb1.max[1] > aabb2.min[1]) &&
                                (aabb1.min[2] < aabb2.max[2] && aabb1.max[2] > aabb2.min[2]);

            if (isColliding) {
                const overlap = [
                    Math.min(aabb1.max[0], aabb2.max[0]) - Math.max(aabb1.min[0], aabb2.min[0]),
                    Math.min(aabb1.max[1], aabb2.max[1]) - Math.max(aabb1.min[1], aabb2.min[1]),
                    Math.min(aabb1.max[2], aabb2.max[2]) - Math.max(aabb1.min[2], aabb2.min[2])
                ];
                
                let minOverlap = Infinity;
                let normal = [0,0,0];
                for (let i = 0; i < 3; i++) {
                    if (overlap[i] < minOverlap) {
                        minOverlap = overlap[i];
                        normal = [0,0,0]; normal[i] = 1;
                    }
                }
                
                const center1 = vec3.scale(vec3.add(aabb1.min, aabb1.max), 0.5);
                const center2 = vec3.scale(vec3.add(aabb2.min, aabb2.max), 0.5);
                if (vec3.dot(vec3.subtract(center2, center1), normal) < 0) {
                    normal = vec3.scale(normal, -1);
                }

                // Resolve penetration
                const penetration = minOverlap * 1.01; // Epsilon to prevent re-collision
                const move = vec3.scale(normal, penetration / 2);
                if (!s1.isStatic) s1.position = vec3.subtract(s1.position, move);
                if (!s2.isStatic) s2.position = vec3.add(s2.position, move);
                
                // Resolve velocity
                const relativeVelocity = vec3.subtract(s2.velocity, s1.velocity);
                const velAlongNormal = vec3.dot(relativeVelocity, normal);
                if (velAlongNormal > 0) return; // Objects are separating
                
                const restitution = 0.2; // Low restitution for stacking
                let impulseScalar = -(1 + restitution) * velAlongNormal;
                impulseScalar /= (1 / s1.mass) + (1 / s2.mass);
                
                const impulse = vec3.scale(normal, impulseScalar);
                if (!s1.isStatic) s1.velocity = vec3.subtract(s1.velocity, vec3.scale(impulse, 1 / s1.mass));
                if (!s2.isStatic) s2.velocity = vec3.add(s2.velocity, vec3.scale(impulse, 1 / s2.mass));
            }
        }
        
        function updatePhysics(deltaTime) {
            const physicsShapes = scene.shapes.filter(s => s.hasPhysics);
            if (physicsShapes.length === 0) return;

            // Apply gravity
            for (const shape of physicsShapes) {
                if (shape.hasGravity && !shape.isStatic) {
                    shape.velocity[1] += GRAVITY * deltaTime;
                }
            }
            
            // Solver iterations
            for (let i = 0; i < SOLVER_ITERATIONS; i++) {
                // Object-Object collisions
                for (let j = 0; j < physicsShapes.length; j++) {
                    for (let k = j + 1; k < physicsShapes.length; k++) {
                        checkAndResolveAABBCollision(physicsShapes[j], physicsShapes[k]);
                    }
                }

                // Ground collision
                for (const shape of physicsShapes) {
                    const aabb = getShapeAABB(shape);
                    if (aabb.min[1] < groundLevel) {
                        const penetration = groundLevel - aabb.min[1];
                        shape.position[1] += penetration;
                        const restitution = 0.2;
                        if (shape.velocity[1] < 0) {
                            shape.velocity[1] *= -restitution;
                            if (Math.abs(shape.velocity[1]) < 0.1) shape.velocity[1] = 0;
                        }
                    }
                }
            }

            // Update positions
            for (const shape of physicsShapes) {
                if (!shape.isStatic) {
                   shape.position = vec3.add(shape.position, vec3.scale(shape.velocity, deltaTime));
                }
            }
        }

        function updatePreviewObject() {
            if (!placementMode.active) return;
            let rayDir = cameraFront;
            let rayOrigin = cameraPos;
            
            let closestHit = { t: Infinity, normal: [0,1,0] };

            // Check floor intersection
            if (rayDir[1] < 0) {
                let t = (0 - rayOrigin[1]) / rayDir[1];
                if (t > 0 && t < closestHit.t) {
                    closestHit.t = t;
                    closestHit.normal = [0,1,0];
                }
            }
            
            // Check shape intersections (Ray vs AABB)
            for (const shape of scene.shapes) {
                const aabb = getShapeAABB(shape);
                let tmin = (aabb.min[0] - rayOrigin[0]) / rayDir[0];
                let tmax = (aabb.max[0] - rayOrigin[0]) / rayDir[0];
                if (tmin > tmax) [tmin, tmax] = [tmax, tmin];
                
                let tymin = (aabb.min[1] - rayOrigin[1]) / rayDir[1];
                let tymax = (aabb.max[1] - rayOrigin[1]) / rayDir[1];
                if (tymin > tymax) [tymin, tymax] = [tymax, tymin];

                if ((tmin > tymax) || (tymin > tmax)) continue;
                if (tymin > tmin) tmin = tymin;
                if (tymax < tmax) tmax = tymax;

                let tzmin = (aabb.min[2] - rayOrigin[2]) / rayDir[2];
                let tzmax = (aabb.max[2] - rayOrigin[2]) / rayDir[2];
                if (tzmin > tzmax) [tzmin, tzmax] = [tzmax, tzmin];

                if ((tmin > tzmax) || (tzmin > tmax)) continue;
                if (tzmin > tmin) tmin = tzmin;
                if (tzmax < tmax) tmax = tzmax;

                if (tmin > 0 && tmin < closestHit.t) {
                    closestHit.t = tmin;
                    // Simplified normal calculation
                    const hitPoint = vec3.add(rayOrigin, vec3.scale(rayDir, tmin));
                    const center = shape.position;
                    const d = vec3.subtract(hitPoint, center);
                    const absD = d.map(Math.abs);
                    if (absD[0] > absD[1] && absD[0] > absD[2]) closestHit.normal = [Math.sign(d[0]), 0, 0];
                    else if (absD[1] > absD[0] && absD[1] > absD[2]) closestHit.normal = [0, Math.sign(d[1]), 0];
                    else closestHit.normal = [0, 0, Math.sign(d[2])];
                }
            }

            if (closestHit.t < Infinity) {
                const worldPos = vec3.add(cameraPos, vec3.scale(rayDir, closestHit.t));
                const size = parseFloat(ui.sliders.size.value);
                let halfExtents = [0,0,0];
                if (placementMode.object === 'cube') { previewShape.type = SHAPE_TYPE.BOX; previewShape.param = [size, size, size, 0]; halfExtents = [size,size,size]; }
                else if (placementMode.object === 'sphere') { previewShape.type = SHAPE_TYPE.SPHERE; previewShape.param = [size, 0, 0, 0]; halfExtents = [size,size,size]; }
                else if (placementMode.object === 'cylinder') { previewShape.type = SHAPE_TYPE.CYLINDER; previewShape.param = [size * 0.5, size, 0, 0]; halfExtents = [size*0.5, size, size*0.5];}
                else if (placementMode.object === 'pyramid') { previewShape.type = SHAPE_TYPE.PYRAMID; previewShape.param = [size * 1.5, 0, 0, 0]; halfExtents = [size*0.75, size*0.75, size*0.75]; }
                else if (placementMode.type === 'light') { previewShape.type = SHAPE_TYPE.SPHERE; previewShape.param = [0.2, 0, 0, 0]; halfExtents = [0.2, 0.2, 0.2]; }

                const offset = vec3.scale(closestHit.normal, vec3.dot(halfExtents, closestHit.normal.map(Math.abs)));
                previewShape.pos = vec3.add(worldPos, offset); 
            }
        }

        function placeObject() {
            if (!placementMode.active || previewShape.pos[1] > 1000) return;
            const size = parseFloat(ui.sliders.size.value);
            if (placementMode.type === 'shape') {
                if (scene.shapes.length >= MAX_SHAPES) return;
                let finalParam, mass;
                if (placementMode.object === 'cube') { finalParam = [size, size, size, 0]; mass = size*size*size; }
                else if (placementMode.object === 'sphere') { finalParam = [size, 0, 0, 0]; mass = (4/3)*Math.PI*size*size*size; }
                else if (placementMode.object === 'cylinder') { finalParam = [size * 0.5, size, 0, 0]; mass = Math.PI * (size*0.5)**2 * (size*2); }
                else if (placementMode.object === 'pyramid') { finalParam = [size * 1.5, 0, 0, 0]; mass = (1/3) * (size*1.5)**2 * (size*1.5); }
                
                const shape_color = hexToRgb(ui.pickers.shape.value);
                const materialType = parseInt(ui.selects.material.value);
                const hasPhysics = ui.checkboxes.physics.checked;
                const newShape = { position: [...previewShape.pos], param: finalParam, shaderType: previewShape.type, velocity: [0, 0, 0], color: [shape_color[0], shape_color[1], shape_color[2], ui.checkboxes.emissive.checked ? 1.0 : 0.0], hasPhysics: hasPhysics, hasGravity: ui.checkboxes.gravity.checked, isStatic: !hasPhysics, mass: hasPhysics ? mass : Infinity, animType: parseInt(ui.selects.anim.value), materialType: materialType };

                if (materialType === MATERIAL_TYPE.MIRROR) newShape.color = [1.0, 1.0, 1.0, newShape.color[3]];
                scene.shapes.push(newShape);
            } else if (placementMode.type === 'light') {
                if (scene.lights.length >= MAX_LIGHTS) return;
                scene.lights.push({ position: [...previewShape.pos], color: hexToRgb(ui.pickers.light.value) });
            }
        }

        function setupEventListeners() {
            document.addEventListener('keydown', (e) => {
                keysPressed[e.key.toLowerCase()] = true;
                if (e.key.toLowerCase() === 'f') { playerLightOn = !playerLightOn; ui.checkboxes.playerLight.checked = playerLightOn; }
            });
            document.addEventListener('keyup', (e) => { keysPressed[e.key.toLowerCase()] = false; });
            canvas.addEventListener('click', () => {
                if (placementMode.active) { placeObject(); placementMode.active = false; previewShape.active = false; document.querySelectorAll('.btn.active').forEach(btn => btn.classList.remove('active')); canvas.requestPointerLock(); } 
                else { if (!pointerLocked) canvas.requestPointerLock(); }
            });
            document.addEventListener('pointerlockchange', () => { pointerLocked = document.pointerLockElement === canvas; document.body.style.cursor = pointerLocked ? 'none' : 'auto'; });
            document.addEventListener('mousemove', (e) => {
                if (pointerLocked) {
                    yaw += e.movementX * 0.1; pitch -= e.movementY * 0.1; pitch = Math.max(-89, Math.min(89, pitch));
                    cameraFront = vec3.normalize([Math.cos(degToRad(yaw)) * Math.cos(degToRad(pitch)), Math.sin(degToRad(pitch)), Math.sin(degToRad(yaw)) * Math.cos(degToRad(pitch))]);
                } else {
                    updatePreviewObject();
                }
            });
        }

        function handleCameraInput(deltaTime) {
            updatePreviewObject(); // Keep preview updated even when not locked
            const speed = 5.0 * deltaTime;
            const right = vec3.normalize(vec3.cross(cameraFront, cameraUp));
            if (keysPressed['w']) cameraPos = vec3.add(cameraPos, vec3.scale(cameraFront, speed));
            if (keysPressed['s']) cameraPos = vec3.subtract(cameraPos, vec3.scale(cameraFront, speed));
            if (keysPressed['a']) cameraPos = vec3.subtract(cameraPos, vec3.scale(right, speed));
            if (keysPressed['d']) cameraPos = vec3.add(cameraPos, vec3.scale(right, speed));
            if (keysPressed['q']) cameraPos = vec3.subtract(cameraPos, vec3.scale(cameraUp, speed));
            if (keysPressed['e']) cameraPos = vec3.add(cameraPos, vec3.scale(cameraUp, speed));
        }

        // --- WebGL Helpers ---
        function createShader(gl, type, source) { const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader; console.error(gl.getShaderInfoLog(shader)); gl.deleteShader(shader); }
        function createProgram(gl, vs, fs) { const p = gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); if (gl.getProgramParameter(p, gl.LINK_STATUS)) return p; console.error(gl.getProgramInfoLog(p)); gl.deleteProgram(p); }
        function resizeCanvasToDisplaySize(canvas, resolutionScale = 1.0) { const dW=canvas.clientWidth,dH=canvas.clientHeight;const nW=Math.floor(dW*resolutionScale),nH=Math.floor(dH*resolutionScale);if(canvas.width!==nW||canvas.height!==nH){canvas.width=nW;canvas.height=nH;return true;}return false; }
        function createTextureFromImage(image) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            return texture;
        }

        // --- Init ---
        setupEventListeners();
        setupUI();
        requestAnimationFrame(render);
    </script>
</body>
</html>
